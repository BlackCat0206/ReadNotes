# C++_Something

---- Lee

***

## 一、C++基础

### 静态局部变量，全局变量，局部变量的特点

| 分类       | 静态局部变量                | 全局变量                       | 局部变量                       |
| ---------- | --------------------------- | ------------------------------ | ------------------------------ |
| 作用域     | 所声明的函数或代码块中      | 整个程序中                     | 所声明的函数和代码块中         |
| 生命周期   | 程序开始到程序结束          | 程序开始到程序结束             | 每次进入函数创建，用完后销毁   |
| 存储位置   | 数据段或BSS段               | 数据段或BSS段                  | 栈区                           |
| 初始化行为 | 只初始换一次，默认初始换为0 | 只初始换一次，默认初始化为0    | 若不初始换其结果未知           |
| 适用场景   | 在函数中实现记录之前的值。  | 整个程序共享的信息，比如配置等 | 用于临时计算，循环体中的变量。 |

### 指针和引用的区别

| 分类             | 指针                                     | 引用                                                         |
| ---------------- | ---------------------------------------- | ------------------------------------------------------------ |
| 数据类型         | 变量                                     | 对象的别名                                                   |
| 存储空间         | 有独立的存储空间，用来存放地址           | 与对象共享存储空间                                           |
| 初始化           | 声明后可以不用初始化，可以为`nullptr`    | 必须要初始化                                                 |
| 是否可以重新赋值 | 可以修改其所指对象                       | 引用一旦绑定就不能绑定其他对象                               |
| 适用场景         | 动态分配内存，需要判断NULL，多级间接访问 | 函数传参时对于大型的对象，避免拷贝的开销，必须要绑定有效的对象，链式调用（返回*this）,运算符重载 |

## 二、关键字

### `const`关键字的作用

修饰指针、引用、成员函数函数、等性质：

* `const`变量：既说明该变量的值不能被修改。

* `const`与指针

  * （`const pointer`）常量指针：指针中所保存的地址不能修改。顶层`const`

  ```cpp
  int* const p;
  ```

  * (`pointer to const`) 指向常量的指针。指针所指向的内容是常量，不能通过指针来修改所指对象的内容。底层`const`

  ```coo
  const int* p;
  ```

  * （`const pointer to const`）指向常量的常量指针。所存放的地址不能修改，不能通过指针修改所指对象。

  ```cpp
  const int* const p;
  ```

* `const`与引用：底层`const`，不能通过引用修改其所绑定对象。
* `const`与成员函数：表示该函数不会修改对象的任何非静态的成员变量。
* 常量对象：表示类所实现的对象是常量，其成员变量不能修改。
* 常量引用传参：表示函数不会修改引用所绑定的对象。
* 指向常量的指针传参：表示函数不会通过指针修改其所指向的内容。

### `static`关键字的作用

修改变量、函数的生命周期，作用域和访问权限。

* 静态变量：
  * 生命周期：程序运行开始到程序运行结束。
  * 作用域：当前整个文件
  * 初始换：只初始换一次，默认初始换结果是0。
* 静态函数：
  * 在类内使用`static`修饰的函数是静态函数。
  * 静态函数属于类，但不属于类的实例，可以通过类名直接调用，而无序创建对象。
  * 静态函数不能访问类中非静态的成员变量/函数。
* 静态成员变量：
  * 在类内使用`static`修饰的成员变量就是静态成员变量。
  * 所有类的对象共享一个静态成员变量的副本。
  * 在类内声明，在类外初始换。
* 静态局部变量：
  * 生命周期：程序运行开始到程序结束。
  * 作用域：在声明它所在的函数或者代码段中。
  * 初始化：只初始换一次，默认初始化是0。
  * 存储位置：全局数据区

### `#define`和`typedef`的区别

| 分类     | `#define`                      | `typedef`                                                    |
| -------- | ------------------------------ | ------------------------------------------------------------ |
| 功能     | 字符串替换，不会进行类型检查。 | 定义变量的别名对进行类型检查                                 |
| 作用阶段 | 在编译的预处理阶段             | 在编译、运行时起作用                                         |
| 内存空间 | 没有独立的内存空间             | 在静态存储空间中分配内存，在程序运行过程中内存中只有一个拷贝 |
| 其他作用 | 可以防止头文件重复包含。       |                                                              |

### `#define`和`inline`的区别

| 分类   | `#define`                    | `inline`                                                     |
| ------ | ---------------------------- | ------------------------------------------------------------ |
| 功能   | 字符串替换，不会进行类型检查 | 将编译好的函数体插入到其所调用的位置，减少压栈，跳转和返回的操作。没有不同函数调用时的开销。 |
| 有效性 | 有效                         | 只是一种请求，编译器不一定要执行。                           |

### C++中`inline`的限制

* 函数体中不能有循环语句。
* 函数体中存在过多的条件判断语句。
* 函数体不能太过庞大。
* 内联函数的声明必须在其调用之前。

### `const`和`#define`的区别

| 分类       | `#define`                                  | `const`                            |
| ---------- | ------------------------------------------ | ---------------------------------- |
| 生效的阶段 | 编译的预处理阶段                           | 编译的阶段                         |
| 类型检查   | 字符串替换，不会进行类型检查               | 定义常量是带类型的，回进行类型检查 |
| 存储空间   | 其定义的常量是运行时的操作数，没有内存空间 | 需要额外的存储空间                 |
| 额外作用   | 防止头文件重复包含                         |                                    |

### `new`和`malloc`的区别

| 分类                    | `new`                                                        | `malloc`                             |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------ |
| 本质                    | 运算符                                                       | 标准库函数                           |
| 调用失败                | 返回`bad_alloc`                                              | 返回`NULL`                           |
| 类型安全                | 安全，不需要转换                                             | 不安全，需要强制转换                 |
| 构造函数/析构函数的调用 | new/delete会分别调用对象的构造和析构函数，实现对象的构成和析构 | 不会调用                             |
| 分配空间大小            | 不需要传入所需分配空间的大小                                 | 需要手动计算并传入所需分配的空间大小 |
| 分配空间                | 自由存储区                                                   | 堆区                                 |
| 重载                    | operator new/operator delete 可以被重载                      | 不可以                               |
| 关系                    | new封装了`malloc`                                            |                                      |

### `const`和`constexper`

| 分类     | `constexper`                                                 | `const`                                      |
| -------- | ------------------------------------------------------------ | -------------------------------------------- |
| 常量定义 | 只能定义编译时期的常量                                       | 可以定义编译时的常量，而可以定义运行时的常量 |
| 初始换   | 必须适用常量初始换                                           | void* const p = a;                           |
| 对于指针 | `constexper int* p`修饰的是指针本身而不是其所指内容          | (const pointer)/(pointer to const)           |
| 函数     | 能用于常量表达式的函数，其返回值和形参都是字面值，函数体只有一个`return`语句 | 成员函数不会修改对象中非静态的成员。         |
| 构造函数 | 字面值常量类：必须有一个空的函数体，既所有成员都在初始列表中。对象调用成员函数时必须加`constexper`修饰 |                                              |

### `constexper`好处

* 为一些不修改数据的场景提供保障，写成变量就有被修改的风险。
* 有些场景编译器可以对`constexper`的代码进行优化，提高效率。
* 相比较于宏来说，没有额外的开销，更加安全。

### `volatile`

作用：对编译的结果有影响，告知编译器其所修饰的变量随时可能发生改变，于该变量有关的计算，不要进行编译优化。要用内存中直接去读，而不是去寄存器中。

适用场景：在中断服务程序和cpu相关寄存器的定义。

### `extern`

* 声明全局变量（函数或者文件外声明的全局变量）
* 多次声明是合法的，但只能有一个定义（否则链接错误：`multiple definition`）

```CPP
extern int x; // 声明，不分配内存，定义才分配内存。
```

* C++和C的混合编程：

```cpp
extern "C" { /* C函数声明 */ } //告诉C++编译器按照C规则链接
```

#### **常见面试问题**

- **Q1：`extern int x;` 和 `int x;` 的区别？** **A**：

  - `extern int x;` 是声明，不分配内存，需依赖其他文件的定义。
  - `int x;` 是定义，分配内存（若多次定义会导致链接错误）。

- **Q2：如何在 C++ 中调用 C 函数？** **A**：

  ```
  // 方式1：直接声明
  extern "C" void c_function(int);
  // 方式2：包含C头文件
  extern "C" {
      #include <cstdio> // 例如调用printf
  }
  ```

- **Q3：`extern` 与 `static` 的关系？** **A**：

  - `extern` 使变量 / 函数具有**外部链接属性**（跨文件可见）。
  - `static` 使变量 / 函数具有**内部链接属性**（仅当前文件可见）。

`extern` 关键字的核心价值在于：

- **分离声明与定义**：实现跨文件共享全局资源。
- **兼容 C 语言**：通过 `extern "C"` 解决函数名修饰问题。
- **优化编译**：结合模板显式实例化减少重复编译。

### 前置++和后置++

```cpp
// 前置
self& opeartor++()
{
    node = (node->next);
    return node;
}

// 后置
const self opeator(int)
{
 	self *temp = *this;
    ++*this;
    return 	temp;
}
```

#### 1.为什么后置返回的是对象，前置返回的是引用？

后置返回了一个临时对象，函数调用后就销毁。

#### 2.为什么后置的返回值要加`const`

为了规避后置自增重复调用的情况。

### `std::atomic`

待定

### 什么是函数指针，如何定义和使用场景

函数指针：指向函数的指针，其可以存储函数的地址，在运行时动态的选择需要调用的函数。

使用场景：

* **回调函数**：实现回调机制，将函数的地址传递给其他参数，在适当的时候调用函数。
* **函数指针数组**：可以使用函数指针数组实现状态机的逻辑，在不同状态下调用不同的函数。
* **函数指针作为参数**：将函数地址传递给其他函数，实现一种函数可插拔的行为。
* **多态的实现**：C++中虚函数与函数指针结合使用，可以实现类似于多态的一种效果。

```c
// 创建圆：绑定“圆的面积函数”到函数指针
Shape* create_circle(double radius) {
    Shape* s = (Shape*)malloc(sizeof(Shape));
    s->calc_area = circle_area;  // 函数指针指向圆的实现
    s->data.circle.radius = radius;
    return s;
}

// 创建矩形：绑定“矩形的面积函数”到函数指针
Shape* create_rectangle(double w, double h) {
    Shape* s = (Shape*)malloc(sizeof(Shape));
    s->calc_area = rectangle_area;  // 函数指针指向矩形的实现
    s->data.rectangle.w = w;
    s->data.rectangle.h = h;
    return s;
}
```

* **函数映射表**：更具某些特定的条件调用不同的函数，可以使用函数指针组成函数映射表。
* **加载动态库**：可以用于在运行时动态加载库中的函数，实现动态链接库的作用

### 函数指针和指针函数的区别

* 函数指针：其本质是一个指针，其保存着函数的地址。
* 指针函数：其本事是一个函数，其返回值类型是指针类型，用于返回某些数据类型的数据指针。

### `struct`和`Class`的区别

* 相同点：

​	如果`struct`没有定义任何构造函数，编译器会默认为其生成一个无参的构造函数。

​	如果`class`没有定义任何构造函数，编译器会默认为其生成一个无参的构造函数。

* 不同点：
  * `struct`中存储的一组有关的数据，`class`用于表示封装了数据和操作的对象。
  * `struct`默认成员访问权限是`public`，`class`默认成员的访问权限是`private`。
  * `struct`默认继承的权限是`public`，`class`默认的继承权限是`private`。

## 三、C++ 类型转换知识点总结表

| 转换类型                         | 语法格式                             | 核心特点                                                     | 适用场景                                                     | 安全性 / 注意事项                                            |
| -------------------------------- | ------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 隐式转换（自动）                 | `type2 var = type1_val;`             | 编译器自动完成，无需显式声明；仅支持 “低风险” 转换（如小类型转大类型）。 | 1. 算术类型兼容转换（如 `char→int`、`int→double`）；2. 派生类指针 / 引用转基类；3. 非 `explicit` 构造函数的类型转换。 | 1. 基本类型提升（如 `int→long`）安全；2. 大类型转小类型（如 `double→int`）会截断；3. 空指针转任意指针类型安全。 |
| 静态转换（static_cast）          | `static_cast<目标类型>(源对象)`      | **编译期**检查，支持隐式转换的反向操作（需保证逻辑合法）；不检查类型继承关系的安全性。 | 1. 基本类型的显式转换（如 `double→int`）；<br />2. 类层次中基类 / 派生类指针 / 引用的转换（无运行时检查）；<br />3. 非 `const` 转 `const`（反向不行）；<br />4. 空指针 /void 指针与具体类型指针互转。 | 1. 派生类转基类安全；2. 基类转派生类（无多态）可能不安全（无运行时类型校验）；<br />3. 不支持无关类型（如 `int→char*`）转换。 |
| 动态转换（dynamic_cast）         | `dynamic_cast<目标类型>(源对象)`     | **运行时**检查，仅支持多态类型（含虚函数的类）的转换；<br />失败时**返回空指针（指针转换）或抛异常（引用转换）**。 | 1. 类层次中安全的向下转换（基类指针 / 引用转派生类）；<br />2. 交叉转换（同一基类的不同派生类之间）。 | 1. 仅适用于多态类；<br />2. 指针转换失败返回 `nullptr`，引用转换失败抛 `std::bad_cast`；3. 运行时开销略大。 |
| 常量转换（const_cast）           | `const_cast<目标类型>(源对象)`       | 仅用于添加 / 移除 `const`/`volatile` 属性；不改变对象的其他类型。 | 1. 移除**指针 / 引用**的 `const` 限定（需确保对象实际非 `const`，否则修改未定义）；<br />2. 给非 `const` 对象添加 `const`。 | 1. 仅作用于指针 / 引用 / 成员指针；<br />2. 移除 `const` 后修改原本 `const` 对象会导致未定义行为；<br />3. 不支持基本类型的 `const` 转换（如 `const int→int`）。 |
| 重新解释转换（reinterpret_cast） | `reinterpret_cast<目标类型>(源对象)` | 编译期转换，直接重新解释二进制位；不做类型检查，最 “暴力” 的转换。 | 1. 无关类型指针 / 引用互转（如 `int*→char*`）；<br />2. 指针与整数类型互转（如 `int*→uintptr_t`）；3. 函数指针与普通指针互转。 | 1. 高度危险，仅适用于底层编程；<br />2. 转换结果依赖平台（二进制布局），可移植性差；<br />3. 不保证转换后对象可合法访问。 |

### `sizeof`操作符：

`sizeof`一元操作符，用于获取变量或类型所占用的字节大小。

* 返回值：`size_t`无符号类型

* 编译期计算：不执行表达式，仅分析内容。

* `sizeof`与表达式：

  * 不执行表达式：

  ```cpp
  int func() { return 42; }
  sizeof(func());		// 返回4字节，不执行表达式
  ```

  * 引用：

  ```cpp
  int x = 0;
  int& xf = x;
  sizeof(xf);			// 4字节（引用类型的大小等于被引用类型的大小）
  ```

  * 空类/结构体

  ```cpp
  struct Empty{};
  sizeof(Empty);		// 1字节
  ```

  * 虚函数

  ```cpp
  class Base {
      virtual void func() {}
  };
  sizeof(Base);	// 一个指针的大小
  ```

* 【知识拓展】

  * 与`decltype`结合`sizeof`

  ```cpp
  int x = 0;
  sizeof(decltype(x));		// 4字节
  ```

  * 条件编译

  ```cpp
  #if sizeof(void*) == 8
  
  #else
  
  #endif
  ```

  * 函数参数中的数组

  ```cpp
  void func(int arr[])		// 退化为指针
  {
      sizeof(arr);			// 一个指针的大小
  }
  ```

### C++中`nullptr`和`NULL`的区别

| 特性       | nullptr         | NULL                |
| ---------- | --------------- | ------------------- |
| 定义       | C++11新增关键字 | 宏，通常表示为整形0 |
| 类型       | std::nullptr    | 整数常量            |
| 类型安全性 | 安全            | 不安全              |
| 转换为整数 | 不可以          | 可以                |
| 推荐使用   | 是              | 否                  |

## 四、C++ STL

### 简述STL的容器

| 序列容器        | 功能                                             |
| --------------- | ------------------------------------------------ |
| `vector`        | 动态数组，支持随机访问，尾部插入快，插入元素很慢 |
| `list`          | 双向链表，支持快速插入/删除，不支持随机访问      |
| `deque`         | 双向队列，支持头部和尾部快速插入/删除            |
| `array`         | 固定大小的数组                                   |
| `forworad_list` | 单向链表                                         |

| 关联容器   | 功能                                             |
| ---------- | ------------------------------------------------ |
| `map`      | 有序，支持键值对匹配，且只有位置key对应唯一value |
| `multimap` | 有序，支持键值对匹配，一个key可对应多个value     |
| `set`      | 唯一元素自动排序集合                             |
| `multiset` | 集合，自动排序，元素可以重复                     |

| 无序容器             | 功能                                          |
| -------------------- | --------------------------------------------- |
| `unordered_set`      | 无序，唯一元素集合，可快速查找。              |
| `unordered_map`      | 无序，键值对，`Key`不允许重复，支持快速查找。 |
| `unordered_multiset` | 无序，元素可重复集合                          |
| `unordered_multimap` | 无序，可以重复键值对                          |

### `vector`和`array`的使用场景分别是什么？

| 功能       | `vector`             | `array`                  |
| ---------- | -------------------- | ------------------------ |
| 大小       | 动态变化             | 固定的                   |
| 存储位置   | 堆                   | 栈                       |
| 引入时间   | C++98                | C++11                    |
| 元素的访问 | 下标和迭代器         | 下标和迭代器             |
| 效率       | 稍慢（动态内存分配） | 快（栈中，没有额外开销） |
| 适用场景   | 需要动态增长         | 关注性能和效率           |

### `array`相较于传统数组的优势：

* 支持STL算法，迭代器。
* 类型安全，避免退化指针的问题。

### 描述下`vector`如何保证元素连续存储？

`vector`以**动态数组**作为内部数据结构，内部使用了一个**单一的内存块**用来存储数组中的元素，并管理着**内存块的大小和容量**。当内存块的**容量不足**时，就申请一个更大的内存块，并将之前内存块中的数据复制到新的内存块中。

### 当`vector`空间不足以容纳元素时，它是如何扩容的。

`vector`在空间不足时，会进行扩容。`vector`内部实现了一个扩容函数，当容量不足时，它会申请一块**原内存块1.5~2倍的内存块**，之后将原内存中数据拷贝至新申请的内存块中。

在拷贝的过程中使用**语义移动复制对象**还是**拷贝构造**。取决于对象是否支持**语义移动**，实现了**移动构造函数**。

### `vector`中`push_back()`和`emplace_back()`有什么区别？

| 类别     | `push_back()`                                                | `emplace_back()`                                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 参数     | 值、对象、对象的引用、右值                                   | 不接受直接参数，接受**构造新元素的参数列表**                 |
| 参数添加 | 左值：使用拷贝构造函数一个副本，添加到向量尾部。<br />右值：使用移动构造函数移动它 | 直接使用参数列表在向量的尾部构造新元素                       |
| 扩容     | 可能会引发扩容，将元素添加至新内存中                         | 不会引发扩容，出发向量的容量已到达它的上限                   |
| 小结     | `emplace_back`相较于`push_back()`省去了**临时对象构建和销毁的开销**。 | `emplace_back`完美转发，既参数的类别（左值、右值）会被很好的记录下来。 |

```cpp
#include <vector>
#include <string>

int main() {
   std::vector<std::string> v;

   // 使用push_back添加元素
   v.push_back("Copy or move this string");

   // 使用emplace_back就地构造元素
   v.emplace_back("Constructed in place");

   return 0;
}

```

### list和vector有什么区别？ （考点：list与vector的比较）

| 类别         | `vector`                                                     | `list`                                                       |
| ------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 底层数据结构 | 动态数组<br />在内存中是连续存储的                           | 双向链表<br />在内存中不是连续存储的，<br />每个节点包含一个指向前一个元素和指向后一个元素的指针 |
| 内存分配     | 一次性分配好，不足时会扩容                                   | 每插入新节点都要进行内存申请。                               |
| 随机访问     | 支持高效地随机访问，时间复杂度O(1)                           | 不支持随机访问                                               |
| 插入和删除   | 尾部添加和删除：O(1)<br />中间元素中添加和删除：O(n)<br />导致元素的拷贝 | 任意节点的添加和删除操作：O(1)<br />但找到对应节点的时间复杂度：O(n)<br />插入和删除不会导致 |
| 迭代器       | 支持随机访问                                                 | 不支持随机防止，只支持++/--                                  |
| 适用场景     | 数据要连续存储，且频繁的随机访问。                           | 数据不频繁访问，需要频繁的添加、删除                         |

### list是如何实现元素的插入和删除的？

插入：位移值插入元素下标的前一个元素。

* 插入元素向后指针指向当前元素的下一个元素，下一个向前的指针，指向新插入的元素。
* 当前元素的指向下一个元素的指针指向插入元素，插入元素指向前一个元素的指针指向当前元素。

删除：位移值删除元素下标的前一个元素。

* 保留将被删除元素的指针，当前元素指向将被删除元素的下一个元素。被删除的元素的下一个元素指向前一个元素的指针指向当前元素。
* 释放保留的被删除元素的指针。

### `set`的底层实现和`map`有什么不同？

| 类别         | `set`                | `map`                          |
| ------------ | -------------------- | ------------------------------ |
| 底层数据结构 | 平衡二叉树（红黑树） | 平衡二叉树（红黑树）           |
| 存储内容     | 键                   | 键值对                         |
| 区别         | 键就是元素本身       | 键值是键，值是和它相关联的数据 |

### map、set、multimap、multiset有什么区别？

| 类别       | `set`                                  | `multiset`                                                   | `map`                       | `multimap`                                                   |
| ---------- | -------------------------------------- | ------------------------------------------------------------ | --------------------------- | ------------------------------------------------------------ |
| 存储内容   | 键（元素本身），不可以重复             | 键（元素本身）可以重复                                       | 键值对，Key是唯一的不能重复 | 键值对，允许多个值有相同的Key                                |
| 元素唯一性 | 键唯一，不允许重复                     | 允许有重复键                                                 | 不允许有重复键值对          | 允许多个值有相同的键                                         |
| 排序       | 按照元素自动排序                       | 按照元素自动排序，对于**有相同值的元素**，其内部是有序的（通常是插入顺序） | 按照元素自动排序            | 按照元素自动排序，对于**有相同值的元素**，其内部是有序的（通常是插入顺序） |
| 访问       | 只能通过迭代器访问，不允许通过下标访问 | 只能通过迭代器范围，不允许通过下标访问                       | 允许通过下标访问            | 允许通过下标访问，但不能直接访问**特定键的所有值，需要遍历** |

### 如何在map和set中查找元素？ （考点：元素查找）

* `find()`：返回找到指向传入值的元素的迭代器，若未找到，返回`end()`。
* `count()`：返回查找值的数量，`set`和`map`中元素是唯一的，返回0（未找到）或1（找到）
* `lower_bound()`：返回一个指向**不小于**给定键的**首个元素的迭代器。**
* `upper_bound()`：返回一个指向**大于**给定键的**首个元素的迭代器**。
* `equal_range()`：返回一个迭代对，`lower_bound`和`upper_bound`，对于不存在的键，它们是相同的。对于**唯一键**，它们是不同的。

#### 详细回答

**std::map**

1. find 方法：

- 直接使用 find 方法查找特定键的值。
- 如果找到了，返回一个指向该元素的迭代器；如果没有找到，返回一个指向 end() 的迭代器。

```
std::map<int, std::string> myMap;
myMap[1] = "one";
myMap[2] = "two";

auto it = myMap.find(1);
if (it != myMap.end()) {
    std::cout << "Found: " << it->second << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

1. count 方法：

- count 方法用于返回具有特定键的元素数量。由于 std::map 中的键是唯一的，所以返回值要么是0（未找到），要么是1（找到）。

```
size_t count = myMap.count(1);
if (count > 0) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

1. lower_bound 和 upper_bound 方法：

- lower_bound 返回指向不小于给定键的首个元素的迭代器。
- upper_bound 返回指向大于给定键的首个元素的迭代器

```
auto lower = myMap.lower_bound(1);
auto upper = myMap.upper_bound(1);
if (lower != upper) {
    std::cout << "Found: " << lower->second << std::endl;
}
```

1. equal_range 方法：

equal_range 返回一个迭代器对，第一个是 lower_bound，第二个是 upper_bound。

```
auto range = myMap.equal_range(1);
if (range.first != range.second) {
    std::cout << "Found: " << range.first->second << std::endl;
}
```

##### std::set

1. find 方法：

```
std::set<int> mySet;
mySet.insert(1);
mySet.insert(2);

auto it = mySet.find(1);
if (it != mySet.end()) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

1. count 方法：

```
size_t count = mySet.count(1);
if (count > 0) {
    std::cout << "Found" << std::endl;
} else {
    std::cout << "Not found" << std::endl;
}
```

1. lower_bound 和 upper_bound 方法：

```
auto lower = mySet.lower_bound(1);
auto upper = mySet.upper_bound(1);
if (lower != upper) {
    std::cout << "Found" << std::endl;
}
```

1. equal_range 方法：

```
auto range = mySet.equal_range(1);
if (range.first != range.second) {
    std::cout << "Found" << std::endl;
}
```

### 容器 map 、deque、list的实现原理？

* std::map
  * 底层数据结构：红黑树（平衡二叉搜索树）
  * 存储内容：键值对
  * 有序容器：元素按照键的顺序进行排序，通常按照小于运算符定义的。
  * 时间复杂度：查找，插入、删除O(logn)。
  * 迭代器访问：通过迭代器遍历是有序的。
* std::deque
  * 双端队列，支持头部和尾部快速插入和删除操作。
  * 基于一个节点数组实现，每个节点存储一部分元素并可以动态的增加和删除节点。
  * 时间复杂度：常数级队首和队尾的插入和删除。在中间元素中添加和删除O(n)。
* std::list:
  * std::list是一个双向链表，支持在任意位置上添加和删除元素的能力。每个节点包含数据和两个指针（前序，后继），分别指向前一个节点和后一个节点。
  * 无序容器：
  * 插入和删除：提供高效的插入和删除操作，特别是在容器中间插入或删除。
  * 时间复杂度：提供线性时间复杂度查找O(n)操作，但插入和删除是O(1)时间内完成，前提是有指向插入和删除元素的迭代器。
  * 迭代器：线性结构，不支持随机访问。

### `map`和`unordered_map`的区别和实现机制

| 类别                     | `map`          | `unordered_map` |
| ------------------------ | -------------- | --------------- |
| 底层数据结构             | 平衡二叉搜索树 | 哈希表          |
| 有序性                   | 有序           | 无序            |
| Key值唯一性              | 唯一           | 唯一            |
| 查询，添加删除时间复杂度 | O(logn)        | O(1)            |

### 迭代器在`STL`中扮演什么角色？

* 统一的方式遍历不同的容器中的元素，无序了解容器的内部结构。
* 可以被视为指向容器中某个特定位置，允许程序**访问**和**操作**程序中的元素。

### 什么是迭代器失效，如何避免？

迭代器失效（***iterator invalidation***）：容器在执行某些修改操作后，**原先持有的迭代器、引用，指针不在指向有效元素**，继续使用将产生未定义行为。

#### 1.常见容器的失效规则

* `std::vector`/`std::basic_string`（连续存储）
  * `push_back()/insert()/emplace_back()/resize()`可能触发**扩容**，所有迭代器失效。
  * 插入/删除**位置及其之后**的迭代器失效。
  * `erase(pos)`：从`pos`起至末尾的迭代器失效；返回指向被**删除元素后一个**的新迭代器。

* `std::deque`
  * 在**首/尾插入删除**可能使**全部**迭代器失效。
  * 中间插入/删除通常使**受影响的区段**迭代器失效。
* `std::list/std::forward_list` （链式存储）
  * 插入/拼接：不会使迭代器失效。
  * 删除：仅使**被删元素**的迭代器失效。

* `std::set/std::map` （有序关联容器，节点式）
  * `insert`：不会使有效的迭代器失效。
  * `erase`：仅使**被删节点**的迭代器失效。
* `std::unordered_set/std::unordered_map`（哈希容器）
  * `rehash`/`reserve`导致**所有迭代器**失效。
  * `insert` 一般不使已有迭代器失效（除非出发`rehash`）
  * `erase`：仅使**被删除元素**失效。

#### 2.典型踩坑示例

1）边遍历边删除（`vector`）

```
std::vector<int> v{1,2,3,4};
for (auto it = v.begin(); it != v.end(); ) {
    if (*it % 2 == 0)
        it = v.erase(it);   // 使用 erase 的返回值继续遍历（正确）
    else
        ++it;               // 不删除时正常前进
}
```

2）扩容导致“全失效”（`vector`）

```
auto it = v.begin();
v.push_back(42);  // 可能扩容 → it 失效
// 使用 it 即 UB，需重新获取 v.begin()
```

3）哈希容器 rehash

```
auto it = um.begin();
um.reserve(10000); // 可能 rehash → 所有迭代器失效
// it 失效，需重新获取
```

4）删除 `list` 元素的安全写法

```
for (auto it = lst.begin(); it != lst.end(); ) {
    if (need_erase(*it)) it = lst.erase(it); // 仅删当前，其他迭代器稳定
    else ++it;
}
```

#### 3.如何避免迭代器失效

* **使用返回值继续遍历：**`erase`返回下一个有效迭代器。
* **提取容量规划（连续存储）**：在大量插入下`reserve`，减少扩容。
* **遍历时尽量不要下标 + 外部缓存迭代器**：修改容器后重新获取迭代器、引用、指针。
* **选择“节点稳定”的容器**：频繁插入、删除需要稳定的迭代器：优先`list`，`map`，`unorderded_map`，`set`。
* **注意哈希容器`rehash`**：批量插入前`reserve`，`rehash`后全部迭代器作废。
* **不要持有临时容器元素的引用/迭代器**：返回局部容器的引用/迭代器->悬垂
* **范围`for`+拷贝值**：当只读数据且容器会变更结构，考虑先拷贝必要的值到临时数组再处理。

### `vector`容器实现与扩容

#### 1.底层实现

`vector`在堆中分配了一段连续的内存空间存放元素。

**1、三个迭代器**

**（1）first ：** 指向的是vector中对象的起始字节位置
**（2）last ：** 指向当前最后一个元素的末尾字节
**（3）end ：** 指向整个vector容器所占用内存空间的末尾字节

![img](https://file1.kamacoder.com/i/bagu/vectorshixianyukuorong.jpg)



**（1）last - first ：** 表示 vector 容器中目前已被使用的内存空间
**（2）end - last ：** 表示 vector 容器目前空闲的内存空间
**（3）end - first ：** 表示 vector 容器的容量

**2.扩容过程**

如果集合已满，在新增数据时，就会申请一块更大的内存，将之前数据复制过来，释放之前的内存，再插入新的元素。

所以对`vector`的操作引一旦引起了空间重新分配，指向原`vector`的所有迭代器就都失效了。

`size()`和`capacity()`

* `size()`：当前向量中的元素数量。
* `capacity()`：当前向量可以容纳元素的数量。
* `capacity()` >= `size()`：二者相等时触发扩容。

**3.扩容机制**

* 固定扩容：
  * 每次扩容时在原`vector`的`capacity()`的基础上加上固定的容量。
  * 缺点：极端情况下，`vector`每次添加元素数量刚好等于每次扩容固定增加数据+1，就会造成一种情况，每添加一次元素就要扩容一次，而扩容的时间花费十分高。所以这种方式时间复杂度高。
* 加倍扩容：
  * 每次扩容的时候原`capacity()`翻倍，比如`capacity=100`扩容一次变为`200`,再扩容一次变为`400`
  * 优点：翻倍扩容的方式使得正常情况下添加元素需要扩容的次数极大减少，时间复杂度低。
  * 缺点：每次扩容空间翻倍，但很多空间时未使用的，空间利用率不如固定扩容。
* 实际应用中，一般采用空间换时间的策略。

**4.`resize()`和`reserve()`**

* `resize()`：改变当前容器内含有元素的数量（size()），而不是改变容器的容量。
  * `len > capacity()`：则`vector`中的`size`和`capacity`均设置`len`。
  * `len <= capacity()`：则数组中的`size`设置为`len`，而`capacity`不变
* `reserve()`：改变当前容器的最大容量（capacity()）
  * `reserve(len)`中`len > capacity()`，那么会重新分配一块内存能存储`len`个元素的空间，之后将之前内存中的元素拷贝过来，销毁之前的内存。
  * `reserve(len)`中`len < capacity()`，`vector`的`size()`、`capacity`不变，既不会容器做任何改变。

扩容相关代码：

* `push_back()`会检查当前容器是否还有空间（end 是否等于 `end_of_finish`），若有则插入，若无则扩容后插入。

```cpp
templeta<class T,class Alloc=alloc>
class vector {
public:
    
protected:
    
    typedef simple_alloc <value_type, Alloc> data_alloctor
    //空间配置器（分配器）
    iterator start;
    iterator finish;
    iterator end_of_storage;
    //这3个就是vector里的数据，所以一个vector就是包含3个指针12byte,下面有图介绍
    
    void insert_aux(iterator position, const T &x);

    //这个就是vector的自动扩充函数，在下面章节我会拿出来分析
    void deallocate() {
        if (start)
            data_allocator::deallocate(start, end_of_storage);
    }

    //析构函数的部分实现函数

    void fill_initialize(size_type n, const T &value) {
        start = allocate_and_fill(n, value);
        finish = start + n;
        end_of_storage = finish;
    }

    //构造函数的具体实现

public:
    
    iterator begin() { return start; };
    iterator end() { return finish; };
    size_type size() const { return size_type(end() - begin()); };
    size_type capacity() const { return size_type(end_of_storage - begin()); }
    bool empty() const { return begin() == end(); }
    reference operator[](size_type n) { return *(begin() + n); };
    //重载[]说明vector支持随机访问
    
    vector() : start(0), end(0), end_of_storage(0) {};
    
    vector(size_type n, const T &value)(fill_initialize(n, value););

    vector(long n, const T &value)(fill_initialize(n, value););

    vector(int n, const T &value)(fill_initialize(n, value););

    explicit vector(size_type n) { fill_initialize(n, T()); };

    //重载构造函数
    ~vector() {
        destory(start, finish);//全局函数，析构对象
        deallocate();//成员函数，释放空间
    }
    //接下来就是一些功能函数
    reference front() { return *begin(); };
    reference back() { return *(end() - 1); };
    void push_back(const T &x) {
        if (finsih != end_of_storage) {
            construct(finish, x);
            ++finish;
        } else insert_aux(end(), x);
        //先扩充在添加
    }

    void pop_back() {
        --finish;
        destory(finish);
    }

    iterator erase(iterator position) {
        if (position + 1 != end())
            copy(position + 1, finish, position);
        --finish;
        destory(finish);
        return position;
    }

    void resize(size_type new_size, const T &x) {
        if (new_size() < size())
            erase(begin() + new_size, end());
        else
            insert(end(), new_size - size(),x);
    }

    void resize()(size_type new_size) { resize(new_size, T()); }
    void clear() { erase(begin(), end()); }
    
protected:
    //配置空间并填满内容
    iterator allocate_and_fill(size_type n, const T &x) {
        iterator result = data_allocator::allocate(n);
        uninitialized_fill_n(result, n, x);//全局函数
    }
}


template<class T, class Alloc>
void vector<T, Alloc>::insert_aux(iterator position, const T &x) {
    if (finish != end_of_storage) {//有备用空间
        consruct(finish, *(finish - 1));//在备用空间处构造一个元素，以vector最后一个元素为其初值
        ++finish;
        T x_copy = x;
        copy_backward(position, finish - 2, finish - 1);
        *position = x_copy;
    } else {
        const size_type old_size = size();
        const size_type len = old_size != 0 ? 2 * old_size() : 1;
        //vector中如果没有元素就配置一个元素，如果有就配置2倍元素。
        iterator new_start = data_allocator::allocate(len);
        iterator new_finish = new_start;
        try {
            //拷贝插入点之前的元素
            new_finish = uninitialized_copy(start, position, new_start);
            construct(new_finish, x);
            ++new_finish;
            //拷贝插入点之后的元素
            new_finish = uninitialized_copy(position, finish, new_finish);
        }
        catch () {
            destroy(new_start, new_finish);
            data_allocator::deallocate(new_start, len);
            throw;
        }
        //析构并释放原vector
        destory(begin(), end());
        deallocate();
        //调整迭代器指向新的vector
        start = new_start;
        finish = new_finish;
        end_of_storage = new_start + len;
    }
}
```

整个分为3个部分，配置**新空间，转移元素，释放原来的元素与空间**,因此一旦引起空间配置指向以前vector的所有迭代器都要失效。

<img src="https://file1.kamacoder.com/i/bagu/_vector_yuanma_yangwang_01.png" alt="img" style="zoom: 200%;" />

### List

list的每个元素都放在一块内存中，但它们是不连续的，通过指针进行访问。其使用频繁的添加和删除场景，不需要移动内存。

### deque (双段队列)

支持快速随机访问，由于`deque`需要内部跳转，所以速度没有`vector`块。

**1.deque概述：**

双端开口的连续存储的线性空间，其内部是分段连续的空间，可以随时新增加一段新的空间并链接。

注：`deque`的迭代器比`vector`复杂，此影响各个层面的运算，故非必要尽量用`vector`。对于`deque`中元素的排序，可以将其拷贝值`vector`中，排序结束后，拷贝回`deque`中。	

**2.`deque`底层结构模型**

`deque`的核心是[**中控数组(map) + 分段连续缓冲（buffer）**]

* **缓冲区（buffer）**：固定大小的连续内存，`deque`存储元素的实际载体。
* **中控数组（map）**：一个普通的**指针数组**（本质`T**`类型），数组中的每个元素（map[i]）是指向「指向某块缓冲区的指针」（即 buffer 的地址）；
* **迭代器**：复合结构
  * `cur`：指向当前元素在`buffer`中的地址。
  * `first`：当前`buffer`的起始地址。
  * `last`：指向当前`buffer`的末尾地址。
  * `node`：指向中控数组中「当前 buffer 对应的指针位置」（即 map 中的某个元素，类型是 `T***`）。

**3.deque 扩容的准确过程（首尾扩容）**

当 deque 头部 / 尾部的 buffer 满了，需要扩容时：

* **申请新 buffer**：分配一块新的固定大小连续内存（buffer）；

* **更新中控数组**：

  - 若尾部扩容：若 map 还有尾部空间，直接把新 buffer 地址存入 map 尾部；若 map 已满，先扩容 map（重新分配更大的数组，拷贝原 map 内容），再存入新 buffer 地址；

  - 若头部扩容：同理，把新 buffer 地址存入 map 头部（map 扩容时会预留头部空间，保证头插高效）；

* **迭代器适配**：新 buffer 加入后，迭代器仅需更新 `node`/`first`/`last` 成员，无需像 vector 那样全部失效（仅跨 buffer 的迭代器需调整）。

**4.迭代器工作的原理：**

* 使用`cur`访问当前元素。
* 若迭代器++/--访问到边界（cur == last 或 cur == first - 1）
  * 通过`node`找到当前`buffer`的下标。
  * 下标+1/-1找到下一个/上一个buffer的地址。
  * 更新`first`/`last`为新`buffer`的首尾，`cur`指向新`buffer`的首/尾元素。
* 全程无序遍历`map`，仅通过指针偏移完成，保证遍历效率接近`vector`。

#### Deque 迭代器 node 指向关系示意图（64 位系统，以 int 类型为例）

```plaintext
┌─────────────────────────────────────────────────────────────────┐
│ 迭代器（DequeIterator）                                         │
│  ┌───────────┬───────────┬───────────┬───────────────────────┐  │
│  │  cur      │  first    │  last     │  node（map_pointer）  │  │
│  │  (T*)     │  (T*)     │  (T*)     │  (T**)                │  │
│  │  0x2000   │  0x2000   │  0x2020   │  0x1008               │  │
│  └─────┬─────┴─────┬─────┴─────┬─────┴───────────┬───────────┘  │
└───────┼───────────┼───────────┼─────────────────┼───────────────┘
        │           │           │                 │
        ▼           │           │                 ▼
┌───────────────┐   │           │        ┌─────────────────────────┐
│ buffer1（T*） │   │           │        │ 中控数组 map（T**）      │
│ 地址：0x2000  │   │           │        │ 起始地址：0x1000        │
│ ┌───────────┐ │   │           │        │ ┌───────────┬─────────┐ │
│ │ 0x2000    │ │<──┘           │        │ │ 0x1000    │ 0x3000 │ │
│ │  int: 10  │ │               │        │ │ (map[0])  │buffer0 │ │
│ ├───────────┤ │               │        │ ├───────────┼─────────┤ │
│ │ 0x2004    │ │               │        │ │ 0x1008    │ 0x2000 │ │<─┐
│ │  int: 20  │ │               │        │ │ (map[1])  │buffer1 │ │  │
│ ├───────────┤ │               │        │ ├───────────┼─────────┤ │  │
│ │  ...      │ │               │        │ │ 0x1010    │ 0x4000 │ │  │
│ └───────────┘ │               │        │ │ (map[2])  │buffer2 │ │  │
│ 末尾：0x2020  │<──────────────┘        │ └───────────┴─────────┘ │  │
└───────────────┘                        └─────────────────────────┘  │
                                                                      │
┌───────────────┐                                                     │
│ buffer0（T*） │                                                     │
│ 地址：0x3000  │<────────────────────────────────────────────────────┘
│ （元素略）    │                     （node的值是0x1008，指向map[1]的地址）
└───────────────┘
┌───────────────┐
│ buffer2（T*） │
│ 地址：0x4000  │
│ （元素略）    │
└───────────────┘
```

#### 关键指向关系拆解（对应示意图）

1. **map 数组的本质**：

   map 是 `T**` 类型（`int**`），数组里的每个元素（map [0]/map [1]/map [2]）是 `T*` 类型（`int*`），存储的是**各个 buffer 的起始地址**（比如 map [1] = 0x2000，即 buffer1 的地址）。

2. **node 的指向逻辑（核心）**：

   迭代器的 `node` 是 `T**` 类型（`map_pointer`），它的值是「map 数组中某个元素的地址」（而非 buffer 地址）：

   - 示意图中 `node = 0x1008` → 这个地址是 map 数组第 2 个元素（map [1]）的存储地址；
   - 对 `node` 解引用（`*node`）→ 得到 `0x2000`（即 map [1] 存储的 buffer1 地址）；
   - 再解引用（`**node`）→ 得到 `0x2000` 地址里的 int 值 `10`。

3. **为什么 node 要这么设计？**

   若迭代器要跨 buffer 遍历（比如从 buffer1 到 buffer2），只需：

   `node++` → node 从 `0x1008` 变成 `0x1010`（指向 map [2] 的地址），再 `*node` 就能拿到 buffer2 的地址（0x4000），无需遍历整个 map 数组，效率极高。

#### 一句话总结

`node` 不直接指向 buffer，而是**指向 map 数组中 “存储该 buffer 地址的那个位置”**，通过「`node` → map 元素地址 → buffer 地址」的两步指向，实现快速切换 buffer。

### heap && priority_queue

| 类别     | `heap`                                                       | `priority_queue`                                             |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 本质     | 堆，STL算法                                                  | 优先队列，容器适配器                                         |
| 大顶堆   | 基于`<`比较，实现**大顶堆**(完全二叉树，根节点是最大值)      | 底层依赖`heap`，默认也是大顶堆                               |
| 单独问题 | 与`priority_queue`的关系？：<br />heap时一组算法`make_heap`、`push_heap`、`pop_heap`、`sort_heap`作用于可随机访问容器的`vector/deque`的；<br />`priority_queue`时容器适配器，底层封装了`heap`算法+底层容器（默认`vector`），提供了更易用的队列接口（`push/pop/top`） | 是否可以更换底层容器？：可以，但要支持随机访问。             |
| 实现细节 | `push_heap`和`pop_heap`的过程？时间复杂度是多少？<br />插入：先把元素放在末尾，然后进行调整-与其父节点向比较，若更大则交换，直到满足堆性质，时间复杂度O(logn);<br />删除：**先交换堆顶和最后一个元素**，再删除末尾元素，再从对顶向下调整-比较当前节点与左右孩子，交换更大，直到满足堆性质，时间复杂度：O(logn)。 | `priority_queue`的为什么没有`iterator`?<br />其设计目标是保证**堆顶可快速访问/删除**，若开发迭代器，用户可能通过迭代器修改元素，破坏了堆结构。<br />`priority_queue`应用场景：**TopK问题**（前K大、小元素），堆排序，任务调度。 |

* TopK 问题用`priority_queue`怎么实现？为什么选小顶堆而非大顶堆（求前 k 大）？

  答：**求前 k 大元素时，维护一个大小为 k 的小顶堆**：遍历数组，先放入 k 个元素，后续元素若比堆顶大，则弹出堆顶、插入当前元素；遍历结束后，堆内就是前 k 大元素；

  原因：小顶堆堆顶是当前堆中最小的，只需比较堆顶即可判断是否保留，时间复杂度`O(nlogk)`（比排序的`O(nlogn)`更优，k 远小于 n 时）。

- 问：`priority_queue`的`pop()`返回值是什么？为什么不能直接获取弹出的元素？

  答：`pop()`是 void 类型，**不会返回元素** —— 因为若返回元素，当**元素拷贝 / 移动抛异常**时，元素可能既被弹出又无法返回，**导致数据丢失**，STL 为了异常安全，设计为`top()`获取、`pop()`仅删除。

- 问：`push_heap`前必须先把元素插入容器末尾，为什么？

  `push_heap`的逻辑是基于 “容器末尾新增了一个元素”，**仅负责向上调整堆结构**，若元素未在末尾，会破坏堆的**索引关系**，导致调整失败。

# C++ 智能指针面试核心问题整理表

| 问题分类                                                     | 核心面试问题                                                 | 核心答案要点（完整版）                                       | 考察维度                 |          |          |          |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------ | -------- | -------- | -------- |
| 基础认知                                                     | 智能指针的设计初衷？解决裸指针哪些问题？                     | 1. 设计初衷：C++ 中动态内存（`new`/`delete`）需手动管理，易出现人为失误，智能指针通过 RAII（资源获取即初始化）机制，将动态内存与智能指针对象的生命周期绑定，实现内存自动化管理；<br />2. 解决的裸指针问题：<br />- 内存泄漏：忘记调用 `delete` 释放动态内存，智能指针析构时自动释放；<br />- 悬空指针：内存释放后裸指针未置空，后续解引用导致未定义行为，智能指针析构后自动失效，无悬空风险；<br />- 重复释放：同一裸指针多次调用 `delete`，智能指针仅在引用计数为 0 时释放，避免重复释放；<br />- 异常安全：函数执行中抛出异常时，裸指针的 `delete` 可能无法执行，智能指针因析构函数自动调用，可保证内存释放。 | 核心价值理解             |          |          |          |
|                                                              | C++ 标准库有哪些智能指针？头文件是什么？                     | 1. 标准库智能指针分类：- 核心类型（C++11 引入，推荐使用）：`unique_ptr`（独占式智能指针）、`shared_ptr`（共享式智能指针）、`weak_ptr`（弱引用智能指针，配合 `shared_ptr` 使用）；- 废弃类型（C++98 引入，C++11 标记为废弃）：`auto_ptr`（设计缺陷，已被 `unique_ptr` 替代）；2. 头文件：所有智能指针均定义在 `<memory>` 头文件中，使用时需包含该头文件。 | 基础分类与规范           |          |          |          |
|                                                              | auto_ptr 为何废弃？unique_ptr 如何改进？                     | 1. `auto_ptr` 被废弃的核心原因：- 拷贝 / 赋值语义缺陷：拷贝 `auto_ptr` 或对其赋值时，会转移所有权（原 `auto_ptr` 变为空指针），这种隐式转移极易导致误用（如容器中存储 `auto_ptr`，遍历 / 排序时触发拷贝，导致大量指针悬空）；- 无移动语义支持：C++11 引入移动语义后，`auto_ptr` 的设计无法适配新特性；2. `unique_ptr` 的改进：- 禁用拷贝：将拷贝构造函数和拷贝赋值运算符声明为 `delete`，编译期直接拦截非法拷贝操作；- 支持显式移动：仅通过 `std::move` 实现所有权转移，语义清晰，避免隐式错误；- 支持数组管理：原生支持动态数组，析构时自动调用 `delete[]`，而 `auto_ptr` 仅支持单个对象。 | 演进逻辑与设计思想       |          |          |          |
| unique_ptr 核心                                              | unique_ptr 核心特性？适用场景？                              | 1. `unique_ptr` 核心特性：<br />**- 独占所有权**：同一时间仅能有一个 `unique_ptr` 指向某块动态内存，保证资源唯一归属；<br />- **移动语义**：仅支持 `std::move` 转移所有权，转移后原指针失效；<br />- **自动释放**：析构时（如超出作用域、被重置）自动调用 `delete`/`delete[]` 释放内存；<br />- **轻量化**：内存开销与裸指针一致（无额外计数等开销），性能接近裸指针；<br />- **支持自定义删除器**：可管理非内存资源（如文件句柄、套接字）；2. 适用场景：<br />- **函数返回动态对象**：无需手动管理，返回时自动移动，避免内存泄漏；<br />- 容器存储独占对象：如 `vector<unique_ptr<Base>>`，利用多态管理子类对象，且保证对象唯一归属；<br />- **替代单个动态对象的裸指针**：如类成员指针，避免手动写析构函数释放；<br />- 管理非内存资源：如文件指针、线程句柄，配合自定义删除器实现资源自动释放。 | 特性与场景匹配           |          |          |          |
|                                                              | unique_ptr 能否管理数组？如何用？                            | 1. `unique_ptr` 完全支持管理动态数组（C++11 起原生支持）；2. 语法格式：- 声明：`std::unique_ptr<int[]> ptr(new int[5]);`（尖括号中加 `[]` 标识数组类型）；- 访问：**仅支持下标访问**（`ptr[0] = 10;`），不支持解引用运算符（`*ptr`），因为数组无单个 “解引用” 语义；- 析构：自动调用 `delete[]` 释放数组，无需手动指定删除器；3. 示例代码：`cpp<br>#include <memory><br>int main() {<br> std::unique_ptr<int[]> arr_ptr(new int[3]{1, 2, 3});<br> arr_ptr[1] = 10; // 合法，修改第二个元素<br> // *arr_ptr = 20; // 非法，数组版unique_ptr无解引用运算符<br> return 0;<br>} // 析构时自动调用delete[]，释放数组<br>` | 数组管理细节             |          |          |          |
|                                                              | 如何自定义 unique_ptr 的删除器？                             | 1. 核心原理：`unique_ptr` 的删除器是模板参数，需在声明时指定，删除器可以是函数指针、函数对象、lambda 表达式（C++11 后）；2. 语法格式：- 函数指针版：`std::unique_ptr<Type, DeleterFuncPtr> ptr(new Type(), DeleterFunc);`；- lambda 版：需用 `decltype` 推导 lambda 类型，语法：`auto del = [](Type* p) { /* 释放逻辑 */ }; std::unique_ptr<Type, decltype(del)> ptr(new Type(), del);`；3. 示例（管理文件指针）：`cpp<br>#include <memory><br>#include <cstdio><br>// 自定义删除器：关闭文件<br>void close_file(FILE* fp) {<br> if (fp) fclose(fp);<br>}<br>int main() {<br> // 声明：删除器类型为函数指针，传入删除器函数地址<br> std::unique_ptr<FILE, decltype(&close_file)> fp(fopen("test.txt", "r"), close_file);<br> if (fp) { /* 操作文件 */ }<br> return 0;<br>} // 析构时自动调用close_file，关闭文件<br>`4. 注意事项：- 函数对象形式的删除器（如无捕获的 lambda）不会增加 `unique_ptr` 的内存开销；- 函数指针形式的删除器会使 `unique_ptr` 占用额外内存（存储指针地址）。 | 非内存资源管理能力       |          |          |          |
| shared_ptr 核心                                              | shared_ptr 核心特性 ？5点<br />底层实现原理？                | 1. `shared_ptr` 核心特性：<br />- **共享所有权**：多个 `shared_ptr` 可指向同一块动态内存，通过引用计数管理生命周期；<br />- **拷贝 / 赋值**：支持自由拷贝和赋值，拷贝时引用计数 +1，赋值时原指针引用计数 -1、新指针引用计数 +1；<br />- **自动释放**：当引用计数减至 0 时，自动调用删除器释放内存；<br />- **线程安全**：引用计数的增减是原子操作，多线程拷贝 / 析构 `shared_ptr` 不会导致计数错乱；<br />- **支持自定义删除器**：删除器存储在控制块中，不影响 `shared_ptr` 的大小；<br />2. 底层实现原理：- `shared_ptr` 内部维护两个指针：① 资源指针：指向管理的动态对象 / 数组；② 控制块指针：指向一块独立的控制块内存，控制块包含：- 强引用计数：当前指向该资源的 `shared_ptr` 数量；- 弱引用计数：当前指向该资源的 `weak_ptr` 数量；- 删除器：释放资源的函数 / 对象；- 分配器：用于分配 / 释放控制块的内存；- 核心操作逻辑：- 拷贝 `shared_ptr`：控制块的强引用计数 +1；- 析构 `shared_ptr`：强引用计数 -1，若强引用计数为 0，释放资源；若弱引用计数也为 0，释放控制块；<br />- 赋值 `shared_ptr`：先减原指针的强引用计数（可能释放资源），再增加新指针的强引用计数。 | 底层内存模型             |          |          |          |
|                                                              | shared_ptr 引用计数线程安全吗？对象访问呢？<br />计数-安全<br />对象访问-非安全 | 1. 引用计数的线程安全性：- 强引用计数和弱引用计数的增减操作是原子的（基于 `std::atomic` 实现），多线程同时拷贝、析构、赋值 `shared_ptr` 时，计数不会出现错乱，是线程安全的；2**. 指向对象的访问安全性：- 非线程安全！**`shared_ptr` 仅保证计数本身的线程安全，不保证对指向对象的读写安全；- 若多个线程同时修改 `shared_ptr` 指向的对象，必须通过互斥锁（`std::mutex`）、原子操作等方式手动同步；若仅读取对象，无需同步；3. 示例说明：`cpp<br>#include <memory><br>#include <thread><br>#include <mutex><br>std::shared_ptr<int> sp = std::make_shared<int>(10);<br>std::mutex mtx;<br>// 线程1：修改对象<br>void thread1() {<br> std::lock_guard<std::mutex> lock(mtx); // 必须加锁<br> *sp = 20;<br>}<br>// 线程2：读取对象<br>void thread2() {<br> std::lock_guard<std::mutex> lock(mtx); // 读取也建议加锁，避免读写冲突<br> printf("%d\n", *sp);<br>}<br>` | 线程安全边界认知         |          |          |          |
|                                                              | shared_ptr 能否管理数组？注意事项？                          | 1. `shared_ptr` 对数组的支持分为两个阶段：- C++17 及以后：原生支持动态数组，语法与 `unique_ptr` 类似，`std::shared_ptr<int[]> sp(new int[5]);`，析构时自动调用 `delete[]`，支持下标访问；- C++17 之前：不原生支持数组，若直接用 `shared_ptr<int> sp(new int[5]);`，析构时会调用 `delete` 而非 `delete[]`，导致数组内存泄漏，需手动指定自定义删除器；2. 不同版本的使用示例：- C++17 及以后：`cpp<br> #include <memory><br> int main() {<br> std::shared_ptr<int[]> sp(new int[3]{1,2,3});<br> sp[1] = 10; // 合法，下标访问<br> return 0;<br> } // 析构自动调用delete[]<br>`- C++17 之前：`cpp<br> #include <memory><br> int main() {<br> // 自定义删除器，指定delete[]<br> std::shared_ptr<int> sp(new int[3]{1,2,3}, [](int* p) { delete[] p; });<br> // sp[1] = 10; // C++17前不支持下标，需通过指针偏移访问：*(sp.get()+1) = 10;<br> return 0;<br> }<br>`3. 注意事项：- C++17 前数组版 `shared_ptr` 不支持下标访问，需通过 `get()` 获取裸指针后偏移；- 数组版 `shared_ptr` 的性能略低于 `unique_ptr`，因为需维护控制块和计数。 | 数组管理兼容性           |          |          |          |
|                                                              | shared_ptr 循环引用是什么？如何解决？                        | 1. 循环引用的定义：两个或多个 `shared_ptr` 互相指向对方（或形成闭环），导致各自的强引用计数无法减至 0，最终内存泄漏；2. 循环引用示例：`cpp<br>#include <memory><br>struct Node {<br> std::shared_ptr<Node> next;<br> ~Node() { printf("Node deleted\n"); } // 循环引用时不会执行<br>};<br>int main() {<br> auto n1 = std::make_shared<Node>();<br> auto n2 = std::make_shared<Node>();<br> n1->next = n2; // n1的next指向n2，n2的强引用计数+1（变为2）<br> n2->next = n1; // n2的next指向n1，n1的强引用计数+1（变为2）<br> return 0;<br>} // 析构时n1、n2的强引用计数各减1（变为1），无法释放，内存泄漏<br>`3. 解决方法：将闭环中的一个或多个 `shared_ptr` 改为 `weak_ptr`（弱引用不增加强引用计数）；4. 修复后的示例：`cpp<br>#include <memory><br>struct Node {<br> std::weak_ptr<Node> next; // 改为weak_ptr<br> ~Node() { printf("Node deleted\n"); } // 正常执行<br>};<br>int main() {<br> auto n1 = std::make_shared<Node>();<br> auto n2 = std::make_shared<Node>();<br> n1->next = n2; // weak_ptr不增加n2的强引用计数（仍为1）<br> n2->next = n1; // weak_ptr不增加n1的强引用计数（仍为1）<br> return 0;<br>} // 析构时n1、n2的强引用计数减至0，正常释放<br>`5. 核心逻辑：`weak_ptr` 指向 `shared_ptr` 管理的资源，但不增加强引用计数，仅作为 “观察者”，打破闭环后强引用计数可正常归 0。 | 核心缺陷与解决方案       |          |          |          |
| weak_ptr 核心                                                | weak_ptr 核心特性？为何不能单独使用？                        | 1. `weak_ptr` 核心特性：<br />- 弱引用：指向 `shared_ptr` 管理的资源，但不增加强引用计数，不影响资源的释放；<br />- 资源检测：通过 `expired()` 方法判断所指向的资源是否已被释放；<br />- 安全升级：通过 `lock()` 方法将自身升级为 `shared_ptr`，若资源未释放则返回有效 `shared_ptr`（强引用计数 +1），若已释放则返回空 `shared_ptr`；<br />- 无所有权：不参与资源的管理，仅作为 “观察者”；2. 不能单独使用的原因：- `weak_ptr` 没有重载解引用运算符（`*`）和箭头运算符（`->`），无法直接访问指向的资源；- `weak_ptr` 不管理资源的生命周期，即使 `weak_ptr` 存在，只要对应的 `shared_ptr` 全部析构，资源仍会被释放；- 必须通过 `lock()` 升级为 `shared_ptr` 后才能访问资源，这是为了保证访问时资源一定有效（若升级失败，`lock()` 返回空，可提前判空避免悬空访问）。 | 设计定位与使用约束       |          |          |          |
|                                                              | weak_ptr 的 lock () 和 expired () 作用？                     | 1. `expired()` 方法：- 功能：判断 `weak_ptr` 指向的资源是否已被释放（即对应的 `shared_ptr` 强引用计数是否为 0）；- 返回值：`bool` 类型，`true` 表示资源已释放，`false` 表示资源仍有效；- 语法：`bool is_expired = wp.expired();`；2. `lock()` 方法：- 功能：尝试将 `weak_ptr` 升级为 `shared_ptr`，是线程安全的操作；- 返回值：若资源有效，返回指向该资源的 `shared_ptr`（强引用计数 +1）；若资源已释放，返回空 `shared_ptr`；- 语法：`std::shared_ptr<Type> sp = wp.lock();`；3. 组合使用示例：`cpp<br>#include <memory><br>#include <iostream><br>int main() {<br> std::shared_ptr<int> sp = std::make_shared<int>(10);<br> std::weak_ptr<int> wp = sp;<br> // 检测资源是否有效<br> if (!wp.expired()) {<br> auto sp2 = wp.lock(); // 升级为shared_ptr<br> if (sp2) { // 双重判空，确保安全<br> std::cout << *sp2 << std::endl; // 输出10<br> }<br> }<br> sp.reset(); // 释放资源<br> std::cout << std::boolalpha << wp.expired() << std::endl; // 输出true<br> auto sp3 = wp.lock();<br> std::cout << std::boolalpha << (sp3 == nullptr) << std::endl; // 输出true<br> return 0;<br>}<br>`4. 注意事项：- 即使 `expired()` 返回 `false`，在调用 `lock()` 前资源也可能被其他线程释放，因此必须在 `lock()` 后判空，而非仅依赖 `expired()`；- `lock()` 是原子操作，可避免多线程下的竞态条件。 | 核心方法使用             |          |          |          |
|                                                              | weak_ptr 除解决循环引用外，还有哪些场景？                    | 1. 缓存 / 对象池场景：- 场景：对象池存储常用对象的 `shared_ptr`，外部通过 `weak_ptr` 引用缓存对象；当对象长时间未被使用时，对象池可释放 `shared_ptr`，外部 `weak_ptr` 通过 `expired()` 检测到后，重新从对象池获取新对象，避免缓存占用过多内存；2. 观察者模式：- 场景：观察者（Observer）持有被观察者（Subject）的 `weak_ptr`，被观察者销毁时，观察者可通过 `expired()` 检测到，避免访问已销毁的被观察者；- 优势：无需手动维护 “观察者列表” 的删除逻辑，被观察者销毁后自动失效；3. 多线程资源检测：- 场景：多线程共享一个动态资源，主线程可能随时释放该资源，工作线程通过 `weak_ptr` 的 `lock()` 检测资源是否存在，若不存在则停止操作，避免访问悬空指针；4. 避免循环依赖的其他场景：- 如类之间的双向关联（A 包含 B，B 需引用 A），将 B 中对 A 的引用改为 `weak_ptr`，既保证能访问 A，又不形成循环引用。 | 场景拓展应用             |          |          |          |
| 使用细节 & 易错点                                            | 为何优先用 make_shared/make_unique 而非 new？                | 1. 减少内存分配次数：- `make_shared`：一次性分配 “对象内存 + 控制块内存”，而 `std::shared_ptr<int> sp(new int(10));` 需分两次分配（先分配 int 对象，再分配控制块），减少内存碎片，提升性能；- `make_unique`：虽无控制块，但语法更简洁，且避免裸 `new` 分散在代码中；<br />2. 提升异常安全：- 问题示例：`func(std::shared_ptr<A>(new A()), std::shared_ptr<B>(new B()));`，编译器可能先执行 `new A()`、`new B()`，再构造 `shared_ptr`；若 `new B()` 抛出异常，`new A()` 已分配的内存无法释放，导致泄漏；- 解决：`func(std::make_shared<A>(), std::make_shared<B>());`，`make_shared` 先构造 `shared_ptr` 再分配内存，异常时不会泄漏；<br />3. 语法简洁：- 避免裸 `new` 出现在代码中，符合 RAII 思想，代码更易维护；<br />4. 注意事项：- `make_shared` 无法自定义删除器，若需自定义删除器，仍需用 `new` 构造；- `make_unique` 是 C++14 引入，C++11 需手动实现或用 `new`。 | 最佳实践认知             |          |          |          |
|                                                              | 智能指针能否指向栈内存？为什么？                             | 1. 绝对禁止将智能指针指向栈内存；2. 核心原因：- 智能指针的析构函数会调用 `delete`（或 `delete[]`）释放内存，而栈内存由操作系统自动管理（函数调用结束后栈帧销毁），对栈内存调用 `delete` 会导致未定义行为（如程序崩溃、内存错乱）；3. 错误示例：`cpp<br>#include <memory><br>int main() {<br> int a = 10; // 栈内存<br> std::unique_ptr<int> sp(&a); // 错误：指向栈内存<br> return 0;<br>} // 析构sp时调用delete &a，导致未定义行为<br>`4. 补充说明：- 智能指针仅用于管理**动态分配的内存**（`new`/`new[]` 分配）或自定义的非内存资源（如文件句柄），不可用于栈资源。 | 栈 / 堆内存管理边界      |          |          |          |
|                                                              | shared_ptr 控制块何时创建？多控制块坑点？                    | 1. 控制块的创建时机：- 调用 `std::make_shared` 时：一次性创建对象内存和控制块，控制块与对象内存连续；- 用裸指针构造 `shared_ptr` 时：在 `shared_ptr` 构造函数中创建控制块，控制块与对象内存分离；- 注意：`shared_ptr` 的控制块一旦创建，无法转移，每个裸指针首次构造 `shared_ptr` 时都会创建新的控制块；2. 多控制块坑点：- 场景：同一裸指针构造多个 `shared_ptr`，每个 `shared_ptr` 都创建独立的控制块，导致多个控制块管理同一块内存，析构时重复释放，触发未定义行为；- 错误示例：`cpp<br>#include <memory><br>int main() {<br> int* p = new int(10);<br> std::shared_ptr<int> sp1(p); // 创建控制块1，强引用计数=1<br> std::shared_ptr<int> sp2(p); // 创建控制块2，强引用计数=1<br> return 0;<br>} // 析构sp2时释放p，析构sp1时再次释放p，重复释放崩溃<br>`- 解决方法：① 始终通过拷贝 `shared_ptr` 而非裸指针构造新的 `shared_ptr`；② 优先使用 `make_shared` 而非裸指针构造。 | 控制块核心坑点           |          |          |          |
|                                                              | 智能指针大小？与裸指针区别？                                 | 1. 裸指针大小：由系统寻址能力决定，32 位系统 4 字节，64 位系统 8 字节；2. 各智能指针大小：- `unique_ptr`：- 默认情况（无自定义删除器 / 删除器为无捕获 lambda / 函数对象）：大小与裸指针一致（4/8 字节）；- 自定义删除器为函数指针：大小 = 裸指针大小 + 函数指针大小（64 位系统 16 字节）；- `shared_ptr`：大小为裸指针的 2 倍（64 位系统 16 字节），因为内部存储 “资源指针 + 控制块指针”；- `weak_ptr`：大小与 `shared_ptr` 一致（64 位系统 16 字节），因为内部存储 “控制块指针”，需通过控制块访问资源；3. 示例验证（64 位系统）：`cpp<br>#include <memory><br>#include <iostream><br>int main() {<br> std::cout << "裸指针大小：" << sizeof(int*) << std::endl; // 8字节<br> std::unique_ptr<int> up;<br> std::cout << "unique_ptr大小：" << sizeof(up) << std::endl; // 8字节<br> std::shared_ptr<int> sp;<br> std::cout << "shared_ptr大小：" << sizeof(sp) << std::endl; // 16字节<br> std::weak_ptr<int> wp;<br> std::cout << "weak_ptr大小：" << sizeof(wp) << std::endl; // 16字节<br> return 0;<br>}<br>` | 内存开销认知             |          |          |          |
| 手撕 / 代码分析                                              | 用 unique_ptr 实现对象工厂？                                 | 1. 核心思路：- 定义基类和多个子类，利用多态特性；- 工厂函数根据参数返回不同子类的 `unique_ptr<基类>`，利用 `unique_ptr` 的移动语义（函数返回时自动移动）；- 保证每个对象的所有权唯一，避免内存泄漏；2. 完整示例代码：`cpp<br>#include <memory><br>#include <iostream><br>// 基类：产品<br>class Product {<br>public:<br> virtual void show() const = 0;<br> virtual ~Product() = default; // 虚析构，保证子类析构<br>};<br>// 子类1：产品A<br>class ProductA : public Product {<br>public:<br> void show() const override {<br> std::cout << "Product A" << std::endl;<br> }<br>};<br>// 子类2：产品B<br>class ProductB : public Product {<br>public:<br> void show() const override {<br> std::cout << "Product B" << std::endl;<br> }<br>};<br>// 工厂函数：创建产品<br>std::unique_ptr<Product> createProduct(int type) {<br> switch (type) {<br> case 1:<br> return std::make_unique<ProductA>(); // 返回ProductA的unique_ptr<br> case 2:<br> return std::make_unique<ProductB>(); // 返回ProductB的unique_ptr<br> default:<br> return nullptr;<br> }<br>}<br>int main() {<br> auto prod1 = createProduct(1);<br> if (prod1) prod1->show(); // 输出Product A<br> auto prod2 = createProduct(2);<br> if (prod2) prod2->show(); // 输出Product B<br> return 0;<br>} // 析构时自动释放prod1、prod2，无需手动管理<br>`3. 优势：- 工厂函数无需返回裸指针，避免调用者忘记释放；- `unique_ptr` 保证产品对象的所有权唯一，不会出现重复释放。 | 实操与多态结合           |          |          |          |
|                                                              | 分析 weak_ptr 使用不当导致崩溃的代码？                       | 1. 错误代码示例：`cpp<br>#include <memory><br>#include <iostream><br>int main() {<br> std::shared_ptr<int> sp = std::make_shared<int>(10);<br> std::weak_ptr<int> wp = sp;<br> sp.reset(); // 释放资源，强引用计数归0<br> // 错误：直接解引用lock()返回的空shared_ptr<br> std::cout << *wp.lock() << std::endl;<br> return 0;<br>}<br>`2. 错误分析：- `sp.reset()` 释放了资源，`wp.lock()` 返回空 `shared_ptr`；- 对空 `shared_ptr` 解引用（`*wp.lock()`），等同于解引用空裸指针，触发未定义行为（程序崩溃）；3. 修复方案：- 调用 `lock()` 后必须判空，确认 `shared_ptr` 有效后再解引用；- 修复后代码：`cpp<br>#include <memory><br>#include <iostream><br>int main() {<br> std::shared_ptr<int> sp = std::make_shared<int>(10);<br> std::weak_ptr<int> wp = sp;<br> sp.reset();<br> auto sp2 = wp.lock();<br> if (sp2) { // 判空，确保安全<br> std::cout << *sp2 << std::endl;<br> } else {<br> std::cout << "资源已释放" << std::endl;<br> }<br> return 0;<br>} // 输出“资源已释放”，无崩溃<br>`4. 核心避坑点：- 永远不要直接解引用 `lock()` 的返回值，必须先判空；- `expired()` 仅作为参考，不能替代 `lock()` 后的判空（多线程场景下可能竞态）。 | 代码漏洞识别             |          |          |          |
|                                                              | 修复 shared_ptr 循环引用的代码？                             | 1. 循环引用的原始代码（见前文）；2. 修复核心逻辑：将闭环中的一个 `shared_ptr` 成员改为 `weak_ptr`，打破强引用闭环；3. 完整修复代码（以双向链表节点为例）：`cpp<br>#include <memory><br>#include <iostream><br>struct ListNode {<br> int val;<br> std::weak_ptr<ListNode> prev; // 改为weak_ptr<br> std::shared_ptr<ListNode> next;<br> ListNode(int v) : val(v) {}<br> ~ListNode() {<br> std::cout << "ListNode " << val << " deleted" << std::endl;<br> }<br>};<br>int main() {<br> auto node1 = std::make_shared<ListNode>(1);<br> auto node2 = std::make_shared<ListNode>(2);<br> // 建立双向关联<br> node1->next = node2; // node2强引用计数+1（变为2）<br> node2->prev = node1; // node1强引用计数不变（仍为1）<br> // 手动断开关联（可选，不影响析构）<br> node1->next.reset();<br> return 0;<br>} // 析构时node1计数减至0，释放；node2计数减至1，随后释放<br>`4. 输出结果：`<br>ListNode 1 deleted<br>ListNode 2 deleted<br>`5. 拓展说明：- 若为多节点闭环（如环形链表），只需将其中一个节点的 `shared_ptr` 改为 `weak_ptr` 即可；- 访问 `weak_ptr` 指向的节点时，需通过 `lock()` 升级为 `shared_ptr` 后操作。 | 问题修复能力             |          |          |          |
| 拓展对比                                                     | unique_ptr 和 shared_ptr 如何选择？性能开销？                | 1. 选型核心原则：- 优先选 `unique_ptr`：只要场景允许（独占所有权），`unique_ptr` 是最优选择，因为其无额外开销，性能接近裸指针；- 选 `shared_ptr`：仅当需要共享所有权时使用（如多个对象需共同管理一个资源）；2. 性能开销对比： | 类型                     | 内存开销 | 时间开销 | 适用场景 |
| ----------------------                                       | ----------------                                             | ------------------------------                               | ------------------------ |          |          |          |
| `unique_ptr`                                                 | 与裸指针一致                                                 | 析构仅释放资源，无额外操作                                   | 独占所有权、高性能要求   |          |          |          |
| `shared_ptr`                                                 | 裸指针 2 倍                                                  | 拷贝 / 析构需原子操作更新计数                                | 共享所有权               |          |          |          |
| 3. 选型示例：- 类成员指针：若类独占该资源，用 `unique_ptr`；若需与其他对象共享，用 `shared_ptr`；- 函数返回值：返回动态创建的对象，用 `unique_ptr`（自动移动，无计数开销）；- 容器存储对象：`vector<unique_ptr<Obj>>` 优于 `vector<shared_ptr<Obj>>`（除非需共享）；4. 注意事项：- 不要为了 “方便” 而滥用 `shared_ptr`，其原子操作的开销在高频调用场景下会被放大；- 若需将 `unique_ptr` 转为 `shared_ptr`，可直接拷贝（`std::shared_ptr<Obj> sp = std::move(up);`），反之不可。 | 选型逻辑与性能认知                                           |                                                              |                          |          |          |          |
|                                                              | C++17/20 对智能指针有哪些新特性？                            | 1. C++17 新特性：- `shared_ptr` 原生支持动态数组：`std::shared_ptr<int[]> sp(new int[5]);`，析构自动调用 `delete[]`，支持下标访问；- `std::make_shared` 支持自定义删除器：此前 `make_shared` 无法指定删除器，C++17 补充该能力；- `shared_ptr` 支持 `operator[]`：数组版 `shared_ptr` 可通过下标访问元素；- `std::weak_ptr` 支持 `owner_before`：用于排序（如放入 `std::set`）；2. C++20 新特性：- `std::make_shared` 支持数组的初始化：`auto sp = std::make_shared<int[]>(3, 1);`（创建长度为 3 的数组，元素初始化为 1）；- `std::shared_ptr` 支持 `constexpr` 构造：编译期构造空 `shared_ptr`；- `std::weak_ptr` 增加 `expired()` 的 noexcept 重载：提升异常安全；- `std::unique_ptr` 支持 `operator<=>`：三路比较运算符，简化比较逻辑；3. 示例（C++20 数组初始化）：`cpp<br>#include <memory><br>#include <iostream><br>int main() {<br> // C++20：make_shared初始化数组<br> auto sp = std::make_shared<int[]>(3, 10);<br> std::cout << sp[0] << ", " << sp[1] << ", " << sp[2] << std::endl; // 输出10,10,10<br> return 0;<br>}<br>` | 新标准掌握程度           |          |          |          |
|                                                              | 智能指针用于多线程需注意什么？                               | 1. `shared_ptr` 的线程安全规则：- 引用计数线程安全：多线程同时拷贝、析构、赋值 `shared_ptr`，计数不会错乱；- 指向对象的访问非线程安全：多线程读写对象时，必须加锁（如 `std::mutex`）；- `shared_ptr` 自身的赋值 / 交换：线程安全，但不保证对象安全；2. `unique_ptr` 的多线程规则：- 不可多线程同时访问同一个 `unique_ptr`（如拷贝、修改指向），因为其无线程安全保护；- 多线程传递 `unique_ptr` 需通过 `std::move` 转移所有权，且保证同一时间只有一个线程操作该指针；3. `weak_ptr` 的多线程规则：- `lock()` 方法是线程安全的，可在多线程中安全升级为 `shared_ptr`；- `expired()` 是线程安全的，但结果仅为瞬时状态，需配合 `lock()` 判空；4. 多线程安全示例：`cpp<br>#include <memory><br>#include <thread><br>#include <mutex><br>std::shared_ptr<int> sp = std::make_shared<int>(10);<br>std::mutex mtx;<br>void threadFunc(int val) {<br> std::lock_guard<std::mutex> lock(mtx); // 加锁保护对象访问<br> *sp = val;<br>}<br>int main() {<br> std::thread t1(threadFunc, 20);<br> std::thread t2(threadFunc, 30);<br> t1.join();<br> t2.join();<br> std::cout << *sp << std::endl; // 输出30（最后执行的线程修改）<br> return 0;<br>}<br>`5. 核心注意事项：- 智能指针仅保证自身计数 / 状态的线程安全，不保证指向对象的安全；- 多线程操作 `unique_ptr` 时，需通过互斥锁或线程局部存储（`thread_local`）保证唯一性。 |                          |          |          |          |

### 栈和堆的区别：

| 类别             | 栈                               | 堆                         |
| ---------------- | -------------------------------- | -------------------------- |
| 地址             | 从高向低增长                     | 从低向高                   |
| 存储数据         | 局部变量，函数参数，函数调用信息 | 程序运行时动态内存分配数据 |
| 数据生命周期     | 与函数执行周期相同               | 有开发者控制               |
| 分配和释放的速度 | 分配和释放是自动的，很快         | 有开发者管理，相对慢       |

### C++内存分区


![image-20240110142421854](https://file1.kamacoder.com/i/bagu/image-20240110142421854.png)

* 栈

​	栈用来存储局部变量，函数参数和函数调用等信息的区域。函数的调用和返回由栈来管理。

* 堆

​	存储动态分配的内存的区域，由开发者手动分配释放。使用`new`和`delete`或`malloc`和`free`进行堆内存的申请和释放。

* 全局/静态区（在编译时就分配好的）

  * 存储全局变量和静态变量的区域。

  * 已初始化全局/静态区（.data）

  * 未初始化全局/静态区（.bass）
  * 生命周期：程序**启动时**分配，结束时释放。

* 常量区
  * 常量区也被称为只读区。
  * 存储常量数据，如字符串常量。

* 代码区
  * 存储程序的代码。

### 什么是内存泄漏？如何避免？

* 内存泄漏：程序未能释放不再使用的内存空间。
* 分类：
  * 堆内存泄漏：既开发者通过`malloc`,`new`申请了堆内存，在使用后未能调用`free`，`delete`释放对应内存。就会产生`Heap Leak`
  * 系统资源泄漏：程序对于系统分配的资源`handle`，`socket`等，在使用后未能释放，导致系统资源浪费，严重时会导致性能下降，程序不稳定。
  * 没有将基类的析构函数定义为虚函数：在多态中，基类析构函数不是虚函数，不会调用派生类的析构函数，就会派生类的资源没有正确的释放，造成内存泄漏。

* 如何防止内存泄漏：
  * 申请放在构造函数中，释放逻辑放在析构函数中。
  * 将基类的析构函数声明为虚函数。

### delete和free的区别

* 类型安全：
  * delete会调用对象的析构函数，保证资源被正确的释放调用。
  * free不了解对象的构造和析构，只是释放内存块。
* 数组释放：
  * delete可以释放通过`new[]`申请的数组。
  * free不了解数组的大小，不适用于释放通过malloc申请的数组。

### 野指针和悬空指针

* 野指针（*Wild Pointer*）:
  * 定义：指针指向了不可预测的区域，
  * 原因：
    * 未初始化
    * 越界访问
    * 指针被非法修改
* 悬空指针（*Dangling Pointer*）：
  * 指针原本保存着一块有效的内存的地址，但该内存已经释放或生命周期结束，指针依然保存着原地址。

### 内存对齐：

* 数据在内存中的存储起始地址是某个值的倍数。
* 

### 进程的地址空间分布：

对于一个进程，其空间分布如下图所示：

![img](https://file1.kamacoder.com/i/bagu/_memory_xiaoyi.png)

* 命令行参数和环境变量：
  * 命令行参数是在执行程序时，给程序的参数。
* 栈区：
  * 存放局部变量，函数参数和函数调用信息等数据。
* 文件映射区：
  * 在栈和堆之间

* 堆区：
  * 存放动态分配的数据，由开发者通过`new`,`malloc`等申请，`free`，`delete`释放
* 未初始化全局区（bss)
  * 存放未初始化的全局变量，静态变量的区域
* 已初始化全局区（data）
  * 存放已初始化的全局变量，静态变量的区域。
* 代码区：
  * 存放执行代码的区域，只读。

## C++_面向对象

### 面向对象三大特征：

* 封装：
  * 将数据和操作数据的方式打包在类中，使用访问权限符：`public`，`protected`，`priviate`控制成员变量的访问权限。
  * 提高安全性，对外只能调用对应接口，不能直接修改内部数据。
* 继承：
  * 派生类获取到基类的**属性**和**行为**，可在原有的功能上进行拓展。提高了代码复用率。
* 多态：
  * 静态多态：在编译时就确认**调用函数绑定关系**。
  * 动态多态：在程序运行时根据**实际对象**决定调用那个函数。
  * 动态多态的实现原理：重写基类的虚函数，生存**虚函数表**和**虚函数指针**，通过基类的指针/引用指向派生类的对象，选取不同的虚函数表。

### 编译多态是否可以代替运行时多态？

* 编译多态：编译时确认函数调用关系，适合于**参数类型**、数量已经确认的情况下。
* 运行多态：要根据**对象真实类型**做动态绑定，适用于”**统一接口处理不同事物**“。
* 对象真实类型在**编译时就能确认**，且**避免虚函数表的开销**，可以使用**模板+策略**模式。

### 虚函数的底层调用机制是怎样的？`vtable`和`vptr`是怎么工作的？

虚函数背后有三样东西：虚函数表，虚函数指针，动态绑定。

* 虚函数表：每个含有虚函数的类，在编译时会产生一个虚函数表（`vtable`）,其用来存放**该类中虚函数的地址**。
* 虚函数指针：每个**对象**内部都会隐含一个虚函数指针（`vptr`），它用来指向该类的虚函数表（`vtable`）。
* `vtable`是类级别，（多个对象共享），`vptr`是对象级别。
* 动态绑定：基类的引用/指针指向派生类的对象时。**基类的虚函数指针->派生类的虚函数表**。当通过基类指针/引用调用虚函数时，程序会通过**基类的虚函数指针**找到**派生类虚函数表**，调用里面**重写的虚函数地址**。

### C++ 重载（overload）和重写（override）的区别和实现方式

* 重载（*overload*）：**函数名相同，参数类型，个数或顺序不同，发生在同一个作用域中**。
  * 发生在同一个类中。
  * 编译时就可以确认使用那个版本的函数。
  * 和返回值无关。
* 重写（*override*）：派生类重写基类的**虚函数，返回值，函数名，参数列表必须相同**，使用`virtual`和`override`关键字。
  * 必须有继承关系。
  * 基类中有虚函数
  * 子类重写的函数返回值，函数名，参数列表必须和基类相同。
  * 最好使用`override`进行编译时检查。

### 什么是虚函数?

基类中由`virtual`修饰的函数，其可以被派生类重写，可以使用动态绑定。

### override的作用

告知编译器，此函数为派生类重写基类的虚函数。进行检查。

### 什么是多重继承？

一个类可以从多个基类中获取属性和行为。

菱形继承：一个类同时继承与**两个拥有相同基类的类**，可能导致**二义性**和代码设计的复杂性。

* 虚继承：通过在继承声明中使用`virtual`关键字，可以避免在派生类中实现多个基类的实例，从而解决了菱形继承的问题。

### C++多态是如何实现的

* 基类虚函数的声明：基类中声明虚函数，用关键字`virtual`，以便于派生类可以重写（override）这些函数。
* 派生类重写基类的虚函数。
* 每个有虚函数的类都会有一个虚函数表（`vtable`）其存放着类中虚函数的地址。
* 每个类的对象会有一个隐含的虚函数指针`vptr`，其用来指向虚函数表。
* 当基类的指针或引用指向派生类的对象时，基类的虚函数指针->派生类的虚函数表。
* 当基类的指针或引用调用虚函数时，基类的虚函数指针就会在派生类的虚函数表中查询。

### 成员函数/成员变量/静态成员函数/静态成员变量的区别

* 成员函数：
  * 归属：归属于类。
  * 功能：可以访问类的成员变量，和成员调用。
  * 声明和定义：在类的内部，在类外定义要加域名。
* 成员变量：
  * 归属：归属于类的变量，存储在类的每个对象中。
  * 功能：每个对象都有一份变量的副本，在构造时创造，在析构时销毁。
  * 访问权限：`public`、`protected`和`private`
* 静态成员函数
  * 归属：归属类不属于对象，可以直接通过类名调用，不需要创建实例。
  * 功能：不能访问非静态成员变量，它没有隐含的`this`指针。
  * 定义和声明：在类的内部，在类外需要使用类名做限定符。
* 静态成员变量
  * 归属：归属类，不属于对象，它在所有对象之间共享。
  * 功能：对象之间共享，通过类名访问。
  * 定义和声明：在类内声明，在类外定义和初始化。

### 什么是构造函数和析构函数

* 构造函数：

  * 在对象构造时自动调用的特殊函数：**初始化对象的成员变量，为对象分配内存，执行必要的初始化操作**。
  * 函数名与类名相同，没有返回值。
  * 可以有多个构造函数，根据形参的不同实现重载。
  * 默认构造函数：当类没有显示定义任何构造函数时，编译器会自动生成一个默认构造函数。没有参数，也可能执行一些默认初始化操作。

  ```cpp
  class MyClass {
  public:
      // 默认构造函数
      MyClass() {
          // 初始化操作
      }
  
      // 带参数的构造函数
      MyClass(int value) {
          // 根据参数进行初始化操作
      }
  };
  
  ```

* 析构函数：对象生命周期结束时调用的特殊函数，用来**释放对象所占用资源，执行必要的清理操作**。特点：

  * 函数名与类名相同，前面加波浪号~
  * 没有参数：不能重载
  * 默认析构函数：若类没有显示定义任何析构函数，编译器会自动为其生成一个，执行简单的清理操作。

### C++构造函数有哪几种？

* **默认构造函数**：若类没有定义任何构造函数，编译器会为其生成一个默认构造函数，其没有参数，可以执行一些简单的初始化操作。
* **带参数的构造函数**：通过形参列表的不同实现构造函数重载，用传入的参数初始化成员变量。
* **拷贝构造函数**：通过已存在的对象创创建一个新对象，参数是**同类型的常量引用**。

```cpp
class MyClass {
public:
    // 拷贝构造函数
    MyClass(const MyClass &other) {
        // 进行深拷贝或浅拷贝，根据实际情况
    }
};
```

* **委托构造函数**：在一个构造函数中调用同类的另一个构造函数，减少代码重复。在成员初始化列表或构造函数内调用。

```cpp
class MyClass {
public:
    // 委托构造函数
    MyClass() : MyClass(42) {
        // 委托给带参数的构造函数
    }

    MyClass(int value) {
        // 进行初始化操作
    }
};
```

### 虚函数和纯虚函数的区别

| 类别           | 虚函数                                                       | 纯虚函数                                                     |
| -------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 声明           | `virtual`关键字声明                                          | 通过在虚函数后加`=0`修饰                                     |
| 实现           | 在基类中有声明实现。<br />派生类中可选择是否实现，若不实现，提供基类的实现。 | 可以有实现，必须在类的外部定义。可以在派生类中调用。<br />派生类若不实现，则派生类也是抽象类。 |
| 是否允许实例化 | 允许                                                         | 不允许，包含虚函数的类是抽象类，不能实例化。                 |
| 目的           | 实现多态                                                     | 提供**接口规范**，要求派生类提供相关实现。                   |

### 什么是抽象类和纯虚函数？

抽象类：包含纯虚函数的类是抽象类，其可以包含普通的成员变量，成员函数，但其不能被实例化。只能被作用继承的基类。

纯虚函数：`virtual`关键字和`=0`修饰的类中的成员函数，其所属类是抽象类。其派生类若不重写纯虚函数，派生类也是抽象类。

### 虚析构的作用

用`virtual`修饰一个类的析构函数。确保该类作为基类指针指向派生类对象时，`delete`释放该指针时，能够正确地调用派生类的析构函数，释放对象所占资源。

### 为什么要虚析构，而不是虚构造？

为什么要虚析构：

* 虚析构的作用是：多态场景下，派生类对象通过基类的指针释放时，能够完成正确的调用。
* 实现逻辑：
  * 基类中声明虚析构函数，基类的vtabl中包含析构函数的入口。
  * 派生类会重写该入口，指向自己的析构函数。
  * 销毁对象时，vptr会vtable找到正确的析构函数。

不是虚构造的原因：

* 构造函数的作用是**初始化对象本身**，对象构造完之前，**vptr尚未完全指向派生类的虚函数表**。
* 构造函数的调用规则：**编译期确定，而非运行期**。构造函数是“**静态绑定**”的—编译器在**编译阶段就确认**要调用构造函数，而不是运行阶段。

### 那些函数不能被声明为虚函数

* 构造函数：
  * 构造函数在对象被创建时调用的，其类型是在被创建时确认的。因此，构造函数不能是虚函数，因为虚函数的动态绑定是在运行时，而构造函数的对象类型在未创建时就会被调用。
* 非成员函数：
  * 只能被重载（overload）
* 静态成员函数：
  * 在编译时静态绑定，且类的对象共享，不需要
* 友元函数：
  * C++不支持友元函数继承，对于没有继承特性的函数没有虚函数说法。
* 内联成员函数：
  * inline在编译时插入调用位置，并展开。虚函数动态绑定在允许时，二者无法兼容。

### 浅拷贝和深拷贝的区别

* 浅拷贝：
  * 复制对象以及其成员变量的值。
  * 对于内部动态资源不会复制，新对象与原对象共享一份。
* 深拷贝：
  * 复制对象及其成员变量的值。
  * 对于内部动态资源也会复制，拥有自己独立的副本。

## C++并发编程

### std::thread

* 类：单个执行线程。用来包装函数或可调用对象，从而再单独的线程中执行。

* 初始化构造函数：创建一个`thread`对象，该`thread`对象可以被`joinable`，新产生的线程会调用`fu`函数，该函数的参数由`args`给出。
* 拷贝构造函数（被删除）
* 移动构造函数：`move`构造函数，调用成功之后x不代表任何`thread`执行对象。
* 注意：可被`joinable`的`thread`对象必须在它们销毁之前被主线程`join`或者被`detached`。**std::thread的对象在线程函数运行期间必须时有效的**。

```cpp
#include <iostream>
#include <thread>

void threadproc() {
    while(true) {
        std::cout << "I am New Thread!" << std::endl;
    }
}

void func() {
    std::thread t(threadproc);
}

int main() {
    func();
    while(true) {} //让主线程不要退出
    return 0;
}
```

上述程序会运行崩溃：**在func函数调用结束后，func中局部变量t（线程对象）被销毁，而此时线程函数仍在运行**。所以在使用`std::thread`类时，必须保证线程函数运行期间其线程对象有效。

* `detached`：让线程对象和线程函数脱离关系，这样即使线程对象被销毁，也不影响线程函数的运行。

```cpp
// 其他代码保持不变
void func() {
    std::thread t(threadproc);
    t.detach();
}
```

### lock_guard

`lock_guard`是一个**互斥量包装程序**，它提供了一种方便的RAII（*Resource acquisition is initialization*）-（资源获取既初始化-**将资源的生命周期与对象的生命周期绑定**）风格的机制来在**作用域块的持续时间内拥有一互斥量**。

创建`lock_guard`对象时，它将尝试获取**互斥锁**的所有权。当控制流离开`lock_guard`对象的作用域时，`lock_guard`析构并释放**互斥量**。

特点：

* 创建既加锁，作用域结束自动析构并解锁，无需手工解锁。
* 不能中途解锁，必须等作用域结束才解锁。
* 不能复制。

### unqiue_lock

unique_lock是一个通用的**互斥锁定包装器**，允许**延迟锁定，限时深度锁定，递归锁定，锁定所有权转移以及与条件变量**一起使用。

`lock_guard`的升级版，使用更加灵活方便，适应更多的业务场景。

特点：

* 创建时可以不锁定（通过第2个参数为:std::defer_lock），而在需要时再锁定。
* 可以随时加锁解锁。
* 作用域规则同`lock_guard`，析构时自动释放锁
* 不可复制，可移动
* 条件变量需要改类型作为参数。

### C++中如何创建和管理线程?

C++11 引入了`<thread>`头文件，提供了标准化的线程操作接口。

* 创建线程：使用`std::thread`创建一个线程，可以传递函数，函数指针，`lambda`表达式作为线程执行的内容。
* 线程的生命周期管理：
  * join()：主线程调用`join()`来等待新线程的结束。`join()`确保主线程等待子线程完成，避免主线程提取结束，导致子线程被销毁。
  * `detach()`：如果不需要等待子线程结束，期望其独立运行，可以调用`detach()`。被`detach`的线程会在后台继续执行，主线程结束后，`std::thread`会自动清理资源。**脱离`std::thread`对象和子线程的关联**。
* 线程的返回值：`std::thread`本身不支持线程返回值。可以同`std::future`和`std::promise`来异步获取结果。

```cpp
#include <iostream>
#include <future>

int add (int a, int b){
    return a + b;
}

int main(){
    // 使用 std::async 启动线程并返回 std::future
    std::future<int> result = std::async(std::launch::async, add, 5, 3);
    
    // 获取线程结果
    std::cout << "Result:" << resule.get() << std::endl;
    return 0;
}
```

* 如果未调用`join()`或`detach()`，`std::thread`析构时会强制终止程序，**这是C++防止线程泄漏的安全机制**。
* **为什么`detach()`后无法控制线程？**分离的线程右C++运行时托管，无法再获取其状态或结果，也不保证生命周期。
* **何时用`join()`VS`detach()`?** `join()`用于需要等待结果的场景，·`detach()`用于后台监控、日志写入等无需交互的任务。

### std::mutex

* `std::mutex`是互斥量，提供基本的**线程同步机制**，用于保护共享数据。
* 当一个线程锁定了一个互斥量，其他尝试锁定同一个互斥量的线程会阻塞，直到互斥量被解锁。
* `std::mutex`提供了`lock()`、`unlock()`和`try_lock()`方式来控制互斥量的状态。

### 条件变量std::condition_variable

* 用于线程间的通信，允许线程等待某个条件成立后再继续执行。
* 通常与互斥锁一起使用，通过`wait()`，`notify_noe()`，`notify_all()`方法实现线程的等待和唤醒。
* 示例：

```cpp
std::mutex mtx;
std::condition_variable cv;
bool ready = false;
void wait_for_ready() {
    std::unique_lock<std::mutex> lock(mtx);
    cv.wait(lock, []{ return ready; });
    // 条件满足后继续执行
}
void set_ready() {
    std::lock_guard<std::mutex> lock(mtx);
    ready = true;
    cv.notify_all();
}
```

### **原子操作(std::atomic)**

* **多线程环境下不可中断的最小操作单元**。
* shared_ptr的强引用计数。
* 示例：

```cpp
std::atomic<int> counter(0);
void increment() {
    counter.fetch_add(1);
}
```

### 信号量 (std::counting_semaphore)

* 用于控制对共享资源访问的数量，允许多个线程同时访问有限数量的资源。
* 通过`acquire()`和`release()`方式控制资源的获取和释放。

* 示例：

```cpp
std::counting_semaphore<10> semaphore(10);
void access_resource() {
    semaphore.acquire();
    // 访问资源
    semaphore.release();
}
```

### **策略锁**：

* `std::shared_mutex`提供了共享锁 ，允许多个线程读取共享数据，但只允许一个线程写入。

### **线程局部存储**：

* `thread_local`关键字可以声明线程局部的变量，这些变量每个线程中有独立实例，互不干扰。

## C++ 网络编程：

### 在C++中，如何使用sockets进行TCP通信？

**服务端：**

* 创建socket：通过`socket()`创建流式套接字（TCP）
* 绑定地址：通过`bind()`将socket与IP进行绑定。
* 监听链接：使用`listen()`开启监听，设置最大连接队列。
* 接收连接：`accept()`阻塞等待客户端连接，返回新的`socket`用于通信。
* 数据收发：使用`send()`和`recv()`进行数据的发送/接收
* 关闭`socket`：通信结束后关闭。

[server.cpp](../Internet/SourceCode/TCP/server.cpp)

**客户端：**

* 创建套接字：同服务器端
* 连接服务器：通过`connect()`向服务器发起连接请求。
* 数据收发：同服务器
* 关闭`socket`：通信结束后关闭。

[client.cpp](../Internet/SourceCode/TCP/client.cpp)

### 在C++网络编程中，如何处理粘包和拆包问题？

* 固定发送包的大小：发送端将每个发送的包固定为100字节的大小，若不足一百个字节补0填充。
* 发送端给包的末尾使用固定的分隔符：`\r\n`。如果发生拆包需等待多个包发送过来之后再找到其中的`\r\n`进行合并。
* 将消息分为头部和消息体：头部保存整个消息的长度，只有读取到足够的长度才算是读到一个完整的消息。
* 通过自定义协议进行沾包和拆包的处理：定义每个数据帧的帧头和帧尾。

### [拓展] 错误处理和优化

* 非阻塞IO：使用`fcntl()`设置socket非阻塞模式。
* 超时设置：通过`set_socketopt()`设置`SO_RCVTIMEO`和`SO_SNDTIMEO`避免永久阻塞。
* 地址复用：设置`SO_REUSEADDR`标志允许快速重启服务器。
* 网络字节序转换：`htons()`、`htonl()`

```cpp
int opt = 1;
setsockopt(server_fd, SO_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
```

### [拓展]面试陷阱

* TCP和UDP的区别：TPC提供可靠的、面向连接的通信；UDP无连接、不可靠但效率高。
* 为什么服务器要两个`socket`? 
  * 监听`socket`用于接受连接请求，建立链接。
  * 通信`socket`用于与客户端的实际通信，可创建多个。
* 如何关闭TCP连接？使用`shutdown()`而非之间`close()`,可以指定关闭的发送或者接受方向，避免数据丢失。

```cpp
shutdown(sockfd, SHUT_RDWR);	// 关闭读写。
```

### 解释一下socket编程中的阻塞模式和非阻塞模式，以及它们之间的区别

* **阻塞模式**：socket I/O操作（`read`、`write`、`accept`、`connect`等）会阻塞调用线程，直到操作完成或发生错误。解决方法：多路复用。

* **非阻塞模式**：非阻塞模式下，socket I/O操作不会阻塞调用线程。如果操作无法完成，会立刻返回，并返回错误码。非阻塞模式通常用于I/O多路复用。结合`select`、`epoll`、`poll`

* 如何切换阻塞和非阻塞模式：

  * 调用系统`fcntl()`：*file control*

  ```cpp
  #include <fcntl.h>
  // 获取文件描述符标志
  int flags = fcntl(sockfd, F_GETFL, 0);
  // 设置文件描述符状态
  fcntl(sockfd, F_SETFL, flags | O_NOBOLOCK);		// 非阻塞模式
  ```

  * 调用`ioctl()`

  ```cpp
  #include　<sys/ioctl.h>
  int nonblocking = 1;
  ioctl(sockfd, FIONBIO, &nonblocking);
  ```

### 如何编写一个C++服务器，能够同时处理多个多个客户端的连接请求？

C++服务器处理多个客户端连接的核心方案有以下三种，各有适用场景：

* **多进程/多线程模型**：
  * 多进程：每个客户端连接`fork`一个子进程
  * 多线程：每个客户端连接创建一个新进程。
  * 优点：编程简单，隔离性好
  * 缺点：资源消耗大（线程/进程上下文切换开销）
* **I/O多路复用模型**：
  * `select/poll`：单线程轮询多个`socket`（select有`FD`数量限制）
  * `epoll(Linux)`：事件驱动，高效处理大量连接（LT/ET模式）
  * 优点：资源利用率高，适合高并发
  * 缺点：编程复杂度高。
  * 代码实现：[server.cpp](../Internet/SourceCode/select/server.cpp)
* **异步I/O模型**：
  * `Windows IOCP / Linux aio`：内核直接通知I/O完成
  * 优点：线程利用率最大化。
  * 缺点：平台依赖，调试困难。

## C++高级特性

### C++11的新特性：

* 成员遍历默认初始化。
* **`auto`关键字：允许编译器自动推断变量的数据类型，减少类型声明的冗余**。

* `decltype`求表达式的类型。
* **智能指针`std::shared_ptr`和`std::unique_ptr`**
* **空指针`nullptr`：提供了明确标识空指针的关键字，替代了传统的`NULL`**
* **基于范围`for`循环：简化遍历容器元素的循环。**
* 右值引用和语义移动：引入右值引用和移动构造函数，高效地将资源从一个对象转移到另一个对象，提高性能。
* **`Lambda`表达式：允许在代码中定义匿名函数。**

### 类型推导

#### 1.auto:

* 必须初始化：否则无法推到出类型。
* 在一行多个变量时，各个变量的推导**不能产生二义性**，否则编译错误。
* 不能作用函数参数。
* 在类中不能作用非静态成员变量。（类的内存布局要在编译时确认，auto推到会导致成员大小无法计算）。
* auto不能定义数组（直推导单个维度），可以定义指针。
* 无法推到模块参数
* 不声明为引用或指针时，auto会忽略等号右边的**引用类型**的**CV限定（`const` `volatile`）**。
* 声明为引用或指针时，auto会保留等号**右边的引用类型**和**CV限定**。
* 简化：
  * 必须初始化，一行变量不能由二义性，不声明引/指，忽略右侧的引用类型和CV限定，声明引/指，保留。
  * 不能作用：函数参数、非静态成员变量、模板参数、数组。

#### 2.decltype:

* 仅用于推导表达式类型，不会执行表达式计算。
* 保留引用和cv属性（顶层`const`，既对象本身是`const`）。

* `decltype(exp)`:
  * exp是表达式：推导结果和exp相同
  * exp是函数：推导结果是返回返回值类型
  * exp是左值，是类的左值引用

### 右值引用

**左值右值：**

左值：可以放在等号左边，可以取地址并且名字。字符串字面值“abcd”也是左值，不是右值。

右值：不可以放在等号左边，不可以取地址，没有名字。

1.将亡值：

C++11为解决“临时对象拷贝开销”引入的概念，通过明确“**可移动对象**”这一类别，让编译器准确匹配语义，大幅提升**临时对象传递的效率**。它**不是新的对象类型**，是即将销毁对象的**语义标记**，核心服务于移动语义。

2.左值引用：对左值引用的类型，是**对象的别名**。

3.右值引用：表达式等号右边的值是右值，可以使用`std::move()`函数强制把左值转换为右值。

4.移动语义：转移所有权，资源转为自己所有，别人不在拥有也不能使用。通过移动构造函数使用移动语义，也就是`std::move`；**移动语义仅针对已实现移动构造函数的类的对象**，对于基本类型`int`，`float`等没有任何优化作用，还是会拷贝，因其未实现对应的移动构造函数。

5.完美转发：写一个接收任意实参的函数模板，并转发到其它函数，目标函数会收到与转发函数完全相同的实参，通过`std::forward()`实现。

### 列表初始化

列表初始化：采用花括号进行初始化。对于内置类型变量，使用列表初始化存在丢失信息风险时，编译器会报错。

```cpp
long double d = 3.1415926536; 
int a = {d};    //存在丢失信息风险，转换未执行。
int a = d;      //确实丢失信息，转换执行
```

### lambda表达式

lambda表达式：可调用的代码单元，返回值由编译器推测（无return语句，均为void）,无函数名。

* 构成：`[捕获](参数列表（可省略）){函数体}`
* 值捕获：在创建时拷贝

```cpp
void func1()
{
    int x = 42;
    auto f = [x]{return x;};  // 创建时拷贝
    x = 0;
    auto j = f();	// 42
}
```

* 引用捕获：创建时引用

```cpp
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2();		// 0; f2保存的是v1的引用
}
```

* 隐式捕获

```cpp
[]								空
[names]							显示捕获
[&]								隐式引用捕获
[=]								隐式值捕获
[&, identifier_list]
[=, identifier_list]
```

* 使用成员变量：捕获当前类的this指针

```cpp
    connect(m_win1ptr, &window1::customWindow1Signal, this,
            [this](){
        m_win1ptr->hide();		// 相当于this->m_win1ptr->hide();
        m_win2ptr->show();
    });
```

* 可变`lambda`：对捕获的值可进行修改，必须添加`mutable`。引用取决于是否被`const`修饰。

```cpp
void fcn3()
{
    size_t vi = 42;
    auto f = [vi] mutable {return ++vi;};
    vi = 0;
    auto j = f();	// 43, 创建时拷贝
}
```

### C++的异常处理机制与示例

#### 传统错误：

* 终止：`assert`，内存错误，除0时错误。
* 返回值：开发者根据错误返回值确认。

#### C++异常：

* 语法错误：编译器可以拦截
* 运行时错误：文件打开失败，数组下标溢出，系统内存不足等。

#### C++异常安全处理方式：更弹性、安全性、稳定性

* 三大关键字：
  * `throw`：抛出异常对象。
  * `try`：定义可能发生异常的代码块
  * `catch`：捕获抛出的异常并处理。
* 异常的抛出和匹配原则：
  * 异常对象的拷贝：考虑到抛出的异常可能是一个临时对象，为保证在异常处理期间有效性，抛出异常对象后，会生成一个异常对象的拷贝。
  * 异常对象的类型决定匹配：抛出异常对象的类型，决定激活对应的`catch`块进行异常处理。
  * 最近匹配原则：如果调用链中存在多个`catch`与异常对象匹配，则距离抛出异常最近的`catch`会被激活处理异常。
  * `catch(...)`捕获所有异常块：它可以捕获所有异常，但无法确认异常类型，故用来处理未知异常。
  * 基类匹配原则：抛出派生类对象，`catch`可以使用基类进行捕获。通常用于处理一组管理类型。
* 异常安全：建议在构造和析构函数中避免抛出异常，避免对象不完整或资源泄漏等问题。
  * 构造函数中的异常：**抛出异常时，已执行的代码全部被撤销，对象将被销毁，且析构函数不会调用**。这可能**导致资源泄漏**或**对象状态**不一致，为了避免这种情况，构造函数尽可能不要抛出异常，或使用**初始化列表**和异常安全的编程技术来处理异常。
  * 析构函数中异常：可能会导致**其他代码无法正常处理资源的释放和清理工作，导致资源泄漏**。为避免此类情况，应在析构函数中尽量避免抛出异常，或者使用异常安全的编程技术来处理异常。
  * 资源泄漏问题：
    * 异常在C++中确实可导致资源泄漏的问题。例如：new进行动态内存分配时，如果在**分配后抛出异常而没有正确释放内存**，就会导致内存泄漏。
    * 使用锁进行资源保护时，如果在锁定和解锁之间抛出异常，可能会导致死锁或资源未正确释放。
    * 为解决上述问题，可以使用RAII技术，通过对象的构造函数获取资源，并在析构函数中释放

  * C++标准库的异常体系：
    * C++标准库提供了一个异常体系，其中定义了一些常见的异常类型，这些类型是继承与`std::exception`类的

* 常见的异常类型：
  * std::exception
  * std::bad_alloc
  * std::bad_cast
  * std::out_of_range

* 异常安全的目标：
  * **避免资源泄漏**：即使发送异常，所有的资源（内存、文件句柄、锁等）都能被正常释放。
  * **保持数据的一致性**：确保程序在发送异常时不会处于不一致的状态。
  * **不影响程序的稳定性**：即使发送异常，程序任然可以稳定运行。


### 命名空间（namespace）的作用是什么？

C++中变量、函数、类都是大量存在的，这些变量、函数和类名称都将存在与**全局作用域**中，可能会导致很多的冲突。使用命名空间的**目的对标识符名称进行本地化**，以避免**命名冲突**或**名字污染**。

**定义：**

定义命名空间，需要使用到namespace关键字，后面跟命名空间的名字，之后使用`{}`，`{}``中就是命名空间的成员。

**使用：**

命名空间里的成员相当于有一个**域的封装**，所以在访问时要加上作用域限定符（`::`）

### inline函数的作用

* 向编译器发出请求，将函数直接插入到调用点，而不是正常的函数调用机制，这通常用于**小型、频繁调用的函数**。

* 目的是减少**函数调用参数压栈和返回地址等操作**的开销，并提高执行效率，但这回增大代码体积，影响缓存性能。

* 这只是一个请求，编译器可以不处理。

### 左值引用和右值引用的区别？

1.定义：

* 左值引用：只能绑定左值（可以放在等号左边，可寻址）。

* 右值引用：
  * 只能绑定纯右值（字面量，临时对象，`std::move`）。
  * 绑定后“延长临时对象的声明周期”（直至失效）。

2.核心用途

* 左值引用：
  * 函数参数传参（避免拷贝）。
  * 函数返回值（返回变量别名）。
* 右值引用：
  * 实现语义移动（`std::move`）：转移临时对象的内存，避免深拷贝。
  * 实现完美转发（`std::forward`）：在模板中保持参数的左/右值属性。
  * 捕获临时对象（`std::unique_ptr`）只能用右值引用传递。

3.可修改性：

* 左值引用：非const：可以修改绑定对象。
* 右值引用：可修改绑定的临时对象（`int&& ref = 10，ref = 20`合法）。

4.地址获取：

* 左值引用：`&ref`能获取绑定对象的地址（和原值地址一致）。
* 右值引用：`&ref`能获取临时对象的地址（临时对象引用绑定而不销毁）。

5.核心：

* 左值引用：“给已有变量取别名”，解决拷贝开销
* 右值引用：“绑定临时对象”，核心是实现移动语义和完美转发；`std::move`仅做类型转换，不移动任何数据。

6.避坑点

* 右值引用本事是[左值]，（如`int&& ref = 10`，`ref`是有名称的值）。
* `std::move`不改变对象的状态，仅将左值转换为右值引用，真正的资源移动由移动构造/赋值函数实现。
* 不要返回局部变量的左值引用（局部变量销毁后引用悬空），但可以返回右值引用（临时对象延迟声明周期）。

## 进程和线程

### 32位系统的地址空间有多大？

`2^32 = 2^10 * 2^10 * 2^10 * 2^2 = 1MB * 2^10 * 2^2 = 1GB * 4 = 4GB

32位系统：地址总线是32根线，所以就有4G的物理地址。

### 什么是物理地址？什么是虚拟地址？

物理地址：32位系统，SOC的地址总线是32根地址总线，有4G的物理地址空间。

虚拟地址：从物理地址映射到虚拟地址，一般带有操作系统的应用，都是在虚拟地址上，这样就可以让每个应用程序看起来都有4G的内存空间。

