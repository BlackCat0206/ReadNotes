# Linux_Base

---- Chime Lee

## 一、概述



## 二、内容

### 2.1 Linux系统重进程默认栈空间是多大？如何修改？

Linux系统中，进程默认栈大小由**操作系统内核**设置，通常是8MB。

修改命令：

```bash
# 单位KB
ulimit -s <stack_size>
```

### 2.2 用户空间于内核通信方式有哪些？

* 系统调用：读写文件，创建进程等。
* 文件接口：通过文件接口**读写文件**与内核进行通信。
* proc下文件：读写/proc文件系统的特定文件与内核通信，查询或修改**内核状态和信息**。
* sys_fs：读写/sys文件系统中文件与内核通信，查询或修改**设备属性和参数**。
* netlink套接字：通过netlink套接字与内核通信，用于**网络配置，管理**等。
* 共享内存：映射共享内存区域来读写数据，实现高效数据交换。
* 设备文件：打开读写设备文件与内核进行通信，如**串口设备、字符设备**。

### 2.3 Linux下检查内存状态的命令

* `free`：查询系统内存的使用情况，总内存，已使用内存，可用内存等。
* `top`：系统的整体资源使用情况，显示每个进程使用内存的情况。
* `vmstat`：虚拟内存统计信息，使用情况，交换情况。
* `/proc/meminfo`文件：系统内存的详细信息。
* `pmap`：线程进程内存映射的详细信息，内存地址，权限，映射文件。

### 2.4 自旋锁和互斥锁的使用场景

自旋锁（Spin Lock）和互斥锁（Mutex Lock）常见的线程同步机制。

| 类型     | 自旋锁                                 | 互斥锁               |
| -------- | -------------------------------------- | -------------------- |
| 等待方式 | 忙等待，一直循环检查锁状态，直到获得锁 | 阻塞等待             |
| 切换方式 | 不涉及上下文切换，多核处理器上表现更好 | 需要进行上下文切换   |
| 适用场景 | 时间占用短或竞争不激烈                 | 临界区较长或竞争激烈 |

### 2.5 线程池的设计思路



### 2.6 Linux的fork的作用？

* fork是一个系统调用，用于创建新的进程。
* 创建的子进程会有独立代码路径，可以执行不同的操作。子进程也可以创建新的进程，实现层级关系。
* 返回值不同：每个进程都有独立的进程ID，子进程创建时，父进程会将独立的进程ID赋予子进程。父进程中返回的子进程的ID，子进程的返回值是0。
* 生命周期：父进程和子进程的生命周期是独立的，父进程先消亡，子进程是孤儿进程，由init进程回收。若子进程消亡，但父进程为等待销毁，则为僵尸进程。
* 资源继承：子进程会继承父进程的绝大部分属性，代码、数据、堆栈、进程上下文、打开的文件、环境变量、当前工作目录。

### 2.7 什么是文件系统，它有什么用？

**存储管理：**将文件存储在计算机硬盘、磁盘等固件上，负责**分配和回收存储空间**。

**文件组织：**提供文件结构和目录结构，帮助用户**分层、分组和管理**。

**文件访问控制：**提供文件访问控制权，针对不同的用户设置文件访问权限。可以b。

**文件的操作和管理：**提供了一系列系统接口，实现对文件的打开、读取、写入、删除、压缩等操作，同时访问文件属性（大小、类型、创建时间）等。

**文件共享和备份：**提供了文件共享功能，允许多个用户同时访问和修改同一个文件，提高信息共享。提供文件备份和恢复功能，确保数据安全和可靠性。

### 2.8 进程调度算法是什么？

**先来先服务（FCFS）**：按照进程到达的先后顺序进行调度。先到达的进程先被执行，直到该进程阻塞或完成。

**短作业优先（SJF）**：根据进程执行的时间来调用，执行时间短的进程先被执行。此算法可以**最小化平均等待时间，但可能会导致执行时间长的进程饥饿**。

**最短剩余时间优先（SRTF）**：根据进程剩余执行时间进行调度。刚到达的进程剩余执行时间比当前进程的剩余执行时间短，则进行切换。

**优先级调度**：为每个进程分配一个优先级，优先级高的进程先被执行。

**时间片轮转调度（Round Robin）**:将CPU的时间分配相同的时间片，每个进程在一个时间片内执行，结束后将其加入就绪队列队尾。

**多级反馈队列调用：**将就绪队列分为多个队列，每个队列都有不同的时间片。新到达进程进入第一个队列，执行后若还有时间进入第二个队列，以此类推。根据进程的特性分配不同的优先级。

### 2.9 简述LRU算法及其实现方式

LRU(Least Recently Used)：用于页面置换，当进行进行页面置换时，选择使用最少的页面替换。

### 2.10 什么是页表，作用是什么？

页表（Page Table）：操作系统的数据结构，管理**虚拟内存和物理内存的映射关系**。记录了**进程的页（Page）于物理页框（Page Frame）的对应关系**。

**作用：**

**映射关系：**页表将进程的虚拟内存转换为真实的物理内存，这样进程就可以**使用连续的虚拟地址而不需要关注真实的物理内存布局**。

**内存管理**：将进程的地址空间划分为固定大小的页，将物理内存空间分割为与页大小相同的块。操作系统根据需要进行**页面调度**，将进程所需的虚拟页加载到物理内存中。

**内存保护**：页中记录**访问权限和控制位等信息**。操作系统根据页保存内存空间，进程只能访问其所拥有的内存空间，防止越界访问和违法操作。

**虚拟化技术支持：**虚拟机监控程序会单独维护页面，**将虚拟机内存地址转换为物理内存地址**，隔离不同虚拟机之间的内存空间。

### 2.11 简述缺页中断

**缺页异常：**`malloc()`和`mmap()`只分配了虚拟地址空间，未分配虚拟内存对应的物理内存。当进程访问**没有建立映射关系的虚拟内存**，**处理器自动引发一个缺页异常，触发缺页中断**（*Page Fault*）。

**缺页中断：**产生缺页中断后，操作系统会根据页表中**外存地址**找到外存中缺失的一页，将其调入内存。

**缺页中断执行过程：**

* **CPU触发中断：**程序访问未建立映射关系的虚拟内存->CPU暂停，发出缺页异常，引发缺页中断。（将控制器从CPU转换到操作系统）。
* **内存合法检查：**操作系统内核捕获到中断，检查中断原因，若为非法访问（越界），直接终止进程。若合法但未加载，进入下一步。
* **内存空间准备：**有空闲的物理页框直接用->无空闲则用置换算法（LRU/FIFO）选择一页换出磁盘。
* **加载页面+更新页表：**从磁盘中读取物理页框->更新页表映射关系”，标记该页“已存在”。
* **恢复程序执行：**被中断的程序从缺页异常的指令处，继续执行。

**缺页中断的目的：**实现虚拟内存的概念，允许程序使用比物理内存更大的内存空间，将常用的页放在物理内存中，将不常用的页放在磁盘中，通过缺页中断将磁盘中的页加载到物理内存中。

### 2.12 简述一下虚拟内存和物理内存，为什么要用虚拟内存？

**虚拟内存：**它为每个进程分配了独立的地址空间，这个地址空间就叫做虚拟内存。允许程序使用比物理内存更大的内存。

**物理内存：**计算机中内存硬件，RAM（*Random Access Memory*）组成。

**好处：**

**扩展内存容量：**允许进程访问超过物理内存容量的虚拟地址空间。当物理内存不足时，操作系统将置换出磁盘中不常用的页，释放物理内存空间。

**内存隔离：**每个进程都有独立的虚拟地址空间，一个进程的异常不会影响其他进程。

**简化程序设计：**开发者将内存视为连续存储的地址，不需要关注物理内存的限制和分配。

### 2.13 虚拟地址到物理地址怎么映射？

虚拟地址到物理地址通过页表（Page Table）实现的。页表是操作系统的数据结构，管理虚拟内存和物理内存的映射关系，记录页和物理页框的对应关系。

**程序访问虚拟地址，操作系统将虚拟地址转换为物理地址的过程：**

* 程序生成虚拟地址，地址拆分为： **页号 + 页内偏移**
* 操作系统根据**页号**，在当前进程的**页表**中，找到对应**页表项**。
* 从页表项中取出**物理页框号**，替换**虚拟地址的页号**。
* **物理页框号 + 页内偏移** -> 最终拼接的物理地址。

**32位线性系统地址：页目录索引（10位）、页号（10位）、业内偏移（12位）**

* 从CR3寄存器中取出**页目基地址**。
* 页目录基地址 + 页目录索引->页表地址。
* 页表地址 + 页号 -> 页表项，从页表项中取出**物理页框号**
* 物理页框号 + 页内偏移 -> 物理地址。

### 2.14 用户态和内核态的区别，进入内核的方法

用户态和内核态的主要区别在**权限**和**安全性**上。

* 权限：**内核态拥有最高权限，可以访问和执行所有的系统指令和资源。**用户态权限较低，只能执行和访问受限的系统指令和资源。
* 安全性：**由于内核态拥有最高权限，错误的操作会导致系统的不稳定和不安全。为了系统的稳定和安全，将操作系统的核心部分下放到内核运行，限制用户态的操作。**用户态必须通过**系统调用**的方式向内核请求操作系统的服务和资源。

* **进入内核态的方法：**
  * **系统调用**：应用程序主动向内核发送请求。
  * **异常**：由应用程序的错误或异常触发的，如：非法访问，内存越界。
  * **设备中断**：由外部设备产生的中断信号，需要内核处理。

### 2.15 段页式内存管理有什么优点？

段页式内存管理结合了段式内存管理的优点和页式内存管理的优点，提供了：**灵活性、保护性、共享性和虚拟化支持**。

* **灵活性：**更方便管理不同类型的程序和数据，细致地进行内存分配和利用。
* **保护性**：设置段和页的访问权限，可以对内存进行访问控制，保护数据的安全性。
* **共享性**：段页式内存管理支持多个程序同时访问同一页或同一段，减少内存重复存储，提高内存使用效率。
* **虚拟化支持**：通过页表和页面的转换，实现虚拟地址向物理地址的转换，同时与其他虚拟机地址隔离。

### 2.16 Linux内核的组成？

* **进程管理**：进程的创建、销毁和调度等功能。
* **内存管理**：物理内存的分配和释放、虚拟内存的映射和管理。
* **文件系统**：提供存储设备和文件访问接口，支持各类文件系统格式。
* **设备驱动**：提供硬件设备的抽象和控制接口，支持各类驱动程序。
* **网络协议栈**：实现各类网络协议，提供网络通信功能。
* **系统调用**：应用程序通过系统调用向内核申请操作系统的服务和资源。

### 2.17 系统调用的作用？

* **用户态向内核态的切换**：用户态运行的应用程序通过系统调用切换至内核态，执行或访问操作系统的核心指令或资源。
* **提供操作系统资源**：用户态应用程序通过系统调用申请操作系统的资源。如：文件读写（文件系统），网络通信等（网络协议栈）
* **提供操作系统服务：**用户态应用程序通过系统调用申请操作系统的服务。如：进程管理，内存管理和网络通信等。
* **实现进程间通信：**提供了进程间的通信机制，允许不同应用程序间数据交换。应用程序通过系统调用进行消息传递，访问共享内存等。

### 2.18 系统调用`read()/wirte()`，内核具体做了什么事情。

* 用户空间发起`read()/write()`系统调用，将**参数**传递给内核。
* 内核通过**系统调用号**找到对应的**内核函数**进行处理，`sys_read()/sys_write()`。
* 内核根据**文件描述符**找到对应**文件对象**，进行读取或写入操作。
* 读操作：**内核**将**数据**从**文件**或**设备**中读取到**内核空间**，并用**页缓存**管理。

* 写操作：内核将**数据从用户空间拷贝至内核空间**，通过**文件系统层**写入文件或设备。
* 内核可能会通过**缓存管理**、**块设备管理**、**驱动程序**对数据进行依次处理。
* 处理完成后、内核将**结果返回给用户空间**，用户空间继续执行下一步操作。

### 2.19 Bootloader内核和根文件的关系

Linux系统从软件可以理解为：**Bootloader（引导加载程序）、Linux内核、文件系统**

* **引导加载程序**（*Bootloader*）**：**第一个执行的代码**、**不依赖内核和文件系统**、负责**系统的引导和初始化**。它包括在硬件中的boot代码和Bootloader程序。它责任：初始化硬件、加载Linux内核、配置参数，将控制器移交到内核。

* **Linux内核**：管理系统的硬件资源，提供进程管理、内存管理、文件操作、驱动程序、网络协议栈和系统调用。会根据Bootloader配置的**启动参数**找到**根文件系统**的**存储位置和文件系统类型**，完成**挂载操作**。**进入用户空间第一个进程`sbin/init`，系统进入可操作状态**。

* **文件系统**：系统通常有一个或多个文件系统。根文件包含了操作系统所需要的**基本文件和目录结构**，包含了系统运行必要的资源：
  * 启动脚本、系统配置文件
  * 标准C库，系统命令
  * 设备节点、驱动模块，用户应用程序。

### 2.20 Bootloader多数由两个阶段的启动程序

**理论：**

**预引导阶段（*pre-load-Stage*）：**

* 第一阶段：硬件初始化和基本系统设置，检测初始化处理器、内存、时钟、总线和其他外设操作。
* 第二阶段：加载存储在存储介质上的第二阶段Bootloader代码，负责更高级的系统初始化和配置。这个阶段还可以提供用户界面，Bootloader配置或固件升级。

**操作系统加载阶段（Operating System Load Stage）：**

* 引导加载程序从存储介质中**读取Linux内核到内存指定位置**，并进行一系列配置，内核参数、初始化设备树等。通过`bootz`或`bootm`将控制器移给内核。

**实际开发：**

**硬件初始化——由汇编实现，实现片内ROM或FLASH的起始地址。**

* 具体操作：关闭看门狗、初始化CPU寄存器、配置时钟、初始化DDR内存、设置栈顶指针。从外部存储介质（EMMC FLASH）将bootloader第二阶段代码搬运到DDR中，并跳转到其入口地址执行。
* 汇编实现

**功能扩展阶段——C语言实现**

* 具体操作：初始化更多外设（UART、I2C等），解析启动参数，从存储介质中**读取Linux内核和设备树文件**到DDR指定区域，最终通过`bootz`或`bootm`移交控制器给内核。
* C语言实现。

示例：

阶段一：

```armasm
/*
 * 嵌入式Bootloader第一阶段：汇编代码（ARM架构）
 * 核心：裸机硬件初始化，为C语言运行准备环境
 */
.globl _start  /* 定义全局入口符号，链接器会将此地址设为启动地址 */
_start:
    /* 1. 异常向量表（ARM架构必需，简化版只保留复位入口） */
    b   reset       /* 复位异常：跳转到reset标签 */
    b   hang        /* 未定义指令异常 */
    b   hang        /* 软中断异常 */
    b   hang        /* 预取指中止异常 */
    b   hang        /* 数据中止异常 */
    b   hang        /* 保留异常 */
    b   hang        /* IRQ中断 */
    b   hang        /* FIQ中断 */

/* 2. 核心初始化逻辑：reset标签 */
reset:
    /* 步骤1：关闭看门狗（防止CPU被意外复位） */
    ldr r0, =0x20C0000  /* 看门狗寄存器基地址（以IMX6ULL为例） */
    ldr r1, =0x0        /* 写入0关闭看门狗 */
    str r1, [r0]        /* 寄存器赋值：*(0x20C0000) = 0 */

    /* 步骤2：配置系统时钟（PLL），简化版省略具体时钟配置 */
    bl  clock_init     /* 调用汇编函数clock_init，初始化PLL和分频 */

    /* 步骤3：初始化DDR内存（关键！为C语言提供运行空间） */
    bl  ddr_init       /* 调用汇编函数ddr_init，配置DDR控制器 */

    /* 步骤4：设置栈指针（C语言运行必需！栈要放在已初始化的DDR中） */
    ldr sp, =0x80800000  /* 将栈指针设为DDR的0x80800000地址（IMX6ULL的DDR起始地址） */
    /* 栈的作用：保存函数调用的返回地址、局部变量、寄存器值 */

    /* 步骤5：跳转到C语言入口函数（核心！完成汇编到C的切换） */
    bl  board_init_f   /* 调用C语言函数board_init_f（第一阶段C初始化） */

/* 3. 异常处理：死循环 */
hang:
    b   hang  /* 异常发生时进入死循环，防止程序跑飞 */

/* 汇编函数：时钟初始化（简化版，仅占位） */
clock_init:
    /* 实际项目中会配置PLL1/2/3，设置CPU/AXI/外设时钟 */
    mov pc, lr  /* 函数返回 */

/* 汇编函数：DDR初始化（简化版，仅占位） */
ddr_init:
    /* 实际项目中会配置DDR的时序、地址映射、刷新参数等 */
    mov pc, lr  /* 函数返回 */
```

阶段二：

```c
/*
 * 嵌入式Bootloader第二阶段：C语言代码（U-Boot的board_init_r函数）
 * 核心：功能扩展，为加载内核做最终准备
 */
#include <common.h>
#include <serial.h>
#include <mmc.h>
#include <fat.h>

/* 全局变量：内核加载地址（IMX6ULL常用地址） */
#define KERNEL_LOAD_ADDR  0x80080000  // 内核镜像加载到DDR的此地址
#define DTB_LOAD_ADDR     0x83000000  // 设备树加载到DDR的此地址

/*
 * Bootloader第二阶段核心函数：board_init_r
 * 汇编代码跳转到此处，开始C语言逻辑
 */
void board_init_r(gd_t *gd, ulong dest_addr)
{
    /* 步骤1：初始化外设（比汇编阶段更全面） */
    serial_init();  // 初始化串口（支持printf打印信息）
    mmc_init(NULL); // 初始化EMMC/SD卡（读取存储介质中的内核）
    lcd_init();     // 初始化LCD（可选，显示启动界面）

    /* 步骤2：初始化控制台（提供命令行交互，如U-Boot的命令行） */
    console_init_r();
    printf("U-Boot second stage init done!\n");  // 串口打印初始化完成

    /* 步骤3：从EMMC/SD卡读取Linux内核镜像到DDR */
    printf("Loading Linux kernel from EMMC...\n");
    if (fat_read_file("uImage", (void *)KERNEL_LOAD_ADDR) != 0) {
        printf("Error: Load kernel failed!\n");
        hang();  // 加载失败则死循环
    }

    /* 步骤4：从EMMC/SD卡读取设备树（DTB）到DDR */
    printf("Loading DTB from EMMC...\n");
    if (fat_read_file("imx6ull.dtb", (void *)DTB_LOAD_ADDR) != 0) {
        printf("Error: Load DTB failed!\n");
        hang();
    }

    /* 步骤5：设置内核启动参数（告诉内核根文件系统位置等） */
    set_bootargs("root=/dev/mmcblk1p2 rootfstype=ext4 rw console=ttymxc0,115200");

    /* 步骤6：启动内核（将控制权传递给内核） */
    printf("Booting Linux kernel...\n");
    do_bootm_linux(KERNEL_LOAD_ADDR, gd, DTB_LOAD_ADDR);
}

/* 死循环函数：出错时调用 */
void hang(void)
{
    while (1);
}
```

