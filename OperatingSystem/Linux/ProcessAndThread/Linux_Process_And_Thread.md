# Linux_Process_And_Thread

---- Chime Lee

## 一、概述

Linux下进程与线程的相关概念与日常问题

## 二、内容

### 2.1 什么是进程？什么是线程？有什么区别？

**进程（Process）：**

* 是系统**资源分配的最小单位**。
* 进程是线程的容器。程序是指令、数据及其组织形式的描述，**进程是程序的实体**。

**线程（Thread）：**

* 操作系统**最小的调度单位**。
* 线程包含在进程中，是进程中实际执行任务的单位。

**进程和线程的区别：**

* 所属关系：
  * 线程是进程的一部分，是进程中执行任务的单位。
  * 而进程是操作系统资源分配的基本单位。
* 系统资源：
  * 每个进程都有独立的**地址空间**和**系统资源**。
  * 线程**共享同一进程**的地址空间和资源资源。
* 切换速度：线程之间的切换速度 > 进程之间的切换速度，因为**线程共享相同的上下文和资源**。
* 通信方式：
  * 线程因天然共享同一进程的地址空间，可之间**读写全局变量、堆内存等共享区域**。通信更加方便。
  * 进程拥有独立的地址空间，即便可以使用共享内存，也许通过**内核创建、挂载内存段并处理跨进程同步**，其余通讯协议间通信协议（管道、消息队列、信号量、套接字）则需要而外**内核态数据拷贝**或**协议封装**。
* 开销：进程创建和销毁比线程的开销更大。
* 独立性：
  * 进程是**相对独立**的，一个进程的崩溃不会影响其他进程。
  * 线程是**相互依赖**的，一个线程的崩溃会导致整个进程的崩溃。

### 2.2 什么时候用进程，什么时候用线程？

**使用进程的情况：**

* **需要独立的地址和系统资源**：任务需要运行在独立的空间中，不同任务之间的**数据隔离**较为重要，那么可以选择使用进程。
* **需要更高的安全性和稳定性**：如果一个任务崩溃不影响其他任务的正常运行，选择进程保证安全性和稳定。
* **并行计算需求**：如果任务需要充分利用**多核处理器的计算能力**，可以通过多个独立的进程并行执行提高计算效率。

**使用线程的情况：**

* **共享数据和资源**：若任务之间需要**共享数据和资源**，并且**数据同步和通讯**较为频繁，使用线程可以更方便地访问和操作共享资源。
* **轻量级任务：**如果任务比较轻量级，且**并行**执行可以提高效率，使用线程可以进行更快速地**切换和调度**，减少开销。
* **实时性要求：**如果任务实时性要求比较高，使用线程可以**更快响应事件和处理任务**。

### 2.3 一个线程占多大内存

一个线程在Linux系统中大约占用8 MB的内存。

原因：Linux系统中的线程都是通过**缺页异常**来进行内存分配的，**不是所有的栈空间都会被实际分配内存**。因此，8 MB是一个上限，**实际的内存消耗会超过实际需要的内存**。这个差额主要是由**内部损耗**（每个线程内部一些开销）所引起的，通常在4 KB范围内。

### 2.4 什么是信号量，有什么作用？

* 信号量：一种同步机制，它本质上是一个计数器。
* 作用：保护共享资源，控制访问共享资源的进行或线程数量。
* 原理：基于P和V两种操作：
  * P：操作会将信号量的值-1。若信号量的值小于0，进程或线程会被挂起，直到其他进程或线程执行V操作释放信号量。
  * V：操作会将信号量的值+1。若有进程或线程因等待信号量被挂起，它们中的一个会被唤醒继续执行。
* 信号量的值：
  * 大于0：进程或线程可以继续访问 共享资源。
  * 等于0：进程或线程会被挂起，直到其他进程或线程执行V操作释放信号量。

```cpp
#include <iostream>
#include <semaphore>
#include <thread>

std::counting_semaphore<1> semaphore; // 创建一个信号量，初始值为 1
int counter = 0; // 共享资源

void IncrementCounter() {
    semaphore.acquire(); // P(sv) 操作

    // 访问共享资源
    counter++;
    std::cout << "Counter: " << counter << std::endl;

    semaphore.release(); // V(sv) 操作
}

int main() {
    constexpr int NumThreads = 3;
    std::vector<std::thread> threads;

    // 创建多个线程并启动
    for (int i = 0; i < NumThreads; i++) {
        threads.push_back(std::thread(IncrementCounter));
    }

    // 等待所有线程完成
    for (auto& thread : threads) {
        thread.join();
    }

    return 0;
}
```

### 2.5 多进程共享内存可能存在什么问题？如何解决？

**多进程共享内存可能存在以下问题：**

* 竞争条件（*Race Condition*）：当多个进程同时访问修改共享内存时，由于**执行顺序的不确定性**，导致**数据不一致**或**不正确**的结果。
* 数据同步问题：不同进程可能以**不同速度访问共享内存**，导致**数据在读取和更新之间**的差异，导致**数据不一致**的情况。
* 死锁：多个进程在访问共享内存时发生**互相等待**的情况，可能发生死锁，导致进程无法执行。

**解决措施：**

* 使用互斥锁（*Mutex*）：在访问前获取互斥锁，在访问后释放，保证同一时间只有一个进程访问共享内存。避免**竞争条件**。
* 使用信号量（*Semaphore*）：使用信号量来同步进程的访问，可以控制同时访问共享内存的数量，从而避免数据同步、和死锁。
* 使用条件变量（*Condition value*）：在满足特点条件下唤醒等待的进程，从而避免等待和资源消耗。
* 使用进程加通讯机制（*IPC*）：管道、消息队列、信号量、套接字等。

### 2.6 多进程、多线程的优缺点

**多进程的优点：**

* 独立地址空间和系统资源：进程有独立的地址空间和系统资源，可以有效的**隔离和保护数据**
* 安全性和稳定性：进程间**相对独立**，一个进程的崩溃不会影响其他进程的正常执行。
* 可扩展性：可以更容易在多个机器上部署，实现分布式计算，提高系统的处理能力和吞吐量。

**多进程的缺点：**

* 开销：**创建和管理**进程开销较大，包括**内存和资源**的分配，**上下文切换**等。
* 通讯复杂：进程间通信需要使用特定的*IPC*机制，编写和维护较为复杂。

**多线程的优点：**

* 资源共享：若多个任务之间需要访问共享资源，且数据的同步和通信较为频繁，选择多线程可以更方便的访问共享数据。
* 轻量化：若任务是轻量化的，且并发可以提高效率，选择多线程更方便的切换和调度。
* 实时性：若任务实时性强，选择多线程更快响应任务或处理事件。

**多线程的缺点：**

* 安全性问题：多线程共享数据是需要考虑**同步和锁机制**，避免**数据竞争**导致不一致的结果。
* 内存占用：每个线程都需**独立的栈空间**和**线程数据结构**，增加**内存消耗**。
* 上下文切换开销：线程切换需要**保持和恢复上下文**，增加**系统开销**。

### 2.7 多进程、多线程同步（通信）方式

**多进程：**

* 管道
* 共享内存
* 信号量
* 互斥锁

**多线程：**

* 互斥锁
* 信号量
* 读写锁

### 2.8 什么是线程同步和互斥

**线程同步：**通过一定的机制，确保多个线程按照一定顺序或规则访问共享资源，避免出现并发导致的竞争条件，数据同步等问题。

**线程互斥**：保护共享资源的机制，确保同一时间只有一个线程可以访问该资源，避免出现竞争条件和数据同步等问题。通过使用互斥锁，只有获取到锁才能进入临界区，其他线程需要等待锁释放。

