# 328_奇偶链表

---- Lee

## 一、题目

给定单链表的头节点 `head` ，将所有索引为奇数的节点和索引为偶数的节点分别分组，保持它们原有的相对顺序，然后把偶数索引节点分组连接到奇数索引节点分组之后，返回重新排序的链表。

**第一个**节点的索引被认为是 **奇数** ， **第二个**节点的索引为 **偶数** ，以此类推。

请注意，偶数组和奇数组内部的相对顺序应该与输入时保持一致。

你必须在 `O(1)` 的额外空间复杂度和 `O(n)` 的时间复杂度下解决这个问题。

 

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/03/10/oddeven-linked-list.jpg)

```
输入: head = [1,2,3,4,5]
输出: [1,3,5,2,4]
```

**示例 2:**

![img](https://assets.leetcode.com/uploads/2021/03/10/oddeven2-linked-list.jpg)

```
输入: head = [2,1,3,5,6,4,7]
输出: [2,3,6,7,1,5,4]
```

**提示:**

- `n == ` 链表中的节点数
- `0 <= n <= 104`
- `-106 <= Node.val <= 106`

[力扣题目](https://leetcode.cn/problems/odd-even-linked-list/description/)

## 二、思路

本质使用`pre` `cur` `cur_nextNode`思路，将`cur`插入值`cur_nextNode`之后，不同的是，本次操作是`pre`和`cur`是要动态变化的。

相关参考：

[92_反转链表2.md](./92_反转链表2.md)

[25_K个一组反转链表.md](./25_K个一组反转链表.md)

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* oddEvenList(struct ListNode* head) {
    // 入参校验
    if (NULL == head)
    {
        return NULL;
    }

    typedef struct ListNode ListNode;

    // 创建pre,cur,cur_nextNode
    ListNode* pre = head;
    ListNode* cur = head->next;
    ListNode* cur_nextNode = NULL;

    while (NULL != cur && NULL != cur->next)
    {
        cur_nextNode = cur->next;
        cur->next = cur_nextNode->next;
        cur_nextNode->next = pre->next;
        pre->next = cur_nextNode;

        pre = pre->next;
        cur = cur->next;
    }
    return head;
}
```

