# 23_合并K个升序链表

---- Lee

## 一、题目

给你一个链表数组，每个链表都已经按升序排列。

请你将所有链表合并到一个升序链表中，返回合并后的链表。

**示例 1：**

```
输入：lists = [[1,4,5],[1,3,4],[2,6]]
输出：[1,1,2,3,4,4,5,6]
解释：链表数组如下：
[
  1->4->5,
  1->3->4,
  2->6
]
将它们合并到一个有序链表中得到。
1->1->2->3->4->4->5->6
```

**示例 2：**

```
输入：lists = []
输出：[]
```

**示例 3：**

```
输入：lists = [[]]
输出：[]
```

**提示：**

- `k == lists.length`
- `0 <= k <= 10^4`
- `0 <= lists[i].length <= 500`
- `-10^4 <= lists[i][j] <= 10^4`
- `lists[i]` 按 **升序** 排列
- `lists[i].length` 的总和不超过 `10^4`

[力扣题目链接](https://leetcode.cn/problems/merge-k-sorted-lists/description/)

## 二、思路

* 对于所谓的大型处理，将其具象化为小型内容：K个有序链表合并，先试试合并2个有序链表，之后引申多次，不就是K个链表合并(☞ﾟヮﾟ)☞

* 大型问题小型化：合并2个有序链表：

  * **入参校验**：入参为空直接返回`nullptr`。

  ```cpp
      if (0 == lists.size()){
          return nullptr;
      }
  ```

  * **确认合并链表和插入链表，并给合并链表添加虚拟头节点**。所谓的合并，就是将一个链表中的元素插入到另一个链表之中，在插入的过程中我们要保证当前的节点是被插入节点元素之前，故推荐使用虚拟头节点。

  ```cpp
      ListNode* fakeHead = new ListNode();
      if (nullptr == fakeHead)
      {
          return nullptr;
      }
      fakeHead->next = lists[0];		// 取第1个元素作为合并链表
  
      // 合并链表
      ListNode* cur = nullptr;
      // 插入链表
      ListNode* insert = nullptr;
  ```

  * **依次遍历每个链表插入到合并链表中**：注意第1个元素已经做了合并链表，循环变量从`1`开始，循环中要实现**两个有序链表合并的逻辑即可**。每次进入循环重置合并链表为其头节点，插入链表为新的链表节点。

  ```cpp
  for (int i = 1; i < lists.size(); ++i){
      cur = fakeHead;
      intsert = lists[i];
      // ... ...
  }
  ```

  * **合并/插入的本质是要比较插入节点元素与合并链表下一个节点的元素**：循环条件为：`nullptr != cur->next`

  ```cpp
  while (nullptr != cur->next){
      
  }
  ```

  * **插入分为四种情况**：

    * **1.插入节点为空**：跳出合并链表遍历循环，合并结束。
    * **2.插入节点元素 <= 合并链表下一个节点元素**：插入节点元素在合并链表当前节点之后。两个遍历向后同时向后走一步。
    * **3.插入节点元素 > 合并链表下一个节点的元素**：合并链表向后走一步。

    * **4.插入节点元素 > 合并链表最后一个元素**：将剩余插入链表的节点，插入到合并链表最后一个元素之后。

  ```cpp
  while (nullptr != cur->next){
  	// 1.
      if (nullptr == insert){
     		break;
  	}
  	
      // 2.
  	if (insert->val <= cur->next->val){
      	// 保存插入节点，插入链表向后走一步
      	ListNode* tempInsert = insert;
      	insert = insert->next;
      
      	// 将插入节点插入值合并链表当前节点之后
      	tempInsert->next = cur->next;
      	cur->next = tempInsert;
      
      	// 合并链表向后走一步
      	cur = cur->next;
  	}
      // 3.
  	else{
      	cur = cur->next;
  	}
  }
  
  // 4.插入链表还有剩余元素：既其剩余元素均大于合并链表最后一个元素
  if (nullptr != insert){
      cur->next = insert;
  }
  ```

  * 遍历结束（合并结束）：释放虚拟头节点，返回合并链表头节点

  ```cpp
  ListNode* result = fakeHead->next;
  delete fakeHead;
  return result;
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for singly-linked list.
   * struct ListNode {
   *     int val;
   *     ListNode *next;
   *     ListNode() : val(0), next(nullptr) {}
   *     ListNode(int x) : val(x), next(nullptr) {}
   *     ListNode(int x, ListNode *next) : val(x), next(next) {}
   * };
   */
  class Solution {
  public:
      ListNode* mergeKLists(vector<ListNode*>& lists) {
          if (0 == lists.size()){
              return nullptr;
          }
          
          ListNode* fakeHead = new ListNode();
          if (nullptr == fakeHead)
          {
              return nullptr;
          }
          fakeHead->next = lists[0];
  
          // 合并链表
          ListNode* cur = nullptr;
          // 插入链表
          ListNode* insert = nullptr;
          for (int i = 1; i < lists.size(); ++i){
              cur = fakeHead;
              insert = lists[i];
              
              while (nullptr != cur->next){
                  // 若插入链表为空，跳出循环
                  if (nullptr == insert){
                      break;
                  }
                  // 若插入元素 <= 当前元素的下一个元素，插入当前节点之后
                  if (insert->val <= cur->next->val){
                      // 记录临时节点
                      ListNode* tempInsert = insert;
                      // 插入链表向后走一步
                      insert = insert->next;
                      // 插入元素
                      tempInsert->next = cur->next;
                      cur->next = tempInsert;
  
                      // 向后走一步
                      cur = cur->next;
                  }
                  else{
                      // 当前插入节点元素值 > 合并节点的下一个节点的值。
                      cur = cur->next;
                  }
              }
  
              // 插入链表可能并没有遍历完成,将其剩余的所有元素加入之合并链表之后
              if (nullptr != insert){
                  cur->next = insert;
              }
          }
          ListNode* result = fakeHead->next;
          delete fakeHead;
          return result;
      }
  };
  ```

  ## 四、源码

  [mergeKLists.cpp](./SourceCode/mergeKLists.cpp)