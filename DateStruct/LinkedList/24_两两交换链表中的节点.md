# 24_两两交换链表中的节点

---- Lee

## 一、题目

给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。

你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/swap-nodes-in-pairs/)

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

**示例 2：**

```
输入：head = []
输出：[]
```

**示例 3：**

```
输入：head = [1]
输出：[1]
```

**提示：**

- 链表中节点的数目在范围 `[0, 100]` 内
- `0 <= Node.val <= 100`

## 二、思路

* 添加虚拟节点
* 明确置换顺序：
  * cur->1->2->3->....->N
  * cur->2->1->... ....
* 将上述内容分解后：
  * cur->2
  * 2->1
  * 1->3

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* swapPairs(struct ListNode* head) {
    if (NULL == head)
    {
        return NULL;
    }

    // 设置虚拟头节点
    struct ListNode* fakeHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    if (NULL == fakeHead)
    {
        return head;
    }

    fakeHead->next = head;
    
    // 获取当前节点
    struct ListNode* cur = fakeHead;

    // 开始交换,需要操作的变量cur->next; cur->next->next
    while((NULL != cur->next) && (NULL != cur->next->next))
    {
        // 存储临时变量
        struct ListNode* temp1 = cur->next;
        struct ListNode* temp2 = cur->next->next->next;

        // 虚拟节点指向第1节点
        cur->next = cur->next->next;

        // 第1节点指向第0节点
        cur->next->next = temp1;

        // 第0节点指向第3节点
        cur->next->next->next = temp2;

        // 位移两位
        cur = cur->next->next;
    }
    struct ListNode* result = fakeHead->next;
    free(fakeHead);
    return result;
}
```

