# 203.移除链表元素

---- Lee

## 一、题目

题意：删除链表中等于给定值 val 的所有节点。

示例 1： 输入：head = [1,2,6,3,4,5,6], val = 6 输出：[1,2,3,4,5]

示例 2： 输入：head = [], val = 1 输出：[]

示例 3： 输入：head = [7,7,7,7], val = 7 输出：[]

[力扣题目链接(opens new window)](https://leetcode.cn/problems/remove-linked-list-elements/)

## 二、思路

* 在算法题目中不允许出现赋值位nullptr的情况，故最好不要用`prev`此类头节点思想
* 注意对于头结点符合要求时的情况。
  * 直接编写单独处理链表头的情况。
  * 使用虚拟节点设置在链表头之前，方便后续操作。

## 三、代码

### 3.1 单独处理链表头与其后内容

```c
struct ListNode
{
    int val;
    struct ListNode* next;
};

/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeElements(struct ListNode* head, int val) 
{
    // 入参校验
    if (NULL == head)
    {
        return NULL;
    }

    // 单独处理头节点
    struct ListNode* temp = NULL;
    struct ListNode* cur = head;
    while(NULL != cur && val == cur->val)
    {
        temp = cur;
        cur = cur->next;
        free(temp);
    }

    // 记录处理好的头节点
    head = cur;
	
    // 不能在此处给temp赋值的原因：无法保证当前的cur是否为空，若cur此时已经为空，再去访问会出现内存问题！！！
    
    // 处理之后的节点,使用临时节点作为当前节点之后的内容。
    while(NULL != cur && (temp = cur->next))
    {
        if (val == temp->val)
        {
            cur->next = temp->next;
            free(temp);
        }
        else
        {
            cur = cur->next;
        }
    }
    return head;
}
```

### 3.2 添加虚拟链表头进行处理

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeElements(struct ListNode* head, int val) {

    // 入参校验
    if (NULL == head)
    {
        return NULL;
    }

    typedef struct ListNode ListNode;

    // 设置虚拟头节点
    ListNode* shead = (ListNode*)malloc(sizeof(ListNode));
    if (NULL == shead)
    {
        return head;
    }   
    shead->next = head;
    
    // 设置中间变量
    ListNode* cur = shead;
    while (NULL != cur->next)
    {
        if (val == cur->next->val)
        {
            ListNode* temp = cur->next;
            cur->next = cur->next->next;
            free(temp);
        }
        else
        {
            cur = cur->next;
        }
    }
    head = shead->next;
    free(shead);
    return head;
}
```

