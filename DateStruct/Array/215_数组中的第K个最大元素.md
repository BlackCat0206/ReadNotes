# 215_数组中的第K个最大元素

---- Lee

## 一、题目

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

[力扣题目链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 二、思路

* 二分法+快排
* 这里的二分法实际上是是一种“**分治**”的思想 。本题的最终目的，是找出第K个大元素。那么，将数组进行排序（从大到小），取第`K-1`下标的元素，即可完成要求。
* 分治：上述说的“**分治**”思想，其体现在快排中。
  * 快排的逻辑找一个基准，排序后返回这个基准的坐标，其左边元素比它小，右边元素比它大，这个顺序是可以修改的。
  * 我们就可以根据这个返回的下标来做点文章：分为三种情况
    * 返回下标 + 1 == K：下标所指元素就是第K大/小的元素，下标左侧元素一定比它大/小。
    * 返回下标 + 1 < K: 那就说明第K大的元素还在右边，继续排序右边，不用管左边。
    * 返回下标 + 1 > K：说明第K大的元素在左边，继续排序左边，不用考虑右边。
  * 这样我们就可以根据返回下标与K的大小关系，只考虑一边的排序。减少时间复杂度。

## 三、代码

```cpp
class Solution {
public:

void SortSwap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

int quickselect(vector<int>& arr, int left, int right)
{
    int base = left;
    // printf("BaseValue arr[%d] = %d\n", left, arr[left]);
    int l = left - 1;
    int r = right + 1;
    while(l < r)
    {
        do{
            ++l;
        }while(arr[base] < arr[l]);

        do{
            --r;
        }while(arr[base] > arr[r]);

        if (l < r){
            // printf("Swapping arr[%d]=%d and arr[%d]=%d\n", l, arr[l], r, arr[r]);
            SortSwap(&arr[l], &arr[r]);
        }
    }
    // printf("arr[%d]=%d\n", r, arr[r]);
    // printf("arr[%d]=%d\n", l, arr[l]);
    SortSwap(&arr[base], &arr[r]);
    return r;
}

    int QuickSort(vector<int>& nums, int left, int right, int k)
    {
        int index = quickselect(nums, left, right);

        if (k == index + 1)
        {
            return nums[index];
        }
        else if (k > index + 1)
        {
            return QuickSort(nums, index + 1, right, k);
        }
        else
        {
            return QuickSort(nums, left, index - 1, k);
        }
    }

    int findKthLargest(vector<int>& nums, int k) {
        if (0 == nums.size() || k > nums.size() || 0 >= k){
            return -1;
        }
        int n = nums.size();
        return QuickSort(nums, 0, nums.size() - 1, k);
    }
};
```

## 小结：

# 快排基准值与返回下标的核心小结

1. **基准值的作用**

   - 选一个元素当「标尺」，把数组分成「≤标尺」和「≥标尺」两部分，它是分区的核心依据。
   - 不管循环内被交换到哪，最终都会被放到分区的分界位置。

2. **返回下标的双重身份**

   - 它是**区域分界点**：左边全≤基准值，右边全≥基准值，后续递归只需要处理分界点两侧的子数组。
   - 它是**基准值的最终位置**（但不一定是当前基准值所在位置）：循环结束后会执行一次交换，把基准值精准移到这个下标处，这个位置就是基准值在当前子数组的有序位置。

3. **一句话总结**

   快排分区返回的下标，既是划分左右区间的「分界线」，也是基准值在当前子数组里的「最终家」。