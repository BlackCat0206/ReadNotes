# 59.螺旋矩阵II

---- Lee

## 一、题目

给定一个正整数 n，生成一个包含 1 到 n^2 所有元素，且元素按顺时针顺序螺旋排列的正方形矩阵。

示例:

输入: 3 输出: [ [ 1, 2, 3 ], [ 8, 9, 4 ], [ 7, 6, 5 ] ]

[力扣题目链接(opens new window)](https://leetcode.cn/problems/spiral-matrix-ii/)

## 二、思路

* 过程不设计算法，趋向于过程模拟。

* 模拟顺时针画矩阵的过程:

  - 填充上行从左到右
  - 填充右列从上到下
  - 填充下行从右到左
  - 填充左列从下到上

  由外向内一圈一圈这么画下去。

  可以发现这里的边界条件非常多，在一个循环中，如此多的边界条件，如果不按照固定规则来遍历，那就是**一进循环深似海，从此offer是路人**。

  这里一圈下来，我们要画每四条边，这四条边怎么画，每画一条边都要坚持一致的左闭右开，或者左开右闭的原则，这样这一圈才能按照统一的规则画下来。

  那么我按照左闭右开的原则，来画一圈，大家看一下：

  ![img](https://file1.kamacoder.com/i/algo/20220922102236.png)

  这里每一种颜色，代表一条边，我们遍历的长度，可以看出每一个拐角处的处理规则，拐角处让给新的一条边来继续画。

  这也是坚持了每条边左闭右开的原则。

* 明确如下条件：

  * 循环几圈：（n / 2）
  * 起点如何确认：`startX`、`startY`从0开始，进行下一圈自动递增。
  * 左闭右开区如何实现：(n - offset)，进入下一圈自动递增。
  * C中如何申请返回的矩阵数组：

  ```c
      // 申请内存
  	// 二维数组是一个指针，其指向一个固定元素的数组。 
      int** ans = (int**)malloc(sizeof(int*) * n);
      if (NULL == ans)
      {
          free(returnColumnSizes);
          return NULL;
      }
  
      int i = 0;
      for (i = 0; i < n; i++)
      {
          ans[i] = (int*)malloc(sizeof(int) * n);
          (*returnColumnSizes)[i] = n;
      }
  ```

## 三、代码

```c
/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** generateMatrix(int n, int* returnSize, int** returnColumnSizes) {
    // 填充返回的行数
    *returnSize = n;
    
    // 填充每一行有多少列
    *returnColumnSizes = (int*)malloc(sizeof(int) * n);
    if (NULL == returnColumnSizes)
    {
        return NULL;
    }

    // 申请内存
    int** ans = (int**)malloc(sizeof(int*) * n);
    if (NULL == ans)
    {
        free(returnColumnSizes);
        return NULL;
    }	

    int i = 0;
    for (i = 0; i < n; i++)
    {
        ans[i] = (int*)malloc(sizeof(int) * n);
        (*returnColumnSizes)[i] = n;
    }

    // 设置起点
    int startX = 0;
    int startY = 0;

    // 设置操作边界
    int offset = 1;

    // 设置循环次数
    int loop = n / 2;

    // 确认中间点坐标 (如果是奇数的话会用到)
    int mid = n / 2;

    // 声明填充元素
    int count = 1;

    i = 0;
    int j = 0;
    while(0 < loop--)
    {
        i = startX;
        j = startY;

        // 从左向右填充
        for (j; j < n - offset; j++)
        {
            ans[i][j] = count++;
        }

        // 从右侧上到下
        for (i; i < n - offset; i++)
        {
            ans[i][j] = count++;
        }

        // 下侧：从右向左
        for(; startY < j; j--)
        {
            ans[i][j] = count++;
        }

        // 左侧：从下向上
        for(; startX < i; i--)
        {
            ans[i][j] = count++;
        }

        // 起点偏移
        startX++;
        startY++;

        // 边界偏移
        offset++;
    }


    if (0 != n % 2)
    {
        ans[mid][mid] = count;
    }

    return ans;
}
```

