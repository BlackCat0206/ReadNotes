# 00X_数组中的逆序对

---- Lee

## 一、题目

### 描述

在数组中的两个数字，**如果前面一个数字大于后面的数字，则这两个数字组成一个逆序对**。输入一个数组,求出这个数组中的逆序对的总数P。并将P对1000000007取模的结果输出。 即输出P mod 1000000007
数据范围： 对于 50%50% 的数据, size≤104*s**i**z**e*≤104
对于 100%100% 的数据, size≤105*s**i**z**e*≤105

数组中所有数字的值满足 0≤val≤1090≤*v**a**l*≤109

要求：空间复杂度 O(n)，时间复杂度 O(nlogn)

### 输入描述：

题目保证输入的数组中没有的相同的数字

### 示例1

输入：

```
[1,2,3,4,5,6,7,0]
```

返回值：

```
7
```

### 示例2

输入：

```
[1,2,3]
```

返回值：

```
0
```

## 二、思路

* 寻找逆序对，既找到数组中一个元素之前有多少个元素是大于它的。
* 可以使用归并排序，将数组拆分为最小单元，之后重新整合排序，在排序的过程中，若出现**左侧有序数组中元素** > **右侧数组中的元素**。那么[begin1 + n, end1]均可以当前右侧元素组成逆序对，累计即可。
* 重复上述操作，直至排序完成。

* 并归排序：[并归排序](../Sort/05_Merge_Sort.md)

## 三、代码

```c

    static int count = 0;
    void _MergeSort(int arr[], int left, int right, int* tmp)
    {
        // 划分至最小单元（单个元素）返回
        if (left == right)
        {
            return;
        }

        int mid = left + (right - left) / 2;
        // 并归排序左半部分
        _MergeSort(arr, left, mid, tmp);
        // 并归排序右半部分
        _MergeSort(arr, mid + 1, right, tmp);

        // 准备合并
        int begin1 = left, end1 = mid;
        int begin2 = mid + 1, end2 = right;

        int index = begin1;

        // 当两侧数组均为越界时
        while(begin1 <= end1 && begin2 <= end2)
        {
            if (arr[begin1] > arr[begin2])
            {
                count += end1 - begin1 + 1;
                count %= 1000000007;
                tmp[index++] = arr[begin2++];
            }
            else
            {
                tmp[index++] = arr[begin1++];
            }
        }

        // 未遍历的子数组放入到数组中
        while (begin1 <= end1)
        {
            tmp[index++] = arr[begin1++];
        }

        while (begin2 <= end2)
        {
            tmp[index++] = arr[begin2++];
        }

        // 将排序结果添加会数组中
        int i = left;
        for (i = left, i <= right; ++i)
        {
            arr[i] = tmp[i];
        }
        return;
    }

    void Merge_Sort(int arr[], int size)
    {
        if (NULL == arr || 0 >= size)
        {
            return;
        }

        int* tmp = (int*)malloc(sizeof(int) * size);
        if (NULL == tmp)
        {
            return;
        }

        _MergeSort(arr, 0, size-1, tmp);

        // 释放临时内存
        free(tmp);
        tmp = NULL;
        return;
    }

```



