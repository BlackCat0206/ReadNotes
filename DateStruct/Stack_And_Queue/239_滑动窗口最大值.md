# 239_滑动窗口最大值

---- Lee

## 一、题目

给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。

返回滑动窗口中的最大值。

进阶：

你能在线性时间复杂度内解决此题吗？

![img](https://file1.kamacoder.com/i/algo/239.%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%9C%80%E5%A4%A7%E5%80%BC.png)

提示：

- 1 <= nums.length <= 10^5
- -10^4 <= nums[i] <= 10^4
- 1 <= k <= nums.length

[力扣题目链接(opens new window)](https://leetcode.cn/problems/sliding-window-maximum/)

## 二、思路

**其实队列没有必要维护窗口里的所有元素，只需要维护有可能成为窗口里最大值的元素就可以了，同时保证队列里的元素数值是由大到小的**

* 队列中维护的数据是从大到小的。
* `push`：若传入的数据大于队列尾部的数据，开始轮询，直到队列中没比它更小的元素。
* `pop`：在`pop`时要传入出窗口的元素，若传入的元素与队列元素不相同，队列不`pop`。（既出窗口的元素，不是其所在窗口的最大值）
* `front`：返回队列的首个元素。

## 三、代码

```cpp
class Solution {
private:
    class MyQueue{
    public:
        deque<int> que;

        void pop(int val)
        {
            // 每次pop时先判断要pop值是否和队列头的元素相同，若不相同，不仅限任何操作。
            if (!que.empty() && val == que.front())
            {
                que.pop_front();
            }
        }

        void push(int val)
        {
            // 每次填充时，判断当前值是否大于队列尾部，若大于当小于的元素全部pop掉，保证队列的单调递减的。
            while(!que.empty() && val > que.back())
            {
                que.pop_back();
            }
            que.push_back(val);
        }

        int front()
        {
            return que.front();
        }
    };
public:
    vector<int> maxSlidingWindow(vector<int>& nums, int k) 
    {
        if (0 == nums.size() || 0 == k || num.size() < size)
        {
            return nums;
        }    

        // 创建结果遍历
        vector<int> result;

        // 创建单调队列
        MyQueue que;

        // 先将第一个大小为k的滑动窗口元素添加到单调队列中
        for (int i = 0; i < k; i++)
        {
            que.push(nums[i]);
        }

        // 先记录前k个数值的最大值
        result.push_back(que.front());
        for (int i = k; i < nums.size(); i++)
        {
            que.pop(nums[i - k]);
            que.push(nums[i]);
            result.push_back(que.front());
        }

        return result;
    }
};
```

