# 701.二叉搜索树中的插入操作

---- Lee

## 一、题目

给定二叉搜索树（`BST`）的根节点和要插入树中的值，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据保证，新值和原始二叉搜索树中的任意节点值都不同。

注意，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回任意有效的结果。

![701.二叉搜索树中的插入操作](https://file1.kamacoder.com/i/algo/20201019173259554.png)

提示：

- 给定的树上的节点数介于 0 和 10^4 之间
- 每个节点都有一个唯一整数值，取值范围从 0 到 10^8
- -10^8 <= val <= 10^8
- 新值和原始二叉搜索树中的任意节点值都不同

[力扣题目链接(opens new window)](https://leetcode.cn/problems/insert-into-a-binary-search-tree/)

## 二、思路

* 看似需要重构，实则不需要，只需要根据要添加的元素，引导遍历方向，在空节点添加需要的元素即可。

* 递归三要素：

  * 确认函数返回值类型和参数类型：
    * 函数返回值类型：节点指针类型
    * 参数类型：当前节点指针，和要插入的节点元素。

  ```cpp
  TreeNode* insertToBST(TreeNode* cur, int val)
  ```

  * 终止条件：遇到空节点，添加新元素节点返回。

  ```cpp
  if (nullptr == cur){
      return new TreeNode(val);
  }
  ```

  * 单次递归执行的内容：
    * 若当前节点元素 > 要添加的元素，则递归进行当前节点的左子树。
    * 若当前节点元素 < 要添加的元素，则递归进入当前节点的右子树。

  ```cpp
  if (cur->val > val){
      cur->left = insertBST(cur->left, val);
  }
  else if (cur->val < val){
      cur->right = insertBST(cur->right, val);
  }
  return cur;
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(TreeNode* cur, int val){
        if (nullptr == cur){
            return new TreeNode(val);
        }

        if (cur->val > val){
            cur->left = traversal(cur->left, val);
        }
        else if (cur->val < val){
            cur->right = traversal(cur->right, val);
        }
        return cur;
    }

    TreeNode* insertIntoBST(TreeNode* root, int val) {
        return traversal(root, val);
    }
};
```

