# 112_路径总和

---- Lee

## 一、题目

给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和。

说明: 叶子节点是指没有子节点的节点。

示例: 给定如下二叉树，以及目标和 sum = 22，

![img](https://file1.kamacoder.com/i/algo/20230407210247.png)

返回 true, 因为存在目标和为 22 的根节点到叶子节点的路径 5->4->11->2。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/path-sum/)

## 二、题目

* 只判断是否存在路径，不需要记录路径。
* 每经过一个节点，若当前节点不是子节点，则将target减去当前节点的继续迭代。若是，判断剩余的数量与当前叶子节点是否相等。

* 递归三要素：
* 确认返回值和函数参数：
  * 返回值类型：返回一个节点左右子树是否路径，故返回值类型为`bool`类型。
  * 参数类型和个数：当前节点，目标值的剩余数。

```cpp
bool findPath(TreeNode* cur, int target)
```

* 确认终止条件：
  * 当遇到叶子节点，且当前节点的数值与剩余的`traget`相等，则返回`true`，否则返回`false`。

```cpp
if (NULL == cur->left && NULL == cur->right){
    if (target == cur->value){
        return true;
    }
}
```

* 确认单次递归的逻辑：
  * 获取左右节点中是否右符合的路径？将二者结果整合返回。

```cpp
bool leftFind = false;
if (NULL != cur->left){
    leftFind = tarversal(cur->left, target - cur->val);
}

bool rightFind = false;
if (NULL != cur->right){
    rightFind = traversal(cur>right, target - cur->val);
}

return leftFind || rightFind;
```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    bool traversal(TreeNode* cur, int target){
        if (NULL == cur){
            return false;
        }   

        // 到达叶子节点
        if (NULL == cur->left && NULL == cur->right){
                return target == cur->val;
        }

        if (NULL != cur->left){
            if(traversal(cur->left, target - cur->val)){
                return true;
            }
        }

        if (NULL != cur->right){
            if (traversal(cur->right, target - cur->val)){
                return true;
            }
        }

        return false;
    }

    bool hasPathSum(TreeNode* root, int targetSum) {
        if (NULL == root){
            return false;
        }

        return traversal(root, targetSum);
    }
};
```

