# 00_二叉树总结

---- Lee

## 一、二叉树理论遍历

- 深度优先遍历
  - [001_二叉树的递归遍历](./001_二叉树的递归遍历.md)
  - 前序遍历
  - 中序遍历
  - 后序遍历
- 广度优先遍历
  * [102_二叉树层序遍历](./102_二叉树层序遍历.md) 通过队列模拟

## 二、求二叉树的属性

* [101_对称二叉树](./101_对称二叉树.md)
  * 递归：后序，比较的是根节点的左子树与右子树是不是相互翻转。
* [559_n叉树的最大深度](./559_n叉树的最大深度.md)
  * 递归：后序，从空节点返回0，每次获取左右子树高度，取最大值+1。
* [111_二叉树的最小深度](./111_二叉树的最小深度.md)
  * 递归：后序，获取左右两颗子树的最小深度，判断当前节点是否有一侧为空，不为空一侧+1返回。1 + 左右子树的最小高度值返回。
* [222_完全二叉树的节点个数](./222_完全二叉树的节点个数.md)
  * 递归：后序，统计左右子树之和，本地+1返回。
* [110_平衡二叉树](./110_平衡二叉树.md)
  * 递归：后序，获得左右子树的高度，做差若绝对值 > 1，返回失败符表示不适平衡二叉树。
* [257_二叉树的所有路径](./257_二叉树的所有路径.md)
  * 递归：前序，逐个在数据中添加当前元素，若当前节点的左右子节点为空，则整合结果路径。若未到叶子节点，遍历当前节点的左右节点，遍历后记得回溯`pop`调用左右子节点。
* [404.左叶子之和](./404.左叶子之和.md)
  * 递归：后序，判断当前节点的左节点是否不为空，且其左右节点为空，若是则直接返回其数值。获取左右子树的最左叶子，求和返回。
* [513_找树左下角的值](./513_找树左下角的值.md)
  * 递归：顺序无所谓，优先遍历左侧孩子，同时找到最大深度的叶子节点。
  * 迭代：层序遍历找最后一个最左边
* [112_路径总和](./112_路径总和.md)
  * 递归：前置，递归过程中递减当前节点元素，并注意回溯。

## 三、二叉树的修改于构造

* [226_翻转二叉树](./226_翻转二叉树.md)
  * 递归：前序，反转左右节点
* [106_从中序与后序遍历序列构造二叉树](106_从中序与后序遍历序列构造二叉树.md)
  * 递归：前置，注意先切割后序，后切割中序。
* [654_最大二叉树](./654_最大二叉树.md)
  * 递归：前置，找出中间点，之后完成切割继续递归即可。
* [617_合并二叉树](./617_合并二叉树.md)
  * 递归：前置，两个数的左右节点分别对比合并，填充空节点。

## 四、求搜索二叉树的属性

* [700_二叉搜索树中的搜索](./700_二叉搜索树中的搜索.md)
  * 递归：按照搜索二叉树的特性完成搜索即可。
* [98_验证二叉搜索树](./98_验证二叉搜索树.md)
  * 递归：中序，记录前一个节点是否大于当前节点，若是返回`false`。**空的树也是搜索二叉树**，整合左右子树结果返回。
* [530_二叉搜索树的最小绝对差](./530_二叉搜索树的最小绝对差)
  * 递归：中序，记录前一个节点的值，与当前节点取差值，与全局变量比较更新记录。
* [538_把二叉搜索树转换为累加树](./538_把二叉搜索树转换为累加树.md)
  * 递归：中序，右中左，逐个累加返回即可。

##  五、二叉树公共祖先问题

* [236_二叉树的最近公共祖先](./236_二叉树的最近公共祖先.md)
  * 递归：后序，获取传入节点，向上地推，第一个左右节点均含有传入节点者就是最近公共祖先。
* [235_二叉搜索树的最近公共祖先](./235_二叉搜索树的最近公共祖先.md)
  * 递归：后序，根据二叉搜索树的特性，引导大于和小于范围内的节点向规定范围内搜索，第一个在范围内的节点就是最近公共祖先。

## 六、二叉搜索树的修改与构造

* [701_二叉搜索树中的插入操作](./701_二叉搜索树中的插入操作.md)
  * 递归：按照二叉树的逻辑递归，在一个空节点处构建新元素即可。
* [450_删除二叉搜索树中的节点](./450_删除二叉搜索树中的节点.md)
  * 递归：前序,根据被删除节点是（1.叶子节点，2.有一侧节点不为空，3.两侧节点均不为空，其左节点要放在右节点的最左叶子上）。
* [669_修剪二叉搜索树](./669_修剪二叉搜索树.md)
  * 递归：前序，通过二叉搜索树的性质遍历完成修建操作，比较精妙。
* [108_将有序数组转换为二叉搜索树](./108_将有序数组转换为二叉搜索树.md)
  * 递归：前序，找出数组的中间值，递归切割数据即可。

## 七、总结

* 二叉树的构造，无论是普通还是搜索二叉树，均使用**前序**，先构造根节点。
* 普通二叉树的属性，一般是后序，通过递归函数做数据计算。
* 搜索二叉树的属性，就是中序了。

二叉树专题汇聚为一张图：

![img](https://file1.kamacoder.com/i/algo/20211030125421.png)