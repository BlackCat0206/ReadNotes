# 102_二叉树层序遍历

----Lee

看完本章，就可以一次解决10个题目了

## 一、题目

[力扣题目链接(opens new window)](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。

![102.二叉树的层序遍历](https://file1.kamacoder.com/i/algo/20210203144842988.png)



## 二、思路

**而这种层序遍历方式就是图论中的广度优先遍历，只不过我们应用在二叉树上。**

使用队列实现二叉树广度优先遍历，动画如下：

![102二叉树的层序遍历](https://file1.kamacoder.com/i/algo/102%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86.gif)

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if (NULL != root)
        {
            que.push(root);
        }

        while(!que.empty())
        {
            int size = que.size();
            vector<int> resTemp;
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if (NULL != node->left){
                    que.push(node->left);
                }
                if (NULL != node->right){
                    que.push(node->right);
                }
            }
            res.push_back(resTemp);
        }
        return res;
    }
};
```

## 四、拓展

#### 107.二叉树的层次遍历 II

[力扣题目链接](https://leetcode.cn/problems/binary-tree-level-order-traversal-ii/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<vector<int>> levelOrderBottom(TreeNode* root) {
        queue<TreeNode*> que;
        vector<vector<int>> res;
        if (NULL != root){
            que.push(root);
        }

        while(!que.empty())
        {
            int size = que.size();
            vector<int> resTemp;
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                if (NULL != node->left){
                    que.push(node->left);
                }
                if (NULL != node->right){
                    que.push(node->right);
                }
            }
            res.push_back(resTemp);
        }

        // 层序遍历变种，对层序遍历结果反转
        reverse(res.begin(), res.end());

        return res;
    }
};
```

#### 199.二叉树的右视图

[力扣题目链接(opens new window)](https://leetcode.cn/problems/binary-tree-right-side-view/)

给定一棵二叉树，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        if (NULL != root){
            que.push(root);
        }

        while(!que.empty())
        {
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();

                // 层序遍历变种，只读取每一层的最后一个元素即可。
                if (i == size - 1)
                {
                    res.push_back(node->val);
                }

                if (node->left){
                    que.push(node->left);
                }
                if (node->right){
                    que.push(node->right);
                }
            }
        }
        return res;
    }
};
```

#### 637.二叉树的层平均值

[力扣题目链接(opens new window)](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

给定一个非空二叉树, 返回一个由每层节点平均值组成的数组。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        queue<TreeNode*> que;
        vector<double> res;

        if (NULL != root){
            que.push(root);
        }

        while(!que.empty()){
            int size = que.size();
            double sum = 0;
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();
                sum += node->val;
                if (node->left){
                    que.push(node->left);
                }
                if (node->right){
                    que.push(node->right);
                }
            }
            res.push_back(sum/size);
        }
        return res;
    }
};
```

#### 429.N叉树的层序遍历

[力扣题目链接(opens new window)](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)

给定一个 N 叉树，返回其节点值的层序遍历。 (即从左到右，逐层遍历)。

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    vector<Node*> children;

    Node() {}

    Node(int _val) {
        val = _val;
    }

    Node(int _val, vector<Node*> _children) {
        val = _val;
        children = _children;
    }
};
*/

class Solution {
public:
    vector<vector<int>> levelOrder(Node* root) {
        queue<Node*> que;
        vector<vector<int>> res;
        if (NULL != root){
            que.push(root);
        }

        while(!que.empty()){
            int size = que.size();
            vector<int> resTemp;
            for (int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();
                resTemp.push_back(node->val);
                // 层序遍历二叉树变种，添加字子节点
                for (int j = 0; j < node->children.size(); j++){
                    if (NULL != node->children[j]){
                        que.push(node->children[j]);
                    }
                }
            }
            res.push_back(resTemp);
        }

        return res;
    }
};
```

#### 515.在每个树行中找最大值

[力扣题目链接(opens new window)](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

您需要在二叉树的每一行中找到最大的值。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        queue<TreeNode*> que;
        vector<int> res;
        
        if (NULL != root){
            que.push(root);
        }

        while(!que.empty()){
            int size = que.size();
            int max = INT_MIN;			// 寻找最大值，起始的值要是最小的
            for (int i = 0; i < size; i++){
                TreeNode* node = que.front();
                que.pop();
                // 层序遍历变种，寻找最大值
                max = max > node->val ? max : node->val;
                if (NULL != node->left){
                    que.push(node->left);
                }
                if (NULL != node->right){
                    que.push(node->right);
                }
            }
            res.push_back(max);
        }
        return res;
    }
};
```

#### 116.填充每个节点的下一个右侧节点指针

[力扣题目链接(opens new window)](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

给定一个完美二叉树，其所有叶子节点都在同一层，每个父节点都有两个子节点。二叉树定义如下：

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;
        if (NULL != root){
            que.push(root);
        }

        while(!que.empty()){
            int size = que.size();
            for (int i = 0; i < size; i++){
                Node* node = que.front();
                que.pop();

                // 当前节点已经是本层的最后一个节点
                if (i == size - 1){
                    node->next = NULL;
                }
                else{
                    node->next = que.front();
                }

                if (node->left){
                    que.push(node->left);
                }
                if (node->right){
                    que.push(node->right);
                }
            }
        }
        return root;
    }
};
```

#### 117.填充每个节点的下一个右侧节点指针II

[力扣题目链接](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

```cpp
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;
    Node* next;

    Node() : val(0), left(NULL), right(NULL), next(NULL) {}

    Node(int _val) : val(_val), left(NULL), right(NULL), next(NULL) {}

    Node(int _val, Node* _left, Node* _right, Node* _next)
        : val(_val), left(_left), right(_right), next(_next) {}
};
*/

class Solution {
public:
    Node* connect(Node* root) {
        queue<Node*> que;

        if (NULL != root)
        {
            que.push(root);
        }

        while(!que.empty())
        {
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                Node* node = que.front();
                que.pop();
                if (i != size - 1)
                {
                    node->next = que.front();
                }

                if (NULL != node->left)
                {
                    que.push(node->left);
                }
                
                if(NULL != node->right)
                {
                    que.push(node->right);
                }
            }
        }
        return root;
    }
};
```

#### 104.二叉树的最大深度

[力扣题目链接(opens new window)](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

给定一个二叉树，找出其最大深度。

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int maxDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if (NULL != root)
        {
            que.push(root);
        }
        
        int depth = 0;
        while(!que.empty())
        {
            depth++;
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();

                if (NULL != node->left)
                {
                    que.push(node->left);
                }

                if (NULL != node->right)
                {
                    que.push(node->right);
                }
            }
        }
        return depth;
    }
};
```

#### 111.二叉树的最小深度

[力扣题目链接](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        queue<TreeNode*> que;
        if (NULL != root)
        {
            que.push(root);
        }

        int depth = 0;
        int isFind = 0;
        while(!que.empty())
        {
            depth++;
            int size = que.size();
            for (int i = 0; i < size; i++)
            {
                TreeNode* node = que.front();
                que.pop();

                // 若左右节点均为空，则到达最浅深度
                if (NULL == node->left && NULL == node->right){
                    isFind = 1;
                    break;
                }

                if (NULL != node->left)
                {
                    que.push(node->left);
                }

                if (NULL != node->right)
                {
                    que.push(node->right);
                }
            }

            if (1 == isFind)
            {
                break;
            }
        }
        return depth;
    }
};
```

