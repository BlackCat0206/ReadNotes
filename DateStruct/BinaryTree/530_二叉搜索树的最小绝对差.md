# 530.二叉搜索树的最小绝对差

---- Lee

## 一、题目

给你一棵所有节点为非负值的二叉搜索树，请你计算树中任意两节点的差的绝对值的最小值。

示例：

![530二叉搜索树的最小绝对差](https://file1.kamacoder.com/i/algo/20201014223400123.png)

提示：树中至少有 2 个节点。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

## 二、思路

* 计算最小差值绝对值，按照中序遍历，从小到达遍历。

  * 声明一节点指针用于记录前一节点。
  * 声明一整形变量用于记录最小差绝对值。

* 递归三要素：

  * 确认返回值类型和参数类型：
    * 返回值类型，需要返回数据，void
    * 参数类型：处理当前节点：`TreeNode*`

  ```cpp
  void minSub(TreeNode* cur);
  ```

  * 终止条件：当前节点为空，返回

  ```cpp
  if (nullptr == cur){
      return ;
  }
  ```

  * 单次遍历实现的功能：中序遍历
    * 执行左子树小差的计算
    * 计算上一节点与当前节点的差的绝对值，判断是否需要更新最小差绝对值。
    * 将`pre`节点更新为当前节点。
    * 执行右子树最小差的计算

  ```cpp
  minSub(cur->left);
  if (nullptr != pre){
      minSub = min(minSub, abs(pre->val - cur->val));
  }
  pre = cur;
  minSub(cur->right);
  return;
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pre = nullptr;
    int minSub = INT_MAX;
    void traversal(TreeNode* cur){
        if (nullptr == cur){
            return;
        }

        traversal(cur->left);
        if (nullptr != pre){
            minSub = min(minSub, cur->val - pre->val);
        }
        pre = cur;
        traversal(cur->right);
        return;
    }

    int getMinimumDifference(TreeNode* root) {
        traversal(root);
        return minSub;
    }
};
```

