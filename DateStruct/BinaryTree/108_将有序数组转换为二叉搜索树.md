# 108_将有序数组转换为二叉搜索树

---- Lee

## 一、题目

将一个按照升序排列的有序数组，转换为一棵高度平衡二叉搜索树。

本题中，一个高度平衡二叉树是指一个二叉树每个节点 的左右两个子树的高度差的绝对值不超过 1。

示例:

![108.将有序数组转换为二叉搜索树](https://file1.kamacoder.com/i/algo/20201022164420763.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/)

## 二、思路

平衡二叉搜索树：对于有序数组来说，既每次的节点都是当前数组的中间节点的值，然后分割数组，当前下发的left < right时，结束

* 递归三要素

  * 返回值类型的参数：
    * 返回值类型：新构建的节点指针：`TreeNode*`
    * 参数：数组，左右边界下标

  ```cpp
  TreeNode* traveresal(vector<int>& nums, int left, int right)
  ```

  * 终止条件：下发左边界大于右边界

  ```cpp
  if (left > right) 
      return nullptr;
  ```

  * 单次遍历实现的内容
    * 获取当前有序数组的中间值，构建新的元素节点。
    * 构建新节点的左右子树，分割递归传入数组的边界。左闭右闭

  ```cpp
  int middle = left + (right - left) / 2;
  TreeNode* node = new TreeNode(nums[middle]);
  node->left = traversal(nums, left, middle - 1);
  node->right = traversal(nums, middle + 1, right);
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* traversal(vector<int>& nums, int left, int right){
        if (left > right){
            return nullptr;
        }

        int middle = left + (right - left) / 2;
        TreeNode* node = new TreeNode(nums[middle]);
        node->left = traversal(nums, left, middle - 1);
        node->right = traversal(nums, middle + 1, right);

        return node;
    }

    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return traversal(nums, 0, nums.size() - 1);
    }
};
```

