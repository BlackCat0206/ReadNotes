# 617_合并二叉树

---- Lee

## 一、题目

给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。

你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。

示例 1:

![617.合并二叉树](https://file1.kamacoder.com/i/algo/20230310000854.png)

注意: 合并必须从两个树的根节点开始

[力扣题目链接(opens new window)](https://leetcode.cn/problems/merge-two-binary-trees/)

## 二、思路

递归法：

* 两棵树一起递归遍历。

* 若对传入的节点都不为空，则将二者的值合并，同时继续遍历迭代新节点左右子节点。若其中有一个为空，另一个不为空，返回不为以不为空的值所构成的新节点。若均为空，终止遍历返回`nullptr`。

* 递归三要素：

  * 确认函数返回值和参数类型与个数：
    * 返回值：构成的新节点：`TreeNode*`
    * 参数类型与个数：两棵树的节点。

  ```cpp
  TreeNode* combineTree(TreeNode* node1, TreeNode* node2);
  ```

  * 确认终止条件：传入的两个节点均为空，返回`nullptr`

  ```cpp
  if (nullptr == node1 && nullptr == node2) {
      return nullptr;
  }
  ```

  * 单次遍历实现的逻辑：
    * 若传入的两个节点均不为空，将两个节点的值的和构建新的节点。继续传入两个节点的左右子节点构建新节点的左右节点。
    * 若只有一个节点不为空，以不为空节点的值构建新的节点，传入不为空节点的左右子节点继续遍历构建。

  ```cpp
  // 构建新节点
  TreeNode* node = nullptr;
  
  // 若传入两个节点有一个为空
  if (nullptr != node1 && nullpt == node2) {
      node = new TreeNode(node1->val);
      node->left  = combineTree(node1-left, nullptr);
      node->right = combineTree(node1->right, nullptr);
      return node;
  }
  
  if (nullptr == node1 && nodeptr == node2) {
      node = new TreeNode(node2->val);
      node->left = combineTree(nullptr, node2->left);
      node->right = combineTree(nullptr, node2->right);
      return node;
  }
  
  node = new TreeNode(node1->val + node2->val);
  node->left = combineTree(node1->left, node2->left);
  node->right = combineTree(node1->right, node2->right);
  return node;
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
          if (nullptr == root1 && nullptr == root2){
              return nullptr;
          }
  
          TreeNode* node = nullptr;
          if (nullptr != root1 && nullptr == root2){
              node = new TreeNode(root1->val);
              node->left = mergeTrees(root1->left, nullptr);
              node->right = mergeTrees(root1->right, nullptr);
              return node;
          }
  
          if (nullptr == root1 && nullptr != root2){
              node = new TreeNode(root2->val);
              node->left = mergeTrees(nullptr, root2->left);
              node->right = mergeTrees(nullptr, root2->right);
              return node;
          }
  
          node = new TreeNode(root1->val + root2->val);
          node->left = mergeTrees(root1->left, root2->left);
          node->right = mergeTrees(root1->right, root2->right);
          return node;
      }
  };
  ```

  