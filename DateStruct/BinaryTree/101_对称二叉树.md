# 101_对称二叉树

给定一个二叉树，检查它是否是镜像对称的。

![101. 对称二叉树](https://file1.kamacoder.com/i/algo/20210203144607387.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/symmetric-tree/)

## 二、思路

* 递归三要素

  * 明确返回值类型和参数类型：要判断是否对称，就传入根的两个节点进行判断，返回bool值

  ```cpp
  bool compare(TreeNode* left, TreeNode* right)
  ```

  * 终止条件：

  * 要比较两个节点数值相不相同，首先要把两个节点为空的情况弄清楚！否则后面比较数值的时候就会操作空指针了。

    节点为空的情况有：（**注意我们比较的其实不是左孩子和右孩子，所以如下我称之为左节点右节点**）

    - 左节点为空，右节点不为空，不对称，return false
    - 左不为空，右为空，不对称 return false
    - 左右都为空，对称，返回true

    此时已经排除掉了节点为空的情况，那么剩下的就是左右节点不为空：

    - 左右都不为空，比较节点数值，不相同就return false

    此时左右节点不为空，且数值也不相同的情况我们也处理了。

  ```cpp
  if (NULL != left && NULL == right)
  {
      return false;
  }
  else if (NULL == left && NULL != right)
  {
      return false;
  }
  else if (left->val != right->val)
  {
      return false;
  }
  eles if (NULL == left && NULL == right)
  {
      return true;
  }
  ```

  * 单次递归要完成的内容：
    * 判断二叉树外则是否相等：传入的是左节点的左孩子，右节点的右孩子。
    * 判断二叉树内测是否相等：传入左节点的右孩子，右节点的左孩子。
    * 如果左右对称返回`true`,否则返回`false`

  ```cpp
  bool outside = compare(left->left, right->right);
  bool inside = compare(left->right, rigth->left);
  bool isSame = inside && outside;
  return isSame;
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:    
  
      bool compare(TreeNode* left, TreeNode* right)
      {
          if (NULL == left && NULL == right){
              return true;
          }
          else if (NULL != left && NULL == right){
              return false;
          }
          else if (NULL == left && NULL != right){
              return false;
          }
          else if (left->val != right->val){
              return false;
          }
  
  
          bool outside = compare(left->left, right->right);
          bool inside = compare(left->right, right->left);
          bool isSame = outside && inside;
          return isSame;
      }
      
      bool isSymmetric(TreeNode* root) {
          if (NULL == root){
              return true;
          }
  
          bool isSame = compare(root->left, root->right);
          return isSame;
      }
  };
  ```

  