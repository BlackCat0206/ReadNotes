# 538_把二叉搜索树转换为累加树

## 一、题目

给出二叉 搜索 树的根节点，该树的节点值各不相同，请你将其转换为累加树（Greater Sum Tree），使每个节点 node 的新值等于原树中大于或等于 node.val 的值之和。

提醒一下，二叉搜索树满足下列约束条件：

节点的左子树仅包含键 小于 节点键的节点。 节点的右子树仅包含键 大于 节点键的节点。 左右子树也必须是二叉搜索树。

示例 1：

![538.把二叉搜索树转换为累加树](https://file1.kamacoder.com/i/algo/20201023160751832.png)

- 输入：[4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]
- 输出：[30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]

示例 2：

- 输入：root = [0,null,1]
- 输出：[1,null,1]

示例 3：

- 输入：root = [1,0,2]
- 输出：[3,3,2]

示例 4：

- 输入：root = [3,2,4,1]
- 输出：[7,9,4,10]

提示：

- 树中的节点数介于 0 和 104 之间。
- 每个节点的值介于 -104 和 104 之间。
- 树中的所有值 互不相同 。
- 给定的树为二叉搜索树。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/convert-bst-to-greater-tree/)

## 二、思路

从树中可以看出累加的顺序是**右中左**，所以我们需要**反中序遍历**这个二叉树，然后顺序累加就可以了。使用外部遍历记录当前的累加

* 递归三要素
* 确认返回值类型和参数类型：
  * 返回值类型：`void`
  * 参数类型：当前节点指针`TreeNode*`

```cpp
void traversal(TreeNode* cur);
```

* 确认终止条件：节点为空，则返回空。

```cpp
if (nullptr == cur){
    return nullptr;
}
```

* 确认单次递归要完成的内容：
  * 递归右侧，完成累加。
  * 将累加值更新到本当前节点。
  * 递归左侧，完成累加。

```cpp
traversal(cur->right);
pre += cur->val;
cur->val = pre;
traversal(cur->left);
```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int pre = 0;
    void traversal(TreeNode* cur){
        if (nullptr == cur){
            return;
        }
        
        traversal(cur->right);
        pre += cur->val;
        cur->val = pre;
        traversal(cur->left);
        
        return;
    }

    TreeNode* convertBST(TreeNode* root) {
        traversal(root);
        return(root);
    }
};
```

