# 669. 修剪二叉搜索树

---- Lee

## 一、题目

给定一个二叉搜索树，同时给定最小边界L 和最大边界 R。通过修剪二叉搜索树，使得所有节点的值在[L, R]中 (R>=L) 。你可能需要改变树的根节点，所以结果应当返回修剪好的二叉搜索树的新的根节点。

![669.修剪二叉搜索树](https://file1.kamacoder.com/i/algo/20201014173115788.png)

![669.修剪二叉搜索树1](https://file1.kamacoder.com/i/algo/20201014173219142.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/trim-a-binary-search-tree/)

##  二、思路

* 注意：不要直接用区间来判断当前的节点是否符合，不符合直接返回空（没有考虑当前节点的左右子树），这回导致如下的情况：

![669.修剪二叉搜索树](https://file1.kamacoder.com/i/algo/20210204155302751.png)

故，最终要实现的效果，是逐个遍历并去除不在区间种的元素—通过节点。

* 递归三要素：

  * 确认函数返回值类型和参数类型
    * 返回值类型：返回处理后的节点：TreeNode*
    * 参数类型：当前要处理的节点和要元素的范围。

  ```cpp
  TreeNode* trimBST(TreeNode* root, int low, int high) 
  ```

  * 确认终止条件：当前节点为空时，返回:

  ```cpp
  if (nullptr == root){
      return root;
  }
  ```

  * 单次循环完成的内容：
    * 若当前元素在取值范围内：继续向左右子树遍历，获取新的左右子树。
    * 若当前元素不在取值范围内：
      * 当前元素在范围左：向右遍历，获取符合条件的右子树。
      * 当前元素在范围右：向左遍历，获取符合条件的左子树。

  ```cpp
  if (hight < root->val)
  {
      TreeNode* left = trimBST(root->left, low, hight);
      return left;
  }
  
  if (low > root->val)
  {
  	TreeNode* right = trimBST(root->right, low, hight);
      return right;
  }
  
  
  root->left = trimBST(root->left, low, right);
  root->right = trimBST(root->right, low, right);
  return root;
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      TreeNode* trimBST(TreeNode* root, int low, int high) {
          if (nullptr == root){
              return root;
          }
  
          // 如果当前节点的值在范围之外，返回符合条件范围的子树（既，去除范围外的节点）
          if (high < root->val){
              TreeNode* left = trimBST(root->left, low, high);
              return left;
          }
  
          if (low > root->val){
              TreeNode* right = trimBST(root->right, low, high);
              return right;
          }
  
          // 当前节点在取值范围内，构建其新的左右子树。
          root->left = trimBST(root->left, low, high);
          root->right = trimBST(root->right, low, high);
          return root;
      }
  };
  ```

  