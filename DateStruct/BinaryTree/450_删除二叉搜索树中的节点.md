# 450.删除二叉搜索树中的节点

---- Lee

## 一、题目

给定一个二叉搜索树的根节点 root 和一个值 key，删除二叉搜索树中的 key 对应的节点，并保证二叉搜索树的性质不变。返回二叉搜索树（有可能被更新）的根节点的引用。

一般来说，删除节点可分为两个步骤：

首先找到需要删除的节点； 如果找到了，删除它。 说明： 要求算法时间复杂度为 $O(h)$，h 为树的高度。

示例:

![450.删除二叉搜索树中的节点](https://file1.kamacoder.com/i/algo/20201020171048265.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/delete-node-in-a-bst/)

## 二、思路

* 删除的情况会比添加复杂一些，需要考虑五种情况，复杂程度因人而异。

* 递归三要素：

  * 确认函数返回值类型于参数类型
    * 返回值类型：返回新的节点，节点指针类型
    * 参数类型：处理当前节点于要删除的元素值

  ```cpp
  TreeNode* deleteBST(TreeNode* cur, int val)
  ```

  * 终止条件：当前节点为空，返回`nullptr`

  ```cpp
  if (nullptr == cur){
      return nullptr;
  }
  ```

  * 单次递归要处理的逻辑
  * 找到要删除的元素：
    * 第一种：没找到，直接返回空。
    * 第二种：元素左右节点为空，直接删除返回空节点。
    * 第三种：元素左节点不为空，元素节点右为空，删除当前节点，返回左节点。
    * 第四种：元素左节点为空，元素右节点不为空，删除当前节点，返回右节点。
    * 第五种：元素左右节点均不为空，将元素左节点的内容放入右节点最左侧节点的左子节点。

  第五种情况有点难以理解，看下面动画：

  ![450.删除二叉搜索树中的节点](https://file1.kamacoder.com/i/algo/450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.gif)

  ```cpp
  if (val == cur->val)
  {
      TreeNode* temp = nullptr;
      // 第二种，第三种情况
      if (nullptr == cur->right){
          temp = cur->left;
          delete cur;
          cur = nullptr;
          return temp;
      }
      // 第四种情况
      else if (nullptr == cur->left){
          temp = cur->right;
          delete cur;
          cur = nullptr;
          return temp;
      }
      // 第五种
      else{
          TreeNode* rightTemp = cur->right;
          while(nullptr != rightTemp->left){
              rightTemp = rightTemp->left;
          }
          rightTemp->left = cur->left;
          TreeNode* temp = cur;
          cur = cur->right;
          delete temp;
          return cur;
      }
  }
  ```

  * 没找到：
    * 若当前节点的值 > 查询值：向左查询，用当前节点的左节点接收结果。
    * 若当前节点的值 < 查询值：向右查询，用当前节点的右节点接收结果。
  * 返回当前节点

  ```cpp
  if (cur->val > val){
      cur->left = deleteBST(cur->left, val);
  }
  else{
      cur->right = deleteBST(cur->right, val);
  }
  
  return cur;
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        if (nullptr == root){
            return root;
        }

        if (key == root->val){
            TreeNode* temp = nullptr;
            // 第二种，第三种：左右均为空，或右侧为空
            if (nullptr == root->right){
                temp = root->left;
            }
            // 第四种情况：右不为空，左为空
            else if (nullptr == root->left){
                temp = root->right;
            }
            else{
                // 第五种情况：将左子树放入右子树最左侧节点的左子节点
                TreeNode* cur = root->right;
                while(nullptr != cur->left){
                    cur = cur->left;
                }
                cur->left = root->left;
                temp = root->right;
            }
            delete root;
            return temp;            
        }

        if (key < root->val){
            root->left = deleteNode(root->left, key);
        }
        else{
            root->right = deleteNode(root->right, key);
        }

        return root;
    }
};
```

