# 700.二叉搜索树中的搜索

---- Lee

## 一、题目

给定二叉搜索树（BST）的根节点和一个值。 你需要在BST中找到节点值等于给定值的节点。 返回以该节点为根的子树。 如果节点不存在，则返回 NULL。

例如，

![700.二叉搜索树中的搜索](https://file1.kamacoder.com/i/algo/20210204155522476.png)

在上述示例中，如果要找的值是 5，但因为没有节点值为 5，我们应该返回 NULL。

[力扣题目地址(opens new window)](https://leetcode.cn/problems/search-in-a-binary-search-tree/)

## 二、思路

* 二叉搜索树：若其节点的左右子节点不为空，左子树的值均小于当前节点，右子树的值均大于当前节点。且其左右子树均为二叉搜索树。

* 本题的本质是一个搜索遍历的过程。那么，可以利用二叉搜索的特性，减少遍历所有的路径。

* 递归三要素：

  * 确认函数返回值类型和参数类型和个数：
    * 返回值类型：节点类型（若找到则返回节点，若未找到则返回`nullptr`）
    * 参数类型：当前节点，目标值

  ```cpp
  TreeNode* searchTree(TreeNode* node, int target);
  ```

  * 终止条件：当前节点为空，返回`nullptr`

  ``` cpp
  if (nullptr == cur){
      return　nullptr;
  }
  ```

  * 单次递归要执行的内容：
  * 判断当前节点的值是否相等，相等直接返回。
  * 否则根据二叉搜索树的特性，进行分叉搜索，将结果进行返回。

  ```cpp
  if (node->val == target){
      return node;
  }
  
  TreeNode* result = nullptr;
  if (target < cur->val){
   	result = searchTree(node->left, target);   
  }
  else{
      result = searchTree(node->right, target);
  }
  return result;
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
   *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
   *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
   * };
   */
  class Solution {
  public:
      TreeNode* searchBST(TreeNode* root, int val) {
          if (nullptr == root || val == root->val){
              return root;
          }
  
          TreeNode* result = nullptr;
          if (val < root->val){
              result = searchBST(root->left, val);
          }
          else
          {
              result = searchBST(root->right, val);
          }
          return result;
      }
  };
  ```

  