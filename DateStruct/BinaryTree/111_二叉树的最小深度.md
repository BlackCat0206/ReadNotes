# 111_二叉树的最小深度

---- Lee

## 一、题目

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

说明: 叶子节点是指没有子节点的节点。

示例:

给定二叉树 [3,9,20,null,null,

[力扣题目链接(opens new window)](https://leetcode.cn/problems/minimum-depth-of-binary-tree/)

## 二、题目

* 递归三要素
* 参数类型和返回值的类型：需要返回当前节点的最小深度，返回值为`int`类型。参数为当前节点类型。

```cpp
int minDepth(TreeNode* node)
```

* 终止条件：节点为空返回0

```cpp
if (NULL == cur) return 0;
```

* 单次遍历执行内容：1.获取子节点的最小节点数； 2.一个节点一侧为空另一侧不为空，不是叶子节点，返回不为空的节点深度；3.若当前节点两侧均不为空，则计算最小深度返回。

```cpp
int leftDepth = minDepth(node->left);
int rightDepth = minDepth(node->right);

// 如果一个节点，左节点为空，右节点不为空，其尚未到达最小深度。
if (NULL == left && NULL != right){
    return rightDepth + 1;
}

// 如果一个节点，右节点为空，左节点不为空，其尚未到达最小深度。
if (NULL == right && NULL != left)
{
    return leftDepth + 1;
}

return 1 + min(leftDepth, rigthDepth);
```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (NULL == root){
            return 0;
        }

        int leftDepth = minDepth(root->left);
        int rightDepth = minDepth(root->right);

        // 如果一个节点的左节点为空，右节点不为空，则未到达最小深度
        if (NULL == root->left && NULL != root->right){
            return 1 + rightDepth;
        }

        // 如果一个节点的右节点为空，左节点不为空，则未达到最小深度
        if (NULL == root->right && NULL != root->left){
            return 1 + leftDepth;
        }

        return 1 + min(leftDepth, rightDepth);
    }
};
```

