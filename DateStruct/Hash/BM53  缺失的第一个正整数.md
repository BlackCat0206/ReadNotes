# **BM53**  缺失的第一个正整数

----Lee

***

## 一、题目

给定一个无重复元素的整数数组nums，请你找出其中没有出现的最小的正整数

进阶： 空间复杂度 O(1)，时间复杂度 O(n)

数据范围:

−231≤nums[i]≤231−1−231≤*n**u**m**s*[*i*]≤231−1

0≤len(nums)≤5∗1050≤*l**e**n*(*n**u**m**s*)≤5∗105

示例

```
[1,0,2]
```

返回值：

```
3
```

## 二、思路

题目要求空间复杂度在O(1)，所有在选择容器时，要考虑底层为红黑树的容器。传入的数组是无序的，所以最好能将其排序。

* 使用set容器配合`vector`的迭代器完成排序。
* 确认查询的最小值：题目中要求的是最小的正整数，故查询时的基本值应该是`1`。
* 确认查询的最大值：数组中的最大数值，可以通过`rend()`获取到反向迭代器的值，即是数组的最大值。
* 若数据是连续的，则返回最大值+1

## 三、代码

```cpp
class Solution {
public:
    /**
     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可
     *
     * 
     * @param nums int整型vector 
     * @return int整型
     */
    int minNumberDisappeared(vector<int>& nums) {
        // write code here
        if (0 == nums.size())
        {
            return -1;
        }

        // 使用set
        set<int> set(nums.begin(), nums.end());        
        
        auto max_it = set.rbegin();     // 反向迭代器，获取最大值
        for (int i = 1; i < *max_it; i++)
        {
            if (set.find(i) == set.end())
            {
                return i;
            }
        }

        return (*max_it) + 1;
    }
};
```

