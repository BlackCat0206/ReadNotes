# 19.删除链表的倒数第N个节点

---- Lee

## 一、题目

给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。

进阶：你能尝试使用一趟扫描实现吗？

示例 1：

![19.删除链表的倒数第N个节点](https://file1.kamacoder.com/i/algo/20210510085957392.png)

输入：head = [1,2,3,4,5], n = 2 输出：[1,2,3,5]

示例 2：

输入：head = [1], n = 1 输出：[]

示例 3：

输入：head = [1,2], n = 1 输出：[1]

[力扣题目链接(opens new window)](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/)

## 二、思路

* 虚拟头节点
* 快慢指针，慢指针指向虚拟头节点，快指针指向链表头。
* 快指针先走N步，之后和慢指针一起出发，当`fast`到达NULL时，`slow`即可到达对应倒数点。
* 对于`while`循环中的变量，要保证其本身不会是空指针。

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* removeNthFromEnd(struct ListNode* head, int n) {
    // 入参校验
    if (NULL == head || 0 >= n)
    {
        return head;
    }

    // 设置虚拟节点头
    typedef struct ListNode ListNode;
    ListNode* fakeHead = (ListNode*)malloc(sizeof(ListNode));
    if (NULL == fakeHead)
    {
        return head;
    }

    // 定义变量名称
    fakeHead->next = head;

    // 快慢指针
    ListNode* fast = head;
    ListNode* slow = fakeHead;

    // 快指针先走
    while(0 < n-- && NULL != fast)
    {
        fast = fast->next;
    }

    // 将慢指针位移至倒数第N+1的位置
    while(NULL != fast)   // 不用fast->next, 是要考虑{1}此类链表的出现，此时fast本身为空。
    {
        fast = fast->next;
        slow = slow->next;
    }

    ListNode* temp = slow->next;
    slow->next = slow->next->next;

    free(temp);
    head = fakeHead->next;
    return head;
}
```

