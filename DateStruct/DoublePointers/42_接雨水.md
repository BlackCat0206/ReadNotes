# 42_接雨水

---- Lee

## 一、题目

给定 `n` 个非负整数表示每个宽度为 `1` 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。

**示例 1：**

![img](https://assets.leetcode.cn/aliyun-lc-upload/uploads/2018/10/22/rainwatertrap.png)

```
输入：height = [0,1,0,2,1,0,1,3,2,1,2,1]
输出：6
解释：上面是由数组 [0,1,0,2,1,0,1,3,2,1,2,1] 表示的高度图，在这种情况下，可以接 6 个单位的雨水（蓝色部分表示雨水）。 
```

**示例 2：**

```
输入：height = [4,2,0,3,2,5]
输出：9
```

**提示：**

- `n == height.length`
- `1 <= n <= 2 * 104`
- `0 <= height[i] <= 105`

[力扣题目链接](https://leetcode.cn/problems/trapping-rain-water/description/?envType=study-plan-v2&envId=top-100-liked)

## 二、思路

* **每个位置的接水量**：取决于其**两侧木板最高高度**的最小值。
* 核心公式：
  * 对于数组中任意位置 `i`，**能接的雨水量 = `min(左侧最高高度, 右侧最高高度) - 当前高度`**
    - 如果结果为负，说明当前位置比两侧短板还高，接不了水（取 0）；
    - 总雨水量 = 所有位置接水量之和。
  * 举个例子：数组 `[0,1,0,2,1,0,1,3,2,1,2,1]`
    * 位置 `2`（值为 0）：左侧最高是 1，右侧最高是 3 → 接水量 = min (1,3)-0=1；
    * 位置 `5`（值为 0）：左侧最高是 2，右侧最高是 3 → 接水量 = min (2,3)-0=2。

* 双指针的核心：压缩空间复杂度至O(1)
  * `left`从左（0）向右，`right`从右（size - 1）向左。
  * 维护 `left_max`（left 指针左侧的最高高度）和 `right_max`（right 指针右侧的最高高度）；
  * 贪心的规则：
    * 若`left_max < right_max`：左侧的短板是`left_max`，此刻`left`位置的接水量仅有`left_max`决定（因为右侧一定有更高的板兜住水），计算完`left`的接水量，`left++`。
    * 反之：右侧的短板是`right_max`，计算`right`位置的接水量后，`right--`。

## 三、代码

```cpp
int trap(vector<int>& height) {
    // 入参校验
    if (height.empty()){
        return 0;
    }

    // 定义双指针，移动至第一个不为0的元素
    int left = 0;
    int right = height.size() - 1;
    int area = 0;
    int left_max = height[left];
    int right_max = height[right];

    while (left < right) {
        left_max = max(left_max, height[left]);
        right_max = max(right_max, height[right]);

        // 若左侧最大值小于右侧最大值，则说明左侧可以存水。
        if (left_max < right_max)
        {
            // 计算左侧存水量
            area += left_max - height[left];
            left++;
        }
        else
        {
            // 计算右侧存水量
            area += right_max - height[right];
            right--;
        }
    }

    return area;
}
```

## 四、源码

[TrappingRainWater.cpp](./SourceCode/TrappingRainWater.cpp)