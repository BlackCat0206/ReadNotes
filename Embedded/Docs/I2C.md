# I2C

---- Chime Lee

## 一、概述

I2C（*Inter-Intergrated Circuit*）集成电路总线

**信号：**

I2C_SCL(*Serial Clock*)：串行时钟线，方向：IO

I2C_SDA(*Serial Data*)：串行数据线，方向：IO

**工作方式：**半双工

**设备间关系：**主从关系

**仲裁逻辑：**I2C时多主机总线，当两个或多个主机发送数据时，通过**开漏输出**和“**线与”逻辑**，实现**总线仲裁**，任何主机发现自己想发送“1”而总线是“0”，就立刻退出竞争。

* SDA，SCL为开漏结构，借助外部的上拉电阻实现了信号的“线与”逻辑。
* 引脚在输出信号的同时在**作为输入信号进行内部检测**，当输出于输入不一致，表示有问题。这为"时钟同步"和“总线仲裁”提供了硬件基础。

**信号类型：**

* 开始信号：时钟信号高电平，数据信号从**高电平->低电平**。

* 接收数据：
  * 时钟信号高电平，接收数据信号时机。
  * 时钟信号低电平，改变数据信号时机。
* 响应信号：从机芯片收到8位数据后，在第9个时钟周期，数据信号为低电平应答，高电平表示非应答。

* 结束信号：时钟信号高电平，数据信号从**低电平->高电平**。

**寄存器介绍：**

* IC2x_IADR (**I2C Address Register**)：I2C地址寄存器
  * [7:1] 作为I2C从设备时的地址；适用软件复位时，这个寄存器不受影响。
* I2Cx_IFDR (**I2C Frequency Divider Register**)：I2C分频寄存器。
  * [5:0] 设置SCL时钟，数据传输过程中，IC值不能改变；但是在发出S信号之前，可以改变。
  * PLL2_PFDn频率 = PLL2频率 × 18 / PFDn_FRAC
  * 一直计算到PERCL_CLK_ROOT = 49.5MHz。
  * 要设置I2C的波特率是100K，I2C分频值 = 49500000 / 100000 = 495，查表选取0x37对应512最接近。
* I2Cx_I2CR (**I2C Control Register**)：I2C控制寄存器
  * [7] IEN：I2C使能
  * [6] IIEN：I2C中断使能，I2C_I2SR[IIF]无论什么状态都可以适用。
  * [5] MSTA：主从模式选择：
    * 0从机 1->0 发送stop，
    * 1主机 0 -> 1，发送start
    * 如果失去总线，硬件会清除此位
  * [4] MTX：发送/接收模式
    * 0：接收模式
    * 1：发送模式
  * [3] TXAK：发送响应使能，处于接收状态才有效
    * 0：第9个时钟周期，发送响应信号，把SDA拉低。
    * 1：第9个时钟周期，不发送响应信号
  * [2] RSTA：Repeat start，读该位总得到0
    * 0 不发送repeat start信号
    * 1 发送 repeat start信号
* I2Cx_I2SR(**I2C Status Register**)：I2C状态寄存器
  * [7] ICF Data transferring bit，数据正在传输标志，
    * 0：正在传输；
    * 1：传输结束，当第 9 个时钟发出后，硬件置位
  * [6] IAAS I2C address as a slave bit，I2C 控制器作用从设备时，通过此位来判断是否有人来寻址它：
    * 0：没人找我；
    * 1：有别的 I2C 主机在找我了
  * [5] IBB I2C bus busy bit，用来显示总线状态，
    * 0：总线空闲，发现 STOP 信号时，IBB 就被清 0；
    * 1：总线忙，发现 START 信号时，IBB 就被置 1
  * [4] IAL Arbitration lost，此位由硬件设置，软件要写入 0来清零，
    * 0：没有丢失总线，
    * 1：总线丢失了
  * [3]  TXAK  发送响应使能，当 I2C 设备处于接收状态时，此位才有效。
    * 0：在第 9 个时钟，发送响应信号，即把 SDA 拉低；
    * 1：在第 9 个时钟，不发送响应信号；
  * [2] SRW  Slave read/write，作为从设备时，主机发送设备地址时会带有读写位，读写位的内容就写入 SRW 中，
    * 0：slave receive，主设备要写数据；
    * 1：slave transmit，主设备要读数据;
  * [1] IIF I2C 中断状态，写 0 清中断，
    * 0：没有 I2C 中断发生；
    * 1：I2C 中断发生了，如果 IIEN=1 则会产生中断，有这些中断：
      * 一个字节传输完毕；
      * 作为从设备，接收到了一个吻合的地址；
      * 总线丢失。
  * [0] RXAK Received acknowledge，是否接收到回应信号，
    * 0：收到了：在一个字节传完后第 9 个时钟周期，收到了回应信号；
    * 1：没收到
* I2Cx_I2DR (**I2C Data I/O Register**) ：数据寄存器
  * [7:0] DATA 
    * 对于接收：存有接收到的最新数据，软件把数据读出来。
    * 对于发送：存放下一个即将哟啊发送的数据，这是软件写进入的。


## 二、实验内容

AP3216光强传感器，接近传感器，还有一个LED。

**AP3216C寄存器读写：**

* 怎么访问到AP3216C？AP3216的设备地址是**0X1E**。
* 怎么访问某个寄存器？发出寄存器地址。
* **写AP3216C的寄存器，有两种方法：**
  * 发送：[设备地址 + 写操作] + [寄存器地址]
  * 发送：
    * [从机设备地址 + 写操作] 
    * [寄存器地址] 
    * [Register Command(寄存器数据)]

* **读AP3216C的寄存器，有两种方法：**
  * 发送：[设备地址 + 读操作] + [Register Command(返回的寄存器数据)]。返回的寄存器的值不确认。
  * 发送：
    * [设备地址 + 写操作] 
    *  [寄存器地址] 
    * RSTART [设备地址+读操作] 
    *  [Register Command(返回的寄存器数据)] + NO ACK。
* 操作符：
  * 读：1
  * 写：0

**AP3216C寄存器：**

* 系统配置寄存器
* 中断状态寄存器
* 中断清理寄存器
* 红外低八位数据寄存器
* 红外高八位数据寄存器
* 环境光低八位数据寄存器
* 环境光高八位数据寄存器
* 接近光低八位数据寄存器
* 接近光高八位数据寄存器

**I2C初始化与读写操作实现整体流程：**

**初始化：**

* 多路复用和电器参数配置（SION开启，开漏使能，上拉电阻）
* 信号选择
* 时钟初始化：
  * 关闭I2C
  * 配置时钟
  * 使能I2C

**校验函数：**

* 校验是否发送总线仲裁。
  * 重置仲裁
  * 重新使能I2C
* 是由有应答。

**Start信号发送：**

* 判断总线是否忙碌
* 改为主机模式/发送模式
* 发送“从机地址”+“操作符”

**Restart信号发送：**

* 判断总线是否忙碌且自己是从机模式（返回）
* 改为发送模式/发送restart信号
* 发送“从机地址”+“操作符”

**Stop信号发送：**

* 设置超时变量。
* 改为从机模式/接收模式/不发送响应。
* 等待从主机变为从机发送STOP信号（判断总线是否忙碌，忙碌开始）。

**读操作：**

* 设置一个假读变量。
* 等待数据传输结束，清空校验位。
* 转为接收模式/开启应答。
* 若只读一个字节，关闭应答。
* 假读。
* 根据读取数据长度轮询
  * 等待数据传输完成。
  * 清空中断。
  * 倒数第二个数据，设置“不应答”。
  * 最后一个字节发送stop
  * 接收数据。

**写操作：**

* 等待数据传输完成，清空校验位。
* 转换到发送模式
* 轮询发送：
  * 传输数据
  * 等待数据传输完成
  * 清空中断
  * 校验函数
* 清空中断
* 发送stop

**转换操作：**

* 等待数据发送完成。
* 重置标志位（中断位和总线仲裁）
* 发送start信号
* 等待中断，校验函数。
* 如果有寄存器地址：
  * 清空中断
  * 递减长度
  * 数据传输
  * 等待中断，校验函数
  * 如果是读操作：发送restart信号，等待中断、校验。
* 读操作
* 写操作

## 三、代码

[I2C.c](../I2C/Src/I2C_Custom.c)

[AP3216C.c](../I2C/Src/AP3216.c)

## 四、DEBUG

### 4.1 位运算的错误导致死循环

baseValue >> 3 & 1 << 0 的结果是否相同？

**核心分析**

**首先，我们先拆解这两个表达式的数学含义：**

1. `1<<4` 的结果是 `16`（二进制 `10000`）
2. `1<<0` 的结果是 `1`（二进制 `1`）

**表达式 1：`status & (1<<4)`**

- 作用：检查 `status` 的第 4 位（从 0 开始计数）是否为 1
- 结果：如果第 4 位是 1，结果为 `16`（二进制 `10000`）；如果是 0，结果为 `0`

**表达式 2：`(status >> 4) & (1 << 0)`**

- 作用：先把 `status` 右移 4 位（将第 4 位移到第 0 位），再检查第 0 位是否为 1
- 结果：如果原第 4 位是 1，结果为 `1`；如果是 0，结果为 `0`

**小结：**

* 因个人开发习惯，对于任何非bool类型的条件判断，一定要写出具体条件，错误写出了
  `表达式2`，导致进入死循环。
* 后续修改为：`while(1 != ((I2C_BASE->I2Cx_I2SR>>3) & (1 << 0)))`

### 4.2 I2C的引脚既输出信号，也会作为输入信号内部检测，这一特性如何实现呢？

* 当两个或多个设备发送数据时，通过**开漏输出**和**”线于逻辑”**，实现了**总线仲裁**，当设备发送“1”但总线是"0"时，它会放弃竞争。
* I2C的引脚既能**输出信号**，也能作为**输入信号内部检测**，当输入和输出不一致时，表示有问题，这为“**时钟同步**”和“**总线仲裁**”提供了硬件基础。
* MUX多路复用寄存器的[4] ：SION（Software Input ON）
  * 无视引脚的输入/输出方向，强制打开输入。
* 作用：
  * 回环确认自己的信号是否有效。
  * 接收应答（之前的问题是start应答超时）。