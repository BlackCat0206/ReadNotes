# UART

---- Chime Lee

## 一、概述

UART（*Universal Asynchronous Receiver/Transmitter*）：通用异步收发器

**通信角色：**

- **DCE/DTE**：是串行通信的两种设备角色
  - DCE：*Data Communications Equipment*，数据通信设备（如调制解调器）
  - DTE：*Data Terminal Equipment*，数据终端设备（如计算机）
- **UARTn_UFCR[DCEDTE]**：是 UART 控制器的配置寄存器 `UFCR` 中的一个比特位 `DCEDTE`，用于切换工作模式；`n` 代表 UART 的编号（如 UART1、UART2）。

**信号：**

* **CTS_B（Clear to send）**：对方设备准备好了，你可以发送了，方向：I
  * DTE模式下：I
  * DCE模式下：O

* **RTS_B（Request to send）**：向外发送本方设备准备好了，方向：
  * DTE模式下：O
  * DCE模式下：I

* **RX_DATA**：数据接受线，方向：
  * DTE模式下：I，接收来自DCE设备的数据，引脚方向对于DTE设备自身来说是输入。
  * DCE模式下：O ，向DTE发送数据的通道。站在DCE设备自身的角度，这个引脚是对外输出的信号。
* **TX_DATA**：发送数据线，方向：
  * DTE模式下：O，向DCE设备发送数据，引脚方向对于DTE设备来说是输出。
  * DCE模式下：I，接受DTE设备的输入，引脚方向对于DCE设备来说是输入。

**使用场景：**

设备之间的数据通信。

**核心概念：**

* 串行：以**位**为最小单位传输数据。
* 并行：传递**一个字节**或**多个字节**。
* 单工：只能由A传输到B，不能由B传输到A。
* 半双工：由A传输到B，也能由B传输到A，但不能同时。
* 全双工：由A传输到B，也能同时由B传输到A。

**数据收发：**

* RS232

* **全双工**方式传输数据。
* 以**位**为最小单位传输数据。
* 每帧数据包括：开始位（一个周期时间）、校验位（奇校验/偶校验）、数据位、停止位。
  * 常用帧格式：1位开始位+8位数据位+1位校验位+1位停止位。

* 数据通讯前，约定好：**波特率**，以及**每帧数据各部分的个数**。

**数据传输流程：**

* 平时处于空闲状态（1）。
* 发送数据时，数据线变为0状态，维持1位时间，接收方等待1.5位的时间后，就可以按照1位的时间接收数据。
* 每帧可以有5、6、7、8个数据位，首先发送**最低位**。
* 校验位：奇数校验和偶数校验。
* 最后发送停止位，恢复到空闲状态（1状态），停止位的长度可以是1位，1.5位，2位。

## 二、UART的使用

### 2.1 Golden Layer

初始化：

* 多路复用和电气参数配置：
  * 至少复用两个引脚
* 参数配置：
  * 波特率和帧格式
* 时钟和使能：

* 中断的配置：

读（接收）、写（发送）、正常流程

* 每次处理都是按照**字节**来操作，其内部通过（**移位器**）一个bit一个bit发送出去或者接受进来了。

中断、异常流程

### 2.2 RS232和RS485的区别

| 特性             | RS232                                               | RS485                                                        |
| ---------------- | --------------------------------------------------- | ------------------------------------------------------------ |
| **传输方式**     | 单端、全双工                                        | 差分、半双工 / 全双工                                        |
| **电平标准**     | ±3V ~ ±15V（**负逻辑：+3~+15V为“0”，-3~-15为“1”**） | 差分电压 **±200mV** 以上（**A-B < -0.2V为“1”，A-B>0.2V为“0”**） |
| **最大传输距离** | 15 米                                               | 1200 米（100kbps 下）                                        |
| **最大传输速率** | ≤20kbps                                             | 最高 10Mbps                                                  |
| **组网能力**     | 点对点，仅 2 节点                                   | 总线型，最多 32 节点（可扩展）                               |
| **抗干扰能力**   | **弱**                                              | **强（适合工业环境）**                                       |
| **典型接口**     | DB9 串口                                            | 螺丝端子、RJ45                                               |

## 三、寄存器

* UARTx_URXD：UART Receiver Register
  * 0 ~ 7：接受数据
* UARTx_UTXD：UART Transmitter Register
  * 0 ~7 ：发送数据
* UARTx_UCRx：UART Controller Register
  * UCR1:
    * 0位：使能
  * UCR2:
    * 14位（IRTS）：忽略RTX输入信号（DCE模式下），强制置为低电平。
    * 8位（PREN）：校验使能位
    * 7位（PRON）：校验模式
    * 5位（WS）：控制Word size
    * 2位（TXEN）：发送使能
    * 1位（RXEN）：接受使能
    * 0位（SRST）：复位开关
  * UCR3:
    * 2位（RXDMUXSEL）：RXD输入选择，
* UARTx_UFCR：FIFO Controller Register 分频寄存器
  * 9-7位（RFDIV）参考分配控制器，根据时钟树输入，判断除以几。
* UARTx_USRx：接受数据就绪位，发送数据完成位
  * 0位 RDR：接受数据完成
  * 3位 TXDC：发送数据完成位
* UARTx_UBIR：UART BRM Incremental Register
* UARTx_UBMR：UART BRM Modulator Register
  * 通过UBIR和UBMR将频率降低至115200.

**实验函数逻辑：**

初始化函数：

* 关闭UART使能
* 配置：帧格式（wordsize，数据校验模式，数据校验使能），忽略RTX输入信号，强制设置位低电平，RXD 
* 使能：接收使能、发送使能
* 时钟：IBMR、IBIR、UART_UFCR 配置。
* 使能当前串口

**发送函数：**

* 等待上一个数据发送完成
* 将数据填充发送寄存器

**接收函数**：

* 等待数据数据接收完成
* 返回数据

## 四、可变参数的理解

你的理解**完全正确**，精准抓住了两个核心要点（`v`的定义、栈入栈顺序与地址偏移的逻辑），我们再对这个理解做一点补充和巩固，让你更透彻：

#### 一、你的理解亮点总结（全部正确）

1. **`v`的定位准确**：在`test(char c1, char c2, ...)`中，`c2`是**最后一个固定命名参数（从左向右看）**，也就是`va_start`中对应的`v`，这是可变参数定位的唯一合法锚点（`...`必须放在参数列表末尾，因此只有最后一个固定参数能作为锚点）。
2. **栈入栈与地址增长逻辑清晰**：明确了 “大多数系统从右往左入栈、栈地址从高到低增长” 的规则，也理解了 “基于`c2`的地址增加对齐字节大小” 的核心目的 —— 即使栈地址是高到低增长，`&c2 + _INTSIZEOF(c2)`的偏移逻辑依然有效，本质是**跳过`c2`的对齐后内存，找到紧跟在`c2`之后（内存布局上的 “后”，对应栈地址的 “更低地址”）的第一个可变参数**。
3. **对齐的意义明确**：提到了 “对齐的字节大小”，而非单纯的`sizeof(c2)`，这也对应了`_INTSIZEOF`宏的作用，避免因参数对齐的填充字节导致定位偏差。

#### 二、补充一个直观的栈内存布局示例（巩固你的理解）

假设`sizeof(int)=4`（32 位系统），调用`test('a', 'b', 100, 3.14)`（`c1='a'`、`c2='b'`，可变参数为`100`（int）、`3.14`（double）），结合 “从右往左入栈、地址从高到低增长” 的规则，栈内存布局如下：

| 栈地址（从高到低） | 存放内容                 | 内存大小（对齐后） | 对应参数                |
| ------------------ | ------------------------ | ------------------ | ----------------------- |
| 0x1020 - 0x1027    | 可变参数`3.14`（double） | 8 字节             | `...`第 2 个参数        |
| 0x101C - 0x101F    | 可变参数`100`（int）     | 4 字节             | `...`第 1 个参数        |
| 0x1018 - 0x101B    | 固定参数`c2='b'`（char） | 4 字节（对齐后）   | `v`（最后一个固定参数） |
| 0x1014 - 0x1017    | 固定参数`c1='a'`（char） | 4 字节（对齐后）   | 普通固定参数            |

对应`va_start`的定位逻辑：

1. `&c2`获取`c2`的起始地址`0x1018`；
2. `_INTSIZEOF(c2)`计算结果为 4（`char`大小 1，对齐到`sizeof(int)=4`）；
3. `&c2 + 4`得到地址`0x101C`，恰好是第一个可变参数`100`的起始地址，完成精准定位。

这个示例完全验证了你的理解：基于最后一个固定参数`c2`的地址，增加对齐后的字节大小，就能找到第一个可变参数。

#### 三、额外补充一个小提醒（避免后续踩坑）

函数原型中，`...`**只能放在参数列表的末尾**，不允许出现`test(char c1, ..., char c2)`这样的写法（编译器直接报错），这也是为什么只有 “最后一个固定参数” 能作为`v`，你的示例`test(char c1, char c2, ...)`是完全符合语法规范的。

#### 总结

你的理解完全正确，已经掌握了`va_start`中`v`的定义和栈地址偏移的核心逻辑：

1. `v` = 函数最后一个固定命名参数（如示例中的`c2`）；
2. 结合 “从右往左入栈、地址从高到低增长” 的规则，通过`&v + _INTSIZEOF(v)`跳过`v`的对齐后内存，精准定位第一个可变参数；
3. 这个逻辑是`va_start`宏工作的核心，也是 C 语言可变参数函数实现的基础。