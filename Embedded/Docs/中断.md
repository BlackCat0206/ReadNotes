# General Interrupt Controller

---- Chime Lee

## 一、概述

**GIC（General Interrupt Controller）：内存映射的外围设备**

**中断：**外部源相对于CPU的中断。 

**中断号**：32（CPU）+ 128 (外设中断) = 160个

**外部中断请求：**

`FIQ`、`IRQ`分别对应`cpsr`中的`I`和`F`位。通过`CPS IE`或`CPS ID`分别启动或禁用异常。

**中断控制器：**

* **分发器（*Distributor*）**：**接收**各种源的中断，通过**仲裁寄存器**控制各个中断属性，例如：**优先级、安全性、路由信息和使能状态**。把中断输出到”CPU接口单元“。中断状态从`pending 、active`转换为`inactive`状态，存储在**分发器寄存器**中。
* **CPU接口单元（CPU Interface）**：**屏蔽、识别和控制转发**CPU的中断状态，异常处理程序必须从**CPU接口单元寄存器查询中断ID**，并执行中断处理程序。

**中断源类型：**

* **SPI（*Shared Peripheral Interrupt*）共享中断**，所有内核共享外部中断，所有内核均可处理。
* **PPI （*Private Peripheral Interrupt*）私有中断**，GIC支持多核，每个内核
* **SGI（*Software-Generate Inpterrupt*）软件中断**

**触发条件：**

* 高电平
* 低电平 
* 上升沿
* 下降沿
* 双边沿

**处理中断的步骤：**

* ARM核自动处理流程：
  * 将当前PC存储到LR_IRQ中。
  * CPSR的内容被复制到SPSR_IRQ中。
  * CPSR内容被更新，设置模式为IRQ，I位屏蔽其它IRQ。
  * PC被设置为向量表中IRQ的入口（向量表及地址偏移`0x18`）。
* 执行向量表中IRQ入口（中断异常分支）的指令。
* 中断处理程序保存被中断的上下文：将被中断程序的所有寄存器入栈。
* 中断处理程序确认中断源，调用执行对应处理流程。
* 恢复现场：
  * 将SPSR_IRQ复制到CPSR
  * 还原上下文。
  * CPU核切换到之前执行状态。
  * 从LR_IRQ恢复PC。

**嵌套中断处理：**

Linux系统中，不支持中断嵌套。

**向量表**：

对于ARM，向量表的地址是不确定的，通过软件设置到VBAR中，基地址一旦确定，每个**异常的偏移的是固定的**。

## 二、操作流程

### 2.1 初始化和使能：

GIC的分发器和CPU接口在**复位后默认禁用**。

**配置分发器：**

* 配置**中断的优先级**、**指定发送给CPU核**，**设置安全属性**，**再逐个开启这些中断**。(优先级、路由信息、安全属性、使能)
* 再通过分发器的**控制寄存器**，把**分发器整个打开**。

**配CPU接口：**

* 配置CPU接口**优先级**和**抢占规则**。
* 通过CPU**接口控制器**，把**接口本身打开**。

**让CPU使能中断：**

* 在**向量表**中存放好**中断处理程序**的**入口地址**，通过协处理命令（mcr）将其设置到向量表地址寄存器中（VBAR）。
* **清除**CPU状态寄存器（CPSR）中的**中断屏蔽位**。
* 通过`cpsie i`使能CPU中断使能。

**一个中断真正可以触发CPU：**

**中断自身使能+分发器使能+CPU接口使能+CPU中断屏蔽位清空。**

### 2.2 中断的处理过程：

**GIC结构下、CPU核处理单个中断的完成流程分4步**

* **查询中断ID并更新状态**：中断处理程序会读取CPU接口单元的**中断应答寄存器**，从而获取中断ID。读操作会自动让分发器该中断变为`active`，避免重复触发。
* **调用对应处理函数**：根据中断ID，中断处理程序调用对应处理函数。
* **结束中断并更新状态**：中断处理结束后，中断处理程序将相同的中断ID写入CPU接口单元中断结束寄存器中，这一步将该中断的`active`状态变为`inactive`或`pending`状态，让CPU接口继续发送待处理的中断。
* **循环处理直至无中断：**因为CPU一次只能传一个中断，故充分上述步骤；直到读到**中断ID 1023**（伪中断ID），代表当前CPU已经没有待处理的中断了。

### 2.3 相关寄存器

协处理器：存储系统通常是**协处理器CP15**完成的，它有16个32位寄存器，编号0~15。

* 协处理器指令MRC：把协处理器的数据读取到ARM通用寄存器中。

  ```bash
  MRC{条件码} 协处理器编号, 操作码1, 目标ARM寄存器, 协处理器寄存器CRn, 协处理器寄存器CRm, 操作码2
  ```

* 协处理器指令MCR：把ARM通用寄存器数据写入协处理器寄存器。

  ```bash
  MCR{条件码} 协处理器编号, 操作码1, 源ARM寄存器, 协处理器寄存器CRn, 协处理器寄存器CRm, 操作码2
  ```

GPIO中断实验用如下内容：

**向量表：**

* **设置基地址**：**SCTLR**（**System Control Register**）寄存器：

* **设置向量表地址**：**VBAR**（**Vector Base Address**）寄存器：

**GPIO：**

* 中断配置寄存器
* 中断状态寄存器
* 中断屏蔽寄存器
* 边沿选择寄存器

**修正IRQ中断返回地址：**

ARM核采用三级流水线：取址（Fetch）-译码(Decode)-执行(Excute)

* 当 CPU 执行指令`Inst_n`时，已经取好了`Inst_n+1`、译码了`Inst_n+2`；
* 当 IRQ 中断触发时，CPU 会立刻停止当前指令执行，硬件自动把 “**下一条要取的指令地址**” 存入`lr_irq`（也就是`Inst_n+2`的地址）；
* 中断处理结束后，我们需要回复到“被中断指令”（`Inst_n+1`）继续执行，而不是`Inst_n+2`。

```bash
.align 2
IRQ_Handler:
	/* 执行到这里之前:
	 * 1. lr_irq保存有被中断模式中的下一条即将执行的指令的地址
	 * 2. SPSR_irq保存有被中断模式的CPSR
	 * 3. CPSR中的M4-M0被设置为10010, 进入到irq模式
	 * 4. 跳到0x18的地方执行程序 
	 */

	/* 保存现场 */
	/* 在irq异常处理函数中有可能会修改r0-r12, 所以先保存 */
	/* lr-4是异常处理完后的返回地址, 也要保存 */
	
	// 修复“修正IRQ中断的返回地址”
	sub lr, lr, #4
	// stm： Stor Multiple 批量存储
    // db：Decrement Before：先递减栈指针再存储数据
    // sp!，sp是栈指针寄存器，！表示回写；执行完指令后，把更新后的栈指针回写给sp
    // {r0-r12, lr} 要存储的寄存器列表,为了保证出栈的顺序，寄存器从大到小入栈
    stmdb sp! {r0-r12, lr}
	
	/* 处理irq异常 */
	bl handle_irq_c
	
	/* 恢复现场 */
	// ldm: load Multiple 批量加载
	// ia: Increment After 先加载数据，再递增指针
	// sp!: 回写，执行结束后sp更新到栈指针寄存器
	// {r0-r12, pc} 要恢复的寄存器列表，从左向右
	// ^特权后缀：把spsr的值恢复到cpsr中
	ldmia sp!, {r0-r12, pc}^  /* ^会把spsr_irq的值恢复到cpsr里 */
	
.align 2
Reset_Handler:
	/* Reset SCTlr Settings */
	mrc 	p15, 0, r0, c1, c0, 0	  /* read SCTRL, Read CP15 System Control register		*/
	/*bit clean*/
	bic 	r0,  r0, #(0x1 << 13)	  /* Clear V bit 13 to use normal exception vectors  	*/
	bic 	r0,  r0, #(0x1 << 12)	  /* Clear I bit 12 to disable I Cache					*/
	bic 	r0,  r0, #(0x1 <<  2)	  /* Clear C bit  2 to disable D Cache					*/
	bic 	r0,  r0, #(0x1 << 2)	  /* Clear A bit  1 to disable strict alignment 		*/
	bic 	r0,  r0, #(0x1 << 11)	  /* Clear Z bit 11 to disable branch prediction		*/
	bic 	r0,  r0, #0x1			  /* Clear M bit  0 to disable MMU						*/
	mcr 	p15, 0, r0, c1, c0, 0	  /* write SCTRL, Write to CP15 System Control register	*/
	
	/* ARM有多用运行模式，触发异常时会自动切换，复位后所有模式公用一个sp。避免栈冲突：IRQ保存的上下文不会覆盖覆盖其他模式的数据。 */
    cps     #0x1B                /* Enter undef mode                */
    ldr     sp, =0x80300000     /* Set up undef mode stack      */

    cps     #0x12                /* Enter irq mode                */
    ldr     sp, =0x80400000     /* Set up irq mode stack      */

    cps     #0x13                /* Enter Supervisor mode         */
    ldr     sp, =0x80200000     /* Set up Supervisor Mode stack  */
	
	// 加载向量表，写入映射向量表地址
	ldr r0, =_vector_table
	mcr p15, 0, r0, c12, c0, 0  /* set VBAR, Vector Base Address Register*/
	//mrc p15, 0, r0, c12, c0, 0  //read VBAR

	bl clean_bss

	bl system_init
	
	// 使能中断
	cpsie	i					 /* Unmask interrupts			  */

	bl main

halt:
	b  halt


clean_bss:
	/* 清除BSS段 */
	ldr r1, =__bss_start
	ldr r2, =__bss_end
	mov r3, #0
clean:
	cmp r1, r2
	strlt r3, [r1]
	add r1, r1, #4
	blt clean
	
	mov pc, lr
```

## 三、实验

### 3.1 SR04超声波

**实验步骤：**

* 触发：向`Trig`发送**`10us`的高电平**。
* 发出超声波，接收反射信号：模块发出8个**`40kHz`的超声波**，超声波遇到障碍物后反射回来，模块收到返回的超声波。
* **回响（中断）**：模块接收返回的超声波，Echo引脚输出一个与**检测距离程正比的高电平**。

在引脚变为高电平时计时，通过超声波的速率进行对应计算。

### 3.2 步进电机

**概述**：28BYJ-48

* 28：步进电机的有效最大外径是 28 毫米

*  B：表示是步进电机

*  Y：表示是永磁式

*  J：表示是减速型（减速比 1:64）

* 48：表示四相八拍
  * **四相**：定子有8个齿，每个齿上缠绕一个**线圈绕阻**，**正对的两个齿是串联的，正对2组会同时导通和关闭，如此形成了4相**。
  * **驱动逻辑**：依次单独导通 **B→A→D→C** 四相绕组，每导通一相，转子就会顺时针转动至与该**相定子对齐**；若要逆时针转动，改为依次导通 **B→C→D→A**。
  * **步进角度与圈数**：完成 1 组 `B-A-D-C` 四节拍，转子转过 **1/8 圈**（45°）；转动 1 整圈需要 8 组四节拍（共 32 拍），**单步转角 = 360° ÷ (8×4) = 11.25°**，转弯一圈需要4*8 = **32步**。
  * **八拍**：八拍模式 = 单相导通步 + 两相导通过渡步，遵循 **“单相→两相→单相”** 的节奏。在四节拍**相邻单向导通之间，插入两项同时导通的过渡步**，形成八步，每步转**5.625°**。转完一圈需要：8*8 = **64步。**
    * **顺时针逻辑**：B-> B+A -> A -> A+D -> D -> D+C -> C -> C+B
    * **逆时针逻辑**：B-> B+C -> C -> C+D -> D -> D+A -> A -> A+ B
  * 注：B->A->D->C 这个顺序不用太在意，一般电机厂家就是A->B->C->D这样或者DCBA。

**信号序列**：**0表示导通了**

|      | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| D    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 0    |
| C    | 1    | 0    | 0    | 0    | 1    | 1    | 1    | 1    |
| B    | 1    | 1    | 1    | 0    | 0    | 0    | 1    | 1    |
| A    | 1    | 1    | 1    | 1    | 1    | 0    | 0    | 0    |

**逻辑真值表**：Z表示高阻态(1)，OUTB1、OUTA 不能同时输出1，

| INAx | INBx | OUTAx | OUTBx |
| ---- | ---- | ----- | ----- |
| L    | L    | Z     | Z     |
| H    | L    | H     | L     |
| L    | H    | L     | H     |
| H    | H    | L     | L     |

**倒推输入信号**：

| ...          | 1     | 2     | 3     | 4     | 5     | 6     | 7     | 8     |
| ------------ | ----- | ----- | ----- | ----- | ----- | ----- | ----- | ----- |
| D            | 0     | 0     | 1     | 1     | 1     | 1     | 1     | 0     |
| C            | 1     | 0     | 0     | 0     | 1     | 1     | 1     | 1     |
| B            | 1     | 1     | 1     | 0     | 0     | 0     | 1     | 1     |
| A            | 1     | 1     | 1     | 1     | 1     | 0     | 0     | 0     |
| **OUTB2**    | **0** | **0** | **1** | **1** | **Z** | **Z** | **Z** | **0** |
| OUTA2        | 1     | 0     | 0     | 0     | Z     | Z     | Z     | 1     |
| OUTB1        | Z     | Z     | Z     | 0     | 0     | 0     | 1     | 1     |
| OUTA1        | Z     | Z     | Z     | 1     | 1     | 0     | 0     | 0     |
| **INB2**     | **0** | **1** | **1** | **1** | **0** | **0** | **0** | **0** |
| INA2         | 1     | 1     | 0     | 0     | 0     | 0     | 0     | 1     |
| INB1         | 0     | 0     | 0     | 0     | 0     | 1     | 1     | 1     |
| INA1         | 0     | 0     | 0     | 1     | 1     | 1     | 0     | 0     |
| **GPIO4_22** | **0** | **1** | **1** | **1** | **0** | **0** | **0** | **0** |
| GPIO4_21     | 1     | 1     | 0     | 0     | 0     | 0     | 0     | 1     |
| GPIO4_20     | 0     | 0     | 0     | 0     | 0     | 1     | 1     | 1     |
| GPIO4_19     | 0     | 0     | 0     | 1     | 1     | 1     | 0     | 0     |
| **NUM[3:0]** | **4** | **C** | **8** | **9** | **1** | **3** | **2** | **6** |
