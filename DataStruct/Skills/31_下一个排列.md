# 31_下一个排列

---- Lee

## 一、题目

整数数组的一个 **排列** 就是将其所有成员以序列或线性顺序排列。

- 例如，`arr = [1,2,3]` ，以下这些都可以视作 `arr` 的排列：`[1,2,3]`、`[1,3,2]`、`[3,1,2]`、`[2,3,1]` 。

整数数组的 **下一个排列** 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 **下一个排列** 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。

- 例如，`arr = [1,2,3]` 的下一个排列是 `[1,3,2]` 。
- 类似地，`arr = [2,3,1]` 的下一个排列是 `[3,1,2]` 。
- 而 `arr = [3,2,1]` 的下一个排列是 `[1,2,3]` ，因为 `[3,2,1]` 不存在一个字典序更大的排列。

给你一个整数数组 `nums` ，找出 `nums` 的下一个排列。

必须**[ 原地 ](https://baike.baidu.com/item/原地算法)**修改，只允许使用额外常数空间。

**示例 1：**

```
输入：nums = [1,2,3]
输出：[1,3,2]
```

**示例 2：**

```
输入：nums = [3,2,1]
输出：[1,2,3]
```

**示例 3：**

```
输入：nums = [1,1,5]
输出：[1,5,1]
```

**提示：**

- `1 <= nums.length <= 100`
- `0 <= nums[i] <= 100`

## 二、思路

**什么是字典序**？

字典序和查字典的顺序一致，对数字数组来说，**从左到右依次比较数字大小**，**先出现更大数字**的排列，整体字典序更大。

比如数组 `[1,2,3]`，它的所有排列按字典序从小到大排列是：

`123` → `132` → `213` → `231` → `312` → `321`

这就是题目中 “下一个排列” 的本质：找**比当前大的排列中最小的那个**。

**如何操作呢**？

排列 [1,3,5,4,2] 的下一个排列是什么？

* 如果 1,3,5 保持不变，只重新排列 4,2，得到 2,4。排列变小了，这不行。
* 如果 1,3 保持不变，只重新排列 5,4,2，由于 5 右边都是小于 5 的数，所以重排后，5 这个位置上的数必然变小，导致排列变小，这也不行。
* 如果 1 保持不变，只重新排列 3,5,4,2，这是可以的，**因为 3 右边有比 3 大的数，重排后可以让 3 这个位置上的数变大，从而得到更大的排列。**
* 由于要求的是下一个排列，所以 3 这个位置上的数只要「大一点点」就好了。**找到 3 右边最小的大于 3 的数，也就是 4，放到 3 这个位置上。于是，下一个排列是 [1,4,_,_,_]。**
* _剩余的三个数是 2,3,5。由于只看前两位 [1,4,_,_,_] 就已经比 [1,3,5,4,2] 大了，所以后三位填最小的排列就行，即按照 2,3,5 的顺序填，得到 [1,4,2,3,5]。

**简化上述过程**：

* 从右向左，找到**第一个小于右侧相邻数字的数`x`**，**x的右边是递减的**。
* 找到右边**最小的大于`x`的数`y`**，交换`x`和`y`。交换后，**y的依然是递减的**。
* **反转`y`右边的数**，把右边的数变成最小的排列。

## 三、代码

```cpp
class Solution {
public:
    void nextPermutation(vector<int>& nums) {
        int n = nums.size();

        // step1：从右向左找到第一个小于右侧相邻数字的数nums[i]
        int i = n - 2;
        while (i >= 0 && nums[i] >= nums[i + 1]){
            i--;
        }

        // 找到了，进入第二步，找不到，进入第三步，反转这个数组
        if (i >= 0){
            // 找到右边最小的大于nums[i]的元素nums[j]
            int j = n - 1;
            while (nums[j] <= nums[i]){
                j--;
            }

            // 交换nums[i]和nums[j]
            swap(nums[i], nums[j]);
        }

        // 第三步，反转[i + 1, n - 1]
        reverse(nums.begin() + i + 1, nums.end());
    }
};
```

