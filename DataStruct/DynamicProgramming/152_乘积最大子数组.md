# 152_乘积最大子数组

---- Lee

## 一、题目

给你一个整数数组 `nums` ，请你找出数组中乘积最大的非空连续 子数组（该子数组中至少包含一个数字），并返回该子数组所对应的乘积。

测试用例的答案是一个 **32-位** 整数。

**请注意**，一个只包含一个元素的数组的乘积是这个元素的值。

**示例 1:**

```
输入: nums = [2,3,-2,4]
输出: 6
解释: 子数组 [2,3] 有最大乘积 6。
```

**示例 2:**

```
输入: nums = [-2,0,-1]
输出: 0
解释: 结果不能为 2, 因为 [-2,-1] 不是子数组。
```

**提示:**

- `1 <= nums.length <= 2 * 104`
- `-10 <= nums[i] <= 10`
- `nums` 的任何子数组的乘积都 **保证** 是一个 **32-位** 整数

## 二、思路

**动态规划五部曲**：

* **确认`dp`数组与其下标的含义**：
  * `dp_max[i]`表示数组**以第`i`元素`nums[i]`结尾的子数组的最大乘积**。
  * `dp_min[i]`表示数组**以第`i`元素`nums[i]`结尾的子数组的最小乘积**。

* **状态转移方程**：

  因为负数会让最大变最小、最小变最大，所以每一步需要同时计算两者：

  ```cpp
  dp_max[i] = max(nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i])
  dp_min[i] = min(nums[i], dp_max[i-1] * nums[i], dp_min[i-1] * nums[i])
  ```

  * 选 `nums[i]`：表示重新开始一个子数组（比如前序乘积为负，单独选当前数更优）

  * 选 `dp_max[i-1] * nums[i]`：前序最大乘积延续到当前

  * 选 `dp_min[i-1] * nums[i]`：前序最小乘积（负数）乘当前负数，可能得到大正数

* **初始化**：

  * `dp_max[0] = nums[0]`
  * `dp_min[0] = nums[0]`

* **遍历**：从前向后遍历（`i` 从 1 到 `nums.size()-1`），因为每个位置只依赖前一个位置的结果

* 针对 `[-2, 3, -4]` 的推导过程

|  i   | `nums[i]` | `pre_max` | `pre_min` | cur_max (`dp_max[i]`) | cur_min (`dp_min[i]`) | result |
| :--: | :-------: | :-------: | :-------: | :-------------------: | :-------------------: | :----: |
|  0   |    -2     |    -2     |    -2     |          -2           |          -2           |   -2   |
|  1   |     3     |    -2     |    -2     |   max(3, -6, -6)=3    |   min(3, -6, -6)=-6   |   3    |
|  2   |    -4     |     3     |    -6     |  max(-4, -12, 24)=24  | min(-4, -12, 24)=-12  |   24   |

## 三、代码

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if (nums.size() == 0){
            return 0;
        }
        
        vector<int> dp_max(nums.size());
        vector<int> dp_min(nums.size());
        dp_max[0] = nums[0];
        dp_min[0] = nums[0];
        int result = nums[0];

        for (int i = 1; i < nums.size(); i++){
            int temp_max = nums[i] * dp_max[i - 1];
            int temp_min = nums[i] * dp_min[i - 1];

            dp_max[i] = max({temp_max, nums[i], temp_min});
            dp_min[i] = min({temp_max, nums[i], temp_min});

            result = max(dp_max[i], result);
        }
        return result;

    }
};
```

* 时间复杂度：O(N)
* 空间复杂度：O(N)

优化：空间复杂度O(1)

```cpp
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        if (nums.size() == 0){
            return 0;
        }
      
        int pre_max = nums[0];
        int pre_min = nums[0];
        int result = nums[0];

        for (int i = 1; i < nums.size(); i++){
            int temp_max = nums[i] * pre_max;
            int temp_min = nums[i] * pre_min;

            int cur_max = max({temp_max, nums[i], temp_min});
            int cur_min = min({temp_max, nums[i], temp_min});

            pre_max = cur_max;
            pre_min = cur_min;
            result = max(cur_max, result);
        }
        return result;

    }
};
```

