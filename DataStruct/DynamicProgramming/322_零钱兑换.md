# 322_零钱兑换

---- Lee

## 一、题目

给你一个整数数组 `coins` ，表示不同面额的硬币；以及一个整数 `amount` ，表示总金额。

计算并返回可以凑成总金额所需的 **最少的硬币个数** 。如果没有任何一种硬币组合能组成总金额，返回 `-1` 。

你可以认为每种硬币的数量是无限的。

**示例 1：**

```
输入：coins = [1, 2, 5], amount = 11
输出：3 
解释：11 = 5 + 5 + 1
```

**示例 2：**

```
输入：coins = [2], amount = 3
输出：-1
```

**示例 3：**

```
输入：coins = [1], amount = 0
输出：0
```

**提示：**

- `1 <= coins.length <= 12`
- `1 <= coins[i] <= 231 - 1`
- `0 <= amount <= 104`

## 二、思路

**动态规划五部曲**：

* 确认`dp`数组及其下标的含义：`dp[j]`为了凑足金额`j`所需的硬币最少个数。
* 递推公式：`dp[j] = min(dp[j], dp[j - coins[i]] + 1);` 
  * 考虑使用当前硬币：总额减去**当前硬币**：`j - coins[i]`, 其所需最小个数是`dp[j - coins[i]]`，在加上当前硬币`dp[j - coins[i] + 1`，就是`dp[j]`。
  * `dp[j]`要取最小的`dp[j - coins[i] + 1`
* 如何初始化：
  * `dp[0] = 0`
  * 其余元素为`amont + 1`，无法到达元素（若有1硬币，凑出amount，最多就要amount，不会更多了）。
* 如何遍历：
  * 先遍历金额：从1到amount
  * 遍历硬币，硬币的大小 < 遍历的金额
* 推导：coins = [1, 2, 5], amount = 11

| 金额 | 硬币 | `dp`                     |
| ---- | ---- | ------------------------ |
| 1    | 1    | **1**                    |
| 2    | 1    | 2                        |
| 2    | 2    | **1**                    |
| 3    | 1    | 3                        |
| 3    | 2    | `min(12, dp[1] + 1) = 2` |
| 4    | 1    | 4                        |
| 4    | 2    | 2                        |
| .... |      |                          |
| 11   | 5    | min(12, dp[6] + 1) = 3   |

## 三、代码

```cpp
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        vector<int> dp(amount + 1, amount + 1);
        dp[0] = 0;

        for (int i = 1; i <= amount; i++){
            for (int coin : coins){
                // 硬币大小 <= 当前金额
                if (coin <= i){
                    dp[i] = min(dp[i], dp[i - coin] + 1);
                }
            }
        }
        dp[amount] = (dp[amount] == amount + 1) ? -1 : dp[amount];
        return dp[amount];
    }
};
```

