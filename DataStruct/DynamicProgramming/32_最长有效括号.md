# 32_最长有效括号

---- Lee

## 一、题目

给你一个只包含 `'('` 和 `')'` 的字符串，找出最长有效（格式正确且连续）括号 子串 的长度。

左右括号匹配，即每个左括号都有对应的右括号将其闭合的字符串是格式正确的，比如 `"(()())"`。

**示例 1：**

```
输入：s = "(()"
输出：2
解释：最长有效括号子串是 "()"
```

**示例 2：**

```
输入：s = ")()())"
输出：4
解释：最长有效括号子串是 "()()"
```

**示例 3：**

```
输入：s = ""
输出：0
```

**提示：**

- `0 <= s.length <= 3 * 104`
- `s[i]` 为 `'('` 或 `')'`

## 二、思路

动态规划五部曲：本地动态规划个人觉得有些局限了。换一个解法

**栈匹配**：

* **哨兵节点**：压入一个`-1`作为起点，实现`i - stack.top()`计算有效长度。

* **状态转换**：考虑到`())()`这类字符串，不能用`stack`压入元素进行匹配，而应该**压入左括号的下标和不匹配的右括号**。
  * 左括号：直接压栈
  * 右括号匹配后，弹出左括号下标，**当前下标`i - stack.top()`，`stack.top()`上一个不匹配元素的下标**。记录最大值。
  * 右括号不匹配：直接更新`statck.top()`。

## 三、代码

```cpp
class Solution {
    stack<char> m_st;
public:
    int longestValidParentheses(string s) {
        if (s.size() <= 1){
            return 0;
        }

        stack<int> stIndex;
        stIndex.push(-1);
        int ans = 0;
        for (int i = 0; i < s.size(); ++i){
            if ('(' == s[i]){       // 左括号
                stIndex.push(i);
            } else if (stIndex.size() > 1){ // 右括号且栈不为空
                stIndex.pop();              // 弹出匹配的左括号下标
                ans = max(ans, i - stIndex.top());  // 计算有效长度
            } else {                        // 右括号不匹配
                stIndex.top() = i;          // 更新栈顶
            }
        }

        return ans;
    }
};
```

- 时间复杂度：O(*n*)，其中 *n* 是 *s* 的长度。
- 空间复杂度：O(*n*)。栈保存 O(*n*) 个下标，需要 O(*n*) 的空间。