# 300_最长递增子序列

---- Lee

## 一、题目

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?

## 二、思路

**动态规划五部曲**：

* 确认`dp`数组及其下标的含义：`dp[i]`表示数**以`nums[i]`结尾**的最长递增子序列长度。

* 状态转移方程：`if (num[i] > num[j]){dp[j] = max(dp[j], dp[i] + 1)}`

  * 位置`i`的最长递增子序列等于`j`从0到`i-1`各个位置的最长递增序列+1的值。

* `dp[i]`初始化：每一个对应的`dp[i]`起始大小至少是1。

* 遍历顺序：

  * `dp[i]`是由`0`到`i  - 1`各个位置最长递增子序列推导而来，那么遍历`i`一定是从前向后。
  * j就是遍历`0`到`i - 1`，从前向后。

* 推导：`[0,1,0,3,2]`

  | 下标  | 0    | 1    | 2    | 3    | 4     |
  | ----- | ---- | ---- | ---- | ---- | ----- |
  | i = 1 | 1    | 2    | 1    | 1    | 1     |
  | i = 2 | 1    | 2    | 1    | 1    | 1     |
  | i = 3 | 1    | 2    | 1    | 3    | 1     |
  | i = 4 | 1    | 2    | 1    | 3    | **3** |

**贪心 + 二分法**：（时间复杂度：O(n log(n))）更符合直觉

* 维护一个贪心数组`tails`，`tails[i]`表示长度为`i+1`的递增子序列的最小可能末尾元素。
* 遍历数组：
  * 如果元素大于`tails`最后一个元素，追加到末尾。
  * 如果元素不大于，用**二分法查找**`tails`中第**一个大于等于该元素的位置**，替换它。

* 最终`tails`的长度就是最大递增子序列的长度。

## 三、代码

```cpp
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1){
            return nums.size();
        }

        vector<int> dp(nums.size(), 1);
        int result = 0;
        for (int j = 1; j < nums.size(); j++){
            for (int i = 0; i < j; ++i){
                if (nums[j] > nums[i]){
                    dp[j] = max(dp[j], dp[i] + 1);
                }
            }
            // 取最长序列
            if (dp[j] > result){
                result = dp[j];
            }
        }
        return result;
        
    }
};
```

- 时间复杂度: O(n^2)
- 空间复杂度: O(n)

**优化时间负复杂度：O(`nlogn`)**

* 维护一个贪心数组`tails`，`tails[i]`表示长度为`i+1`的递增子序列的最小可能末尾元素。
* 遍历数组：
  * 如果元素大于`tails`最后一个元素，追加到末尾。
  * 如果元素不大于，用**二分法查找**`tails`中第**一个大于等于该元素的位置**，替换它。

* 最终`tails`的长度就是最大递增子序列的长度。

```cpp
class Solution {
    int lowerBoundCustom(vector<int>&nums, int traget){
    if (nums.size() == 0){
        return 0;
    }
    int left = 0;
    int right = nums.size() - 1;
    while (left <= right){
        int mid = left + (right - left) / 2;
        if (nums[mid] < traget){
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return left;
    }
public:
    int lengthOfLIS(vector<int>& nums) {
        if (nums.size() <= 1){
            return nums.size();
        }

        vector<int> tails;
        for (int num : nums){
            int size = tails.size();
            int index = lowerBoundCustom(tails, num);
            if (index >= size){
                tails.push_back(num);
            }
            else{
                tails[index] = num;
            }
        }
        return tails.size();
    }
};
```

