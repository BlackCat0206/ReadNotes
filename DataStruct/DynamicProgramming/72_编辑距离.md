# 72_编辑距离

---- Lee

## 一、题目

给你两个单词 `word1` 和 `word2`， *请返回将 `word1` 转换成 `word2` 所使用的最少操作数* 。

你可以对一个单词进行如下三种操作：

- 插入一个字符
- 删除一个字符
- 替换一个字符

**示例 1：**

```
输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
```

**示例 2：**

```
输入：word1 = "intention", word2 = "execution"
输出：5
解释：
intention -> inention (删除 't')
inention -> enention (将 'i' 替换为 'e')
enention -> exention (将 'n' 替换为 'x')
exention -> exection (将 'n' 替换为 'c')
exection -> execution (插入 'u')
```

**提示：**

- `0 <= word1.length, word2.length <= 500`
- `word1` 和 `word2` 由小写英文字母组成

## 二、思路

**动态规划五部曲**：

* 确认`dp`数组及其下标的含义：`dp[i][j]`表示以下标`i - 1`为结尾的字符串`word1`，以下标`j - 1`结尾的字符串`word2`，最近的编辑距离。

* 状态转换方程：

  * 若`word1[i - 1] == word2[j - 1]`：`dp[i][j] = dp[i - 1][j - 1]`;
  * 若`word1[i - 1]  != word2[j - 1]`：`dp[i][j] = min(dp[i - 1][j], dp[i][j], dp[i][j - 1]) + 1`;
    * 增：`dp[i][j - 1] + 1`
    * 删：`dp[i - 1][j] + 1`
    * 换：`dp[i - 1][j - 1] + 1`

  ```cpp
  if (word1[i - 1] == word2[j - 1]){
      dp[i][j] = dp[i - 1][j - 1];
  } else {
      dp[i][j] = min(dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]) + 1;
  }
  ```

* 初始化：

  * `word1`对于空串的转换：`dp[i][0] = i`
  * `word2`对于空串的转换：`dp[0][j] = j`

* 如何遍历：从上到下，从前向后

* 推导：

|      | 空串 | r    | o    | s    |
| ---- | ---- | ---- | ---- | ---- |
| 空串 | 0    | 1    | 2    | 3    |
| h    | 1    | 1    | 2    | 3    |
| o    | 2    | 2    | 1    | 3    |
| r    | 3    | 2    | 2    | 2    |
| s    | 4    | 3    | 3    | 2    |
| e    | 5    | 4    | 4    | 3    |

## 三、代码

```cpp
class Solution {
public:
    int minDistance(string word1, string word2) {
        vector<vector<int>> dp(word1.size() + 1, vector<int>(word2.size() + 1, 0));
        for (int i = 0; i <= word1.size(); i++){
            dp[i][0] = i;
        }
        for (int j = 0; j <= word2.size(); j++){
            dp[0][j] = j;
        }

        for (int i = 1; i <= word1.size(); i++){
            for (int j = 1; j <= word2.size(); j++){
                if (word1[i - 1] == word2[j - 1]){
                    dp[i][j] = dp[i - 1][j - 1];
                } else {
                    dp[i][j] = min({dp[i - 1][j], dp[i - 1][j - 1], dp[i][j - 1]}) + 1;
                }
            }
        }
        return dp[word1.size()][word2.size()];
    }
};
```

