# 139_单词拆分

---- Lee

## 一、题目

给定一个非空字符串 s 和一个包含非空单词的列表 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

说明：

拆分时可以重复使用字典中的单词。

你可以假设字典中没有重复的单词。

示例 1：

- 输入: s = "leetcode", wordDict = ["leet", "code"]
- 输出: true
- 解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。

示例 2：

- 输入: s = "applepenapple", wordDict = ["apple", "pen"]
- 输出: true
- 解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
- 注意你可以重复使用字典中的单词。

示例 3：

- 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
- 输出: false

## 二、思路

**动态规划五部曲**：

* 物品：单词，背包：字符串。

* **确认`dp`数组以及下标的函数**：**`dp[i]`表示字符串`s`前`i`个字符组成的子串，是否可以被拆分为单词**。
* **推导公式：**`dp[i] = (dp[j] == true && word.substr(j, i - 1) 存在于 wordDirt);`
  * 如果确定`dp[j]`是true，且`[j, i - 1]`处存在于`wordDict`中，j < i。dp[i] = true;
  * `dp[i] = (dp[j] == true && word.substr(j, i - 1) 存在于 wordDirt);`
* **如何初始化**？：
  * `dp[0] = true`，空字符串，逻辑的起点。
* **如何遍历：**
  * 遍历字符串，对其每个位置`i`，遍历所有可能的拆分点`j`（j < i）。满足两个条件，则`dp[j] = true`
  * `dp[j] = true`：前`j`个字符可拆分；
  * `子串[j:i-1]`存在于`wordDict`中

* 推导：
* ...

**拓展**：使用hash表加速查找`unordered_set`

## 三、代码

```cpp
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> wordSet(wordDict.begin(), wordDict.end());
        
        vector<bool> dp(s.size() + 1, false);
        dp[0] = true;

        for (int i = 1; i <= s.size(); i++)
        {
            for (int j = 0; j < i; ++j)
            {
                if (dp[j] == true && wordSet.count(s.substr(j, i - j))){
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```

