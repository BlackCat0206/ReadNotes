# 416_分割等和子集

---- Lee

## 一、题目

给你一个 **只包含正整数** 的 **非空** 数组 `nums` 。请你判断是否可以将这个数组分割成两个子集，使得两个子集的元素和相等。

**示例 1：**

```
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。
```

**示例 2：**

```
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
```

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 100`

## 二、思路

**01背包问题**：

物品：数字。

价值：数字的大小。

重量：等于价值，背包的重量 == sum/2，满足条件。

**动态规划五部曲**。

* **确认`dp`数组及其下标含义**：`dp[j]`表示容量为`j`的背包，所背的物品的最大价值是`dp[j]`.

* **状态转移方程**：
  * `dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);`

* **初始化**：
  * 全部初始化为0即可。
* **遍历方式**：
  * 先遍历物品：从前向后
  * 遍历背包：从后向前，每个元素只能一次。

## 三、代码

```cpp
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        if (nums.size() <= 1){
            return false;
        }
        // 01背包问题
        // 最大容量的一半 10001个
        vector<int> dp(10001, 0);

         int sum = 0;
        for (int i = 0; i < nums.size(); i++) {
            sum += nums[i];
        }
        if (1 == sum % 2){
            return false;
        }
        int target = sum / 2;

        for(int i = 0; i < nums.size(); i++) {
            for(int j = target; j >= nums[i]; j--) { 
                dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
            }
        }

        return (target == dp[target]);
    }
};
```

