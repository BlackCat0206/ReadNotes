# 64_最小路径和

给定一个包含非负整数的 `*m* x *n*` 网格 `grid` ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

**说明：**每次只能向下或者向右移动一步。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/05/minpath.jpg)

```
输入：grid = [[1,3,1],[1,5,1],[4,2,1]]
输出：7
解释：因为路径 1→3→1→1→1 的总和最小。
```

**示例 2：**

```
输入：grid = [[1,2,3],[4,5,6]]
输出：12
```

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 200`
- `0 <= grid[i][j] <= 200`

## 二、思路

**动态规划五部曲**：

* 确认`dp`数组及其下标的含义 ：`dp[i][j]`表示到达下标`i,j`的最小和。
* 状态转换公式：`dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1])`
  * 当前位置最小和：当前元素与上层元素、左侧元素的最小值。
* 如何初始化：
  * 第一行：逐个累加
  * 第一列：逐个累加
* 如何遍历：
  * 逐行从前到后。
* 推导：grid = [[1,3,1],[1,5,1],[4,2,1]]

| 1    | 4    | 5     |
| ---- | ---- | ----- |
| 2    | 7    | 6     |
| 6    | 8    | **7** |

## 三、代码

```cpp
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        if (0 == grid.size()){
            return 0;
        }
        int m = grid.size();
        int n = grid[0].size();
        vector<vector<int>> dp(m, vector<int>(n, 0));
        dp[0][0] = grid[0][0];

        for (int i = 1; i < m; i++){
            dp[i][0] = grid[i][0] + dp[i - 1][0];
        }

        for (int j = 1; j < n; j++){
            dp[0][j] = grid[0][j] + dp[0][j - 1];
        }

        for (int i = 1; i < m; i++){
            for (int j = 1; j < n; j++){
                dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[m - 1][n - 1];
    }
};
```

