# 118_杨辉三角

---- Lee

## 一、题目

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在**「杨辉三角」**中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode.cn/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```

**提示:**

- `1 <= numRows <= 30`

## 二、思路

| 行数 | dp内容     | 计算                                    |
| ---- | ---------- | --------------------------------------- |
| 1    | 1          | 1                                       |
| 2    | 1、1       | 1、1                                    |
| 3    | 1、2、1    | 1、`dp[i - 1][j] + dp[i - 1][j - 1]`、1 |
| 4    | 1、3、3、1 | 1、dp[1] + dp[0]、dp[2] + dp[1]、1      |

**动态规划五部曲：**

* 确认`dp`数组含义：二维数组表示三角的元素
* 递推公式：`dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1]`
* 如何初始化`dp`数组：`dp.resize(i + 1， 1)`；
* 遍历方式：从上到下，从前向后：`for (int i = 0; i < rows; ++i){ for (int j = 1; j < i; j++)}

* 举例推导：见上

## 三、代码

```cpp
class Solution {
public:
    vector<vector<int>> generate(int numRows) {
        vector<vector<int>> ans(numRows);
        for (int i = 0; i < numRows; ++i){
            ans[i].resize(i + 1, 1);
            for (int j = 1; j < i; ++j){
                ans[i][j] = ans[i - 1][j] + ans[i - 1][j - 1];
            }
        }
        return ans;
    }
};
```

