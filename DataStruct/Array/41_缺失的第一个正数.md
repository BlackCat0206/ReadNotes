# 41_缺失的第一个正数

---- Lee

## 一、题目

给你一个未排序的整数数组 `nums` ，请你找出其中没有出现的最小的正整数。

请你实现时间复杂度为 `O(n)` 并且只使用常数级别额外空间的解决方案。

**示例 1：**

```
输入：nums = [1,2,0]
输出：3
解释：范围 [1,2] 中的数字都在数组中。
```

**示例 2：**

```
输入：nums = [3,4,-1,1]
输出：2
解释：1 在数组中，但 2 没有。
```

**示例 3：**

```
输入：nums = [7,8,9,11,12]
输出：1
解释：最小的正数 1 没有出现。
```

**提示：**

- `1 <= nums.length <= 105`
- `-231 <= nums[i] <= 231 - 1`

[力扣题目链接](https://leetcode.cn/problems/first-missing-positive/description/?envType=study-plan-v2&envId=top-100-liked)

## 二、思路

* 每日一遍：感谢灵神ಥ_ಥ
* 将数组中的大于0的元素，按照其元素本身移动至数组对应下标。例：`i`位置的元素`nums[i] == i`。
* 不在[1, n]范围内的元素不考虑。
* 交换完成后，从左向右看，第一个下标和元素不匹配的，其下标就是答案。

* 示例1
  * `nums = [2,3,1]`
  * 从`num[1]`开始。这个位置上的元素是`2`,它应在`nums[2]`的位置上，所以它和`nums[2]`交换，交换后`nums = [3, 2, 1]`。
  * 依然从`nums[1]`，这个位置上元素是`3`，它应改在`nums[3]`上，所以他和`nums[3]`交换。交换后`nums = [1,2,3]`。
  * 仍然看 `nums[1]`，元素是 1，他坐在正确的座位上。
  * 向后遍历，`nums[2]=2`，他坐在正确的座位上。
  * 向后遍历，`nums[3]=3`，他坐在正确的座位上。
  * 交换结束
  * 再次遍历`nums`，发现`nums[i] = i`都满足，说明数组中`1,2,3`都有，所以缺失的第一个正数是4。

* 示例2：
* `nums = [3,4,-1,1]`，这是题目中的示例2
  * 从`nums[1]`开始，元素是3，它应该在`nums[3]`上，交换。交换后`nums = [-1,4,3,1].
  * 依然看`nums[1]`，这个座位上的学生，学号是`-1`，忽略。
  * 向后遍历，`nums[2] = 4`，他应当坐在`nums[4]`上，所以他和`nums[4]`交换。交换后：`nums = [-1,1,3,4]`。
  * 依然看`nums[2] = 1`，他应该在`nums[1]`,所以他和`nums[1]`交换。交换后`nums = [1, -1, 3, 4]。
  * 依然看`nums[2]`，其元素是`-1`，忽略。
  * 向后遍历，`nums[3] = 3`，其在正确位置。
  * 向后遍历，`nums[4] = 4`，其在正确的位置上。
  * 交换结束，
  * 再次遍历`nums`，发现`nums[2]` = -1 != 2，说明没有元素2，所以答案是2。
* 示例3
* `nums = [1,1,2]`。
  * 从`nums[1]`开始。这个下标的元素正确。
  * 继续遍历，`nums[2] = 1`, 这是1的影分身。由于1的真身已经在正确的位置上，可以在第**二次遍历的中知道【数组中有1】这个信息**，所以可以忽略nums[2]，向后遍历。
  * `nums[3] = 2`，他应当坐在`nums[2]`上，所以他和`nums[2]`交换。交换后`nums = [1,2,1]`。
  * 仍然看`nums[3]=1`，同样地，由于`1`已经在正确的位置上，所以忽略`nums[3]`。
  * 交换结束。
  * 再次遍历`nums`，发现`nums[3] = 1 != 3`，说明没有元素3，所以答案是3.

* 细节：
  * 判断位置是否正确，能用`nums[i] = i`判断吗？注意**有影分身（重复元素）**。
  * 示例3中，虽然`nums[2] = 1 != 2`，但由于`nums[nums[2]] = nums[1] = 1`，所以`nums[2]`是个影分身，并且真身坐在正确的位置上，所以可以忽略`nums[2]`，向后遍历。注意这种情况是不能交换的，因为 *nums*[2]=*nums*[1]，交换后 *nums*=[1,1,2] 是不变的，这会导致**死循环**。
  * 为了避免死循环，可以改为判断`nums[2]`和`nums[nums[2]]`是不是已有。如果已有，就不执行交换，继续向后遍历。

```cpp
// 如果当前学生的学号在[1,n]中，但（真身）没有坐在正确的位置上
while (1 <= nums[i] && nums[i] <= n && nums[i] != nums[nums[i] - 1])	// nums[i] - 1哦
{
    int j = nums[i] - 1;    // 减一是因为数组下标从0开始
    swap(nums[i], nums[j]);
}
```

## 三、代码

```cpp
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        // 入参校验
        if (nums.empty()){
            return 1;
        }

        int n = nums.size();
        for (int i = 0; i < n; ++i)
        {
            // 如果当前学生的学号在[1,n]中，但（真身）没有坐在正确的位置上
            while (1 <= nums[i] && nums[i] <= n && nums[i] != nums[nums[i] - 1])
            {
                int j = nums[i] - 1;    // 减一是因为数组下标从0开始
                swap(nums[i], nums[j]);
            }
        }

        // 找到第一个学号和编号不匹配的学生
        for (int i = 0; i < n; i++){
            if (nums[i] != i + 1){
                return i + 1;
            }
        }

        // 所有学生都在座位上
        return n + 1;
    }
};
```

