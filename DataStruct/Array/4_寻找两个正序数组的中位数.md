# 4.寻找两个正序数组的中位数

---- Lee

## 一、题目

给定两个大小分别为 `m` 和 `n` 的正序（从小到大）数组 `nums1` 和 `nums2`。请你找出并返回这两个正序数组的 **中位数** 。

算法的时间复杂度应该为 `O(log (m+n))` 。

**示例 1：**

```
输入：nums1 = [1,3], nums2 = [2]
输出：2.00000
解释：合并数组 = [1,2,3] ，中位数 2
```

**示例 2：**

```
输入：nums1 = [1,2], nums2 = [3,4]
输出：2.50000
解释：合并数组 = [1,2,3,4] ，中位数 (2 + 3) / 2 = 2.5
```

**提示：**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`

## 二、思路

### 2.1 双指针法

假设`a`和`b`的长度是`m`和`n`，且`m <= n` （如果不满足则交换两个数组）

* 如果`m > n`，无法从`i=0`开始枚举。以`m=5,n=3`, `i = 0`时，`b`数组需要有4个数在第一组，但`n = 3 < 4`,无法做到。保证`m <= n`可以让我们从`i = 0`开始枚举，写起来更方便。

* 为了方便处理`i = -1`，**既`a`有0个元素在第一组的情况**，可以向`a`左侧插入一个虚拟元素`-∞`，确保数组有序。对于`j = -1`的情况也同理，向`b`的左侧插入一个`−∞`。
* 为了方便处理`i + 1= m`，**既`a`有`m`个数在第一组的情况**，向`a`最右侧插入一个虚拟元素`∞`，确保数组有序。对于`j + 1 = n`同理。
* 插入虚拟元素后，就可以保证无论`a`和`b`是什么样，一定存在一个`i`满足`a[i] <= b[j+1]`且`a[i + 1] > b[j]`。
* `i`的含义变更成了`a`有`i`个数在第一组，`j`的含义编程了`b`有`j`个数在第一组。

初始化 i=0，那么 j 应该初始化成多少？

* 如果`m + n`是偶数，那么每个数组的大小未`(m + n) / 2`，`j = (m + n) / 2`。
* 如果`m + n`是奇数，规定第一组比第二组多一个数，第一组的大小为`(m + n + 1) / 2`，`j = (m + n + 1) / 2`。
* 合并上述情况`j = (m + n + 1) / 2`。

为了保证数组的大小不变，i每增加1，j就要减少1所以有：

* `j = ((m + n + 1) / 2 ) - i`

根据图片的结论，只要发现`a[i] <= b[j + 1]`且`a[i + 1] > b[j]`那么：

* 如果`m + n`是偶数，中位数为`max(a[i], b[j])`和`min(a[i + 1], b[j + 1])`的平均值
* 若是`m + n`是奇数，中位数为`max(a[i], b[j])`。

### 2.2 二分法：

由于`a`和`b`是有序数组，`i`越小`a[i] <= b[j + 1]`越能成立；`i`越大，`a[i] <= b[j + 1]`越不能成立。

所以可以用二分法**最大的**满足`a[i] <= b[j + 1]`的i。二分结束后，我们就有`a[i] <= b[j + 1]`且`a[i + 1] >= b[j]`。

**写法一：**

讨论二分的上下界。本文**用开区间二分，其他二分法也是可以的**。

* 开区间二分左边界：0。在插入`-∞`后，`a[i] <= b[j + 1]`在`i =0`时一定成立。
* 开区间二分右边界：*m*+1。在插入 ∞ 后，`a[i] <= b[j+1]` 在 `i=m+1` 时一定不成立。

时间复杂度不满足：插入的时间复杂度还是`o(m + n)`

**写法二：**

去掉插入的 −∞ 和 ∞，*a* 和 *b* 的下标都减一。

`i`的含义变为了`a`有`i + 1`个数在第一组，`j`的含义变成了`b`有`j+1`个数在第一组。

* `j = (m + n + 1) / 2 - i`变为了`j + 1  = (m + n + 1) / 2 - (i + 1)`
* 既`j = (m + n + 1) / 2 - i - 2`
* `j = (m + n - 3) / 2 - i`

## 三、代码

### 3.1 双指针：不满足时间复杂度

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()){
            swap(nums1, nums2);
        }

        int m = nums1.size();
        int n = nums2.size();

        // 最左侧插入哨兵元素
        nums1.insert(nums1.begin(), INT_MIN);
        nums2.insert(nums2.begin(), INT_MIN);

        // 最右侧添加哨兵元素
        nums1.push_back(INT_MAX);
        nums2.push_back(INT_MAX);

        // 枚举nums1有i个元素在第一组
        // 那么nums2有j = (m + n + 1) / 2 - i个元素在第一组
        int i = 0;
        int j = (m + n + 1) / 2;
        while (1)
        {
            if (nums1[i] <= nums2 [j + 1] && nums1[i + 1] >= nums2[j])
            {
                int max1 = max(nums1[i], nums2[j]);
                int min1 = min(nums1[i + 1], nums2[j + 1]);
                return (m + 2) % 2 ? max1 : (max1 + min1) / 2.0;
            }
            i++;
            j--;
        }
    }
};
```

时间复杂度：*O(m + n)*

空间复杂度：*O(m + n)*

### 3.2 双指针(小优化)

* `a[i + 1] > b[j]`会从不成立到成立，则满足`a[i + 1] <= b[j]`继续遍历，不满足测说明找到元素。

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()){
            swap(nums1, nums2);
        }

        int m = nums1.size();
        int n = nums2.size();

        // 最左侧插入哨兵元素
        nums1.insert(nums1.begin(), INT_MIN);
        nums2.insert(nums2.begin(), INT_MIN);

        // 最右侧添加哨兵元素
        nums1.push_back(INT_MAX);
        nums2.push_back(INT_MAX);

        // 枚举nums1有i个元素在第一组
        // 那么nums2有j = (m + n + 1) / 2 - i个元素在第一组
        int i = 0;
        int j = (m + n + 1) / 2;
        while (nums1[i + 1] <= nums2[j])
        {
            ++i;
            --j;
        }

        int max1 = max(nums1[i], nums2[j]);
        int min1 = min(nums1[i + 1], nums2[j + 1]);

        return (m + 2) % 2 ? max1 : (max1 + min1) / 2.0;
    }
};
```

### 3.3 二分法（不是答案，使用哨兵插入时间复杂度还是O(m + n)）

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size()){
            swap(nums1, nums2);
        }

        int m = nums1.size();
        int n = nums2.size();

        // 最左侧插入哨兵元素
        nums1.insert(nums1.begin(), INT_MIN);
        nums2.insert(nums2.begin(), INT_MIN);

        // 最右侧添加哨兵元素
        nums1.push_back(INT_MAX);
        nums2.push_back(INT_MAX);

        // 枚举nums1有i个元素在第一组
        // 那么nums2有j = (m + n + 1) / 2 - i个元素在第一组
        int left = 0;
        int right = m + 1;
        while (left + 1 < right)
        {
            int i = left + (right - left) / 2;
            int j = (m + n + 1) / 2 - i;
            if (nums1[i] <= nums2[j + 1]){
                left = i;   // 缩小二分区间为（i, right）
            }
            else{
                right = i; // 缩小二分区间（left , i）
            }
        }

        // 此时left = right - 1
        // 且 a[left] <= b[j + 1] 且 a[right] > b[j'+1] = b[j]，所以答案是 i=left
        int i = left;
        int j = (m + n + 1) / 2 - i;
        int max1 = max(nums1[i], nums2[j]);
        int min1 = min(nums1[i + 1], nums2[j + 1]);
        return (m + n) % 2 ? max1 : (max1 + min1) / 2.0;

    }
};
```

### 3.4 二分法（终结）

```cpp
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        if (nums1.size() > nums2.size())
        {
            swap(nums1, nums2);
        }

        int m = nums1.size();
        int n = nums2.size();

        int left = 0;
        int right = m - 1;
        while (left <= right)
        {
            int i = left + (right - left) / 2;
            int j = (m + n + 1) / 2 - i - 2;
            if (nums1[i] <= nums2[j + 1]){
                left = i + 1;
            }
            else{
                right = i - 1;
            }
        }

        // 
        int i = left - 1;
        int j = (m + n + 1) / 2 - i - 2;
        int ai = (i >= 0) ? nums1[i] : INT_MIN;
        int bj = (j >= 0) ? nums2[j] : INT_MIN;
        int ai1 = (i + 1 < m) ? nums1[i + 1] : INT_MAX;
        int bj1 = (j + 1 < n) ? nums2[j + 1] : INT_MAX; 
        int max1 = max(ai, bj);
        int min1 = min(ai1, bj1);
        return (m + n) % 2 ? max1 : (max1 + min1) / 2.0;

    }
};
```

时间复杂度：O(log min(m, n))

空间复杂度：O(1)