# 347_前K个高频元素

---- Lee

## 一、题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你返回其中出现频率前 `k` 高的元素。你可以按 **任意顺序** 返回答案。

**示例 1：**

**输入：**nums = [1,1,1,2,2,3], k = 2

**输出：**[1,2]

**示例 2：**

**输入：**nums = [1], k = 1

**输出：**[1]

**示例 3：**

**输入：**nums = [1,2,1,2,1,2,3,1,3,2], k = 2

**输出：**[1,2]

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`
- `k` 的取值范围是 `[1, 数组中不相同的元素的个数]`
- 题目数据保证答案唯一，换句话说，数组中前 `k` 个高频元素的集合是唯一的

**进阶：**你所设计算法的时间复杂度 **必须** 优于 `O(n log n)` ，其中 `n` 是数组大小。

## 二、思路

**统计各元素出现的次数：**

* 题目中要求的是元素出现的次数，适用hash表记录每个元素出现的次数。为方便查找适用`unordered_map`，`first`是元素本身，`second`是对应出现次数。

```cpp
unordered_map<int, int> cnt;
int maxCount = 0;
for (int& num : nums)
{
    cnt[num]++;
    maxCount = max(maxCount, cnt[num]);
}
```

* 把出现次数相同的元素，放到同一个桶中。同一个桶内的元素出现次数相同，无需对桶排序。
  * 假设出现的最大值为”`maxCnt`“。创建一个大小为`maxCnt + 1`的列表`buckets`，其中`buckets[c]`存储着出现次数为c的元素。
  * 注意：`maxCnt <= n`，这保证时间复杂度是O(n)。
  * 遍历`cnt`，把出现次数为c的元素x，添加到`buckets[c]`中。

```cpp
// 创建一个maxCount + 1大小的桶，将出现次数相同的元素放入同一个桶中
vector<vector<int>> buckets(maxCount + 1);
for (auto& [value, c] : cnt){
    buckets[c].push_back(value);
}
```

* 倒序遍历 `buckets`，把`buckets[c]`中的元素加到答案中。
  * 一旦答案的长度等于k，就立刻返回答案。

```cpp
vector<int> ans;
for (int i = maxCount; i >= 0 && ans.size() < k; --i)
{
	ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
}
```

## 三、代码

```cpp
class Solution {
public:
    vector<int> topKFrequent(vector<int>& nums, int k) {
        // 统计每个元素出现的次数
        unordered_map<int, int> cnt;
        int maxCount = 0;
        for (int& num : nums)
        {
            cnt[num]++;
            maxCount = max(maxCount, cnt[num]);
        }

        // 创建一个maxCount + 1大小的桶，将出现次数相同的元素放入同一个桶中
        vector<vector<int>> buckets(maxCount + 1);
        for (auto& [value, c] : cnt){
            buckets[c].push_back(value);
        }

        // 倒序遍历buckets, 把出现次数前k大的元素加入答案
        vector<int> ans;
        for (int i = maxCount; i >= 0 && ans.size() < k; --i)
        {
            ans.insert(ans.end(), buckets[i].begin(), buckets[i].end());
        }
        return ans;
    }
};
```

