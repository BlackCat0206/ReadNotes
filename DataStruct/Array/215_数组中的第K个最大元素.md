# 215_数组中的第K个最大元素

---- Lee

## 一、题目

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `**k**` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

**提示：**

- `1 <= k <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

[力扣题目链接](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 二、思路

* 二分法+快排

* 这里的二分法实际上是是一种“**分治**”的思想 。本题的最终目的，是找出第K个大元素。那么，将数组进行排序（从大到小），取第`K-1`下标的元素，即可完成要求。

* 分治：上述说的“**分治**”思想，其体现在快排中。
  * 快排的逻辑找一个基准，排序后返回这个基准的坐标，其左边元素比它小，右边元素比它大，这个顺序是可以修改的。
  * 我们就可以根据这个返回的下标来做点文章：分为三种情况
    * 返回下标 + 1 == K：下标所指元素就是第K大/小的元素，下标左侧元素一定比它大/小。
    * 返回下标 + 1 < K: 那就说明第K大的元素还在右边，继续排序右边，不用管左边。
    * 返回下标 + 1 > K：说明第K大的元素在左边，继续排序左边，不用考虑右边。
  * 这样我们就可以根据返回下标与K的大小关系，只考虑一边的排序。减少时间复杂度。
  
* 原有`Hoare`思路缺陷：对于重复元素数组，直接死循环( •_•)>⌐■-■，若这是我们用一点自己的小巧思，选择一边大于等于不久行了。很遗憾，现实是排序后比排序前有序不了多少🤡。

* 解决方案：**三路分区优化版 `Hoare` 快排**

  * 入参判断：若左右边界相同，既已经完成排序，直接返回

  ```cpp
  if (left >= right)
  {
      return;
  }
  ```

  * 确认基准值：规避有序数组，选择当前排序数组中间元素。

  ```cpp
  int baseValue = arr[left + (right - left) / 2];
  ```

  * 确认左右边界，与遍历下标

  ```cpp
  int l = left;
  int r = right;
  int i = left;	// 遍历下标
  ```

  * 在遍历过程中完成逻辑：
    * 将所需数据进行划分，注意遍历下标的递增位置。

  ```cpp
  while (i <= r)
  {
      // 将大于基准值的内容存放在数组左侧
      if (arr[i] > baseValue)
      {
          swap(arr[i], arr[l]);
          ++i;		// 注意这里i要前进,因为i的下标一定是 >= l的，既i与l交换后的数据一定是处理过的数据。
          ++l;
      }
      // 将小于基准值的内容防止数组右侧
      else if (arr[i] < baseValue)
      {
          swap(arr[i], arr[r]);
          --r;
      }
      // 相同，跳过。
      else
      {
      	++i;    
      }
  }
  
  ```

  * 递归继续拆分排序

  ```cpp
  QuickSort(arr, left, l - 1);
  QuickSort(arr, r + 1, right);
  ```

## 三、代码

```cpp
class Solution {
public:

void SortSwap(int* a, int* b)
{
    int temp = *a;
    *a = *b;
    *b = temp;
}

/**
 * @brief hoare排序法三路排序，处理重复元素
 * @param [in] arr 数组
 * @param [in] left 左边界索引
 * @param [in] right 右边界索引
 * @return int
 */
int _QuickSortHoare3(vector<int>& arr, int left, int right, int K)
{
    if (left >= right)
    {
        return arr[K - 1];
    }

    // 选择基准值,防止有序数组，选择中间值
    int index = left + (right - left) / 2;
    int baseValue = arr[index];

    int l = left;
    int r = right;
    int i = left;   // 当前遍历指针
    while (i <= r)
    {
        if (arr[i] > baseValue)
        {
            SortSwap(&arr[i], &arr[l]);
            l++;
            i++;
        }
        else if (arr[i] < baseValue)
        {
            SortSwap(&arr[i], &arr[r]);
            r--;
        }
        else
        {
            i++;
        }
    }
    
    if (K - 1 < r)
    {
        return _QuickSortHoare3(arr, left, l - 1, K);
    }
    else if (K - 1 > r)
    {
       return _QuickSortHoare3(arr, r + 1, right, K);
    }
    else
    {
        return arr[K - 1];
    }
}

    int findKthLargest(vector<int>& nums, int k) {
        if (0 == nums.size() || k > nums.size() || 0 >= k){
            return -1;
        }
        int n = nums.size();
        _QuickSortHoare3(nums, 0, nums.size() - 1, k);
        return nums[k - 1];
    }
};
```

## 四、源码

[findKMax.c](../Sort/SourceCode/findKMax.c)

## 小结：

# 快排基准值与返回下标的核心小结

1. **基准值的作用**

   - 选一个元素当「标尺」，把数组分成「≤标尺」和「≥标尺」两部分，它是分区的核心依据。
   - 不管循环内被交换到哪，最终都会被放到分区的分界位置。

2. **返回下标的双重身份**

   - 它是**区域分界点**：左边全≤基准值，右边全≥基准值，后续递归只需要处理分界点两侧的子数组。
   - 它是**基准值的最终位置**（但不一定是当前基准值所在位置）：循环结束后会执行一次交换，把基准值精准移到这个下标处，这个位置就是基准值在当前子数组的有序位置。

3. **一句话总结**

   快排分区返回的下标，既是划分左右区间的「分界线」，也是基准值在当前子数组里的「最终家」。