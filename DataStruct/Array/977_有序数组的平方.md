# 977.有序数组的平方

---- Lee

## 一、题目

给你一个按 非递减顺序 排序的整数数组 nums，返回 每个数字的平方 组成的新数组，要求也按 非递减顺序 排序。

示例 1：

- 输入：nums = [-4,-1,0,3,10]
- 输出：[0,1,9,16,100]
- 解释：平方后，数组变为 [16,1,0,9,100]，排序后，数组变为 [0,1,9,16,100]

示例 2：

- 输入：nums = [-7,-3,2,3,11]
- 输出：[4,9,9,49,121]

[力扣题目链接(opens new window)](https://leetcode.cn/problems/squares-of-a-sorted-array/)

## 二、思路

* 双指针
  * 双指针分别在左右边界，将其对于元素的平方进行对比，较大这填充至新的数组中，之后缩减范围。

## 三、代码

```c
/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* sortedSquares(int* nums, int numsSize, int* returnSize) {
    // 入参校验
    if (NULL == nums || 0 >= numsSize)
    {
        return nums;
    }

    // 填充返回数组大小
    *returnSize = numsSize;

    // 创建新的结果数组
    int* newArray = (int*)malloc(numsSize * sizeof(int));
    if (NULL == newArray)
    {
        return nums;
    }

    // 设置双边界指针
    int left = 0;
    int right = numsSize - 1;
    int k = numsSize - 1;

    // 根据数组大小进行遍历，将计算结果从高到底进行填充
    while (left <= right)
    {
        // 若左侧数据的平方 >= 右侧的平方，填充左侧数据，left++
        if ((nums[left] * nums[left]) >= (nums[right] * nums[right]))
        {
            newArray[k--] = nums[left] * nums[left];
            ++left;
        }
        // 若右侧数据的平方 > 左侧的平方， 填充右侧数据 right--
        else
        {
            newArray[k--] = nums[right] * nums[right];
            --right;
        }
    }

    // 返回新的结果数组
    return newArray;
}
```

