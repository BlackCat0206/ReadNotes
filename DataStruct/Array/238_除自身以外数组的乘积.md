# 238_除自身以外数组的乘积

---- Lee

## 一、题目

给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。

题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在 **32 位** 整数范围内。

请 **不要使用除法，**且在 `O(n)` 时间复杂度内完成此题。

**示例 1:**

```
输入: nums = [1,2,3,4]
输出: [24,12,8,6]
```

**示例 2:**

```
输入: nums = [-1,1,0,-3,3]
输出: [0,0,9,0,0]
```

**提示：**

- `2 <= nums.length <= 105`
- `-30 <= nums[i] <= 30`
- 输入 **保证** 数组 `answer[i]` 在 **32 位** 整数范围内

**进阶：**你可以在 `O(1)` 的额外空间复杂度内完成这个题目吗？（ 出于对空间复杂度分析的目的，输出数组 **不被视为** 额外空间。）

## 二、思路

* 题目明确要求不能使用除法。

**前后缀积：**

* 那要计算某一元素除自身外的所有元素从成绩，只需直到`nums[0] ~ nums[i - 1]，nums[i + 1] ~ nums[n]`的成绩即可，那么就计算一个前缀积，和后缀积。
* 前缀积：首元素是1

```cpp
int n = nums.size();
vector<int> pre(n, 1);
for (int i = 1; i < n; ++i){
    pre[i] = pre[i - 1] * nums[i - 1];
}
```

* 后缀积：尾元素是1

```cpp
vector<int> suf(n, 1);
for (int i = n - 2; i >= 0; --i){
    suf[i] = suf[i + 1] * nums[i + 1];
}
```

* 计算结果

```cpp
vector<int> ans;
for (int i = 0; i < n; ++i){
    ans[i] = pre[i] * suf[i];
}
return ans;
```

* 时间复杂度：`O(n)`
* 空间复杂度：`O(n)`

进阶：

* 先计算后缀，以后缀数组作为结果，给每个后缀称上遍历计算前缀积即可。

```cpp
int n = nums.size();
vector<int> suf(n, 1);
suf[n - 1] = 1;
for (int i = n - 2; i >= 0; --i){
    suf[i] = suf[i + 1] * num[i + 1];
}

// 实时计算前缀积并同时计算结果
int pre = 1;
for (int i = 0; i < n; ++i){
    // 此时 pre 为 nums[0] 到 nums[i-1] 的乘积，直接乘到 suf[i] 中
    suf[i] *= pre;
    pre *= nums[i];
}

return suf;
```

* 时间复杂度：`O(n)`
* 空间复杂度：`O(1)`

## 三、代码

```cpp
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        // 入参校验
        if (nums.empty()){
            return {};
        }

        // 计算前缀积
        int n = nums.size();
        vector<int> pre(n ,1);
        for (int i = 1; i < n; ++i){
            pre[i] = pre[i - 1] * nums[i - 1];
        }
        
        // 计算后缀积
        vector<int> suf(n, 1);
        for (int i = n - 2; i >= 0; --i){
            suf[i] = suf[i + 1] * nums[i + 1];
        }

        // 计算结果
        vector<int> ans(n);
        for (int i = 0; i < n; ++i){
            ans[i] = pre[i] * suf[i];
        }

        return ans;
    }
};
```

