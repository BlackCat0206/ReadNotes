# 84_柱状图中最大的矩形

---- Lee

## 一、题目

给定 *n* 个非负整数，用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 1 。

求在该柱状图中，能够勾勒出来的矩形的最大面积。

**示例 1:**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg)

```
输入：heights = [2,1,5,6,2,3]
输出：10
解释：最大的矩形为图中红色区域，面积为 10
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/04/histogram-1.jpg)

```
输入： heights = [2,4]
输出： 4
```

**提示：**

- `1 <= heights.length <=105`
- `0 <= heights[i] <= 104`

## 二、思路

**以柱子高度为枚举，寻找左右最近的更小柱子的下标：**

* 以h[i]为最终矩形高度，找到能容纳它的最大宽度。

**为何需要找「左右最近的小于 `h[i]` 的下标」？**

要找到以 `h[i]` 为高度的最大宽度，本质是找到 `h[i]` 能 “延伸” 的左右边界：

- 左边界：`i` 左侧**第一个高度小于 `h[i]`** 的柱子下标（记为 `left[i]`）
- 右边界：`i` 右侧**第一个高度小于 `h[i]`** 的柱子下标（记为 `right[i]`）

原因很简单：

- 从 `left[i]+1` 到 `i` 之间的所有柱子，**高度都≥`h[i]`**（因为 `left[i]` 是左侧第一个更小的，意味着中间的柱子都不小于 `h[i]`）
- 从 `i` 到 `right[i]-1` 之间的所有柱子，高度也都≥`h[i]`（同理，`right[i]` 是右侧第一个更小的，中间的柱子都不小于 `h[i]`）

因此，以 `h[i]` 为高度的矩形，**有效宽度就是 `right[i] - left[i] - 1`**（左右边界之间的柱子数量），超出这个范围的柱子高度小于 `h[i]`，无法支撑 `h[i]` 作为矩形高度。	

## 三、代码

**写法一：三次遍历**

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int>left (n, -1);
        stack<int> st;
        // 寻找每个元素最近左侧最小元素下标
        for (int i = 0; i < n; ++i)
        {
            int h = heights[i];
            while (!st.empty() && h <= heights[st.top()])
            {
                st.pop();
            }
            
            // 找到左侧最近的小于当前元素的下标
            if (!st.empty()){
                left[i] = st.top();
            }
            st.push(i);
        }

        vector<int> right(n, n);
        st = stack<int>();
        for (int i = n - 1; i >=0; --i){
            int h = heights[i];
            while (!st.empty() && h <= heights[st.top()]){
                st.pop();
            }

            // 找到右侧最近小于它的元素的下标
            if (!st.empty()){
                right[i] = st.top();
            }

            st.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++){
            ans = max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
};
```

**写法二：两次遍历**

* 将`right`的定义改为：右侧最近**小于等于**当前柱子高度的下标。

* **明确核心前提**：我们的目标是「找到全局最大面积」，而非「准确计算每个`h[i]`对应的最大面积」

* **核心原因**：重复高度（相同`h[i]`）的柱子之间存在「**互补性**」，不会遗漏全局最大值

  当`heights`中存在相同高度的柱子时，修改`right[i]`定义（加入等于）导致的 “**左侧相同柱子面积偏小”，会被 “右侧相同柱子的准确面积” 弥补**，具体拆解如下：

  示例：`heights=[1,3,4,3,2]`

  我们先明确两根高度为 3 的柱子（记左侧 3 为`i=1`，右侧 3 为`i=3`，高度`h=3`）：

  - 原定义（右侧最近**小于**3）：

    - `i=1`的`right[i]`：右侧最近小于 3 的是`i=4`（高度 2），宽度 =`4-左边界-1`（左边界是`i=0`，高度 1），面积 =`3×(4-0-1)=9`
    - `i=3`的`right[i]`：同样是`i=4`，左边界是`i=0`，面积 =`3×(4-0-1)=9`

    

  - 修改后定义（右侧最近**小于等于**3）：

    - `i=1`的`right[i]`：右侧最近小于等于 3 的是`i=3`（高度 3，等于当前值），此时宽度 =`3-0-1=2`，面积 =`3×2=6`（确实偏小）
    - `i=3`的`right[i]`：右侧最近小于等于 3 的仍是`i=4`（高度 2，小于 3），左边界仍是`i=0`，面积 =`3×(4-0-1)=9`（保持准确，和原定义一致。

  可见：**左侧相同柱子`i=1`的面积计算偏小，但右侧相同柱子`i=3`的面积仍能准确反映以 3 为高度的最大矩形面积，全局最大值 9 并未被遗漏**。

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        int n = heights.size();
        vector<int>left (n, -1);
        vector<int> right(n, n);
        stack<int> st;
        // 寻找每个元素最近左侧最小元素下标
        for (int i = 0; i < n; ++i)
        {
            int h = heights[i];
            while (!st.empty() && h <= heights[st.top()])
            {
                // 填充右侧最近小于等于柱子高度的下标
                right[st.top()] = i;
                st.pop();
            }
            
            // 找到左侧最近的小于当前元素的下标
            if (!st.empty()){
                left[i] = st.top();
            }
            st.push(i);
        }

        int ans = 0;
        for (int i = 0; i < n; i++){
            ans = max(ans, heights[i] * (right[i] - left[i] - 1));
        }
        return ans;
    }
};
```

**写法三：一次遍历**

* 栈顶出栈时，当**前下标是栈顶的right**。
* 如果我们可以**一次性将left**一起带出来，是不是就可以完成一次遍历？
* 由于**单调栈是底小顶大**的，栈顶下面那个柱子的高度一定比栈顶小，所以栈顶下面的值就是 ***left***

```cpp
class Solution {
public:
    int largestRectangleArea(vector<int>& heights) {
        heights.push_back(-1);  // 用-1把栈清空
        int n = heights.size();
        stack<int> st;
        st.push(-1);    // 栈中只有一个数的时候，栈顶的 下面那个数 时-1，对应的left[i] = -1
        int ans = 0;
        for (int right = 0; right < heights.size(); ++right)
        {
            int h = heights[right];
            while (st.size() > 1 && h <= heights[st.top()])
            {
                int i = st.top();
                st.pop();
                int left = st.top();
                ans = max(ans, heights[i] * (right - left - 1));
            }
            st.push(right);
        }
        return ans;
    }
};
```

* 时间复杂度：O(n)，其中 n 为 heights 的长度。每个元素入栈出栈各至多一次，所以二重循环是 O(n) 的。
* 空间复杂度：O(min(n,U))。其中 U 为 heights 中的不同元素个数。注意栈中没有重复元素。

## 四、思考

#### 1. 栈的核心使命

为每个柱子 `i` 快速找到「左右最近的更小 / 小于等于它的柱子下标」（即 `left[i]` 和 `right[i]`），而栈的单调性正是为了实现这一 “快速查找”—— 避免暴力遍历，将时间复杂度从 O (n²) 优化到 O (n)。

#### 2. 栈内下标的「单调性要求」

栈内存储的下标 `j1, j2, j3, ..., jk`（栈底到栈顶），必须满足 `heights[j1] < heights[j2] < heights[j3] < ... < heights[jk]`（严格递增），或 `heights[j1] ≤ heights[j2] ≤ ... ≤ heights[jk]`（非递减，对应 `right[i]` 定义修改后）。

#### 3. 遍历过程中的「入栈」与「出栈」逻辑（关键）

遍历每个柱子下标 `i`（从左到右），针对当前 `heights[i]`，执行以下操作：

- 「弹出不满足条件的下标」：只要栈不为空，且 `heights[i] ≤ heights[栈顶下标]`（**不满足单调递增 / 非递减**），就弹出栈顶下标；
  - **此时，当前 `i` 就是「被弹出下标」的「右侧最近小于等于它的下标」**（即 `right[被弹出下标] = i`）；
  - **而弹出后新的栈顶下标（若存在），就是「被弹出下标」的「左侧最近小于它的下标」**（即 `left[被弹出下标] = 新栈顶下标`）；
- 「入栈当前下标」：当栈为空，或 `heights[i] > heights[栈顶下标]`（满足单调性）时，将 `i` 入栈，维持栈的单调递增性。

#### 4. 直观示例（`heights=[1,3,4,3,2]`）

我们跟踪栈的变化（栈底→栈顶，存储下标，对应高度单调递增）：

- 初始栈为空；

- 遍历 `i=0`（高度 1）：栈空，入栈→栈：`[0]`；

- 遍历 `i=1`（高度 3）：`3>1`（满足递增），入栈→栈：`[0,1]`；

- 遍历 `i=2`（高度 4）：`4>3`（满足递增），入栈→栈：`[0,1,2]`；

- 遍历 `i=3`（高度 3）：

  - 栈顶是 2（高度 4），`3≤4`（不满足），弹出 2；此时 `right[2]=3`，`left[2]=1`；
  - 新栈顶是 1（高度 3），`3≤3`（不满足，对应 `right[i]` 定义修改后），弹出 1；此时 `right[1]=3`，`left[1]=0`；
  - 新栈顶是 0（高度 1），`3>1`（满足），入栈 3→栈：`[0,3]`；

- 遍历 `i=4`（高度 2）：

  - 栈顶是 3（高度 3），`2≤3`（不满足），弹出 3；此时 `right[3]=4`，`left[3]=0`；
  - 新栈顶是 0（高度 1），`2>1`（满足），入栈 4→栈：`[0,4]`；

  

- 遍历结束后，处理栈内剩余下标（0、4），其 `right` 为数组长度（无右侧更小元素）。

从这个流程可以清晰看到：栈中始终是「单调递增的下标序列」，弹出操作是为了维持单调性，同时快速确定被弹出下标的左右边界，这和你理解的「备选最小元素」有本质区别。