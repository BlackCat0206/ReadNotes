# 295_数据流的中位数

---- Lee

## 一、题目 

**中位数**是有序整数列表中的中间值。如果列表的大小是偶数，则没有中间值，中位数是两个中间值的平均值。

- 例如 `arr = [2,3,4]` 的中位数是 `3` 。
- 例如 `arr = [2,3]` 的中位数是 `(2 + 3) / 2 = 2.5` 。

实现 `MedianFinder` 类:

- `MedianFinder()` 初始化 `MedianFinder` 对象。
- `void addNum(int num)` 将数据流中的整数 `num` 添加到数据结构中。
- `double findMedian()` 返回到目前为止所有元素的中位数。与实际答案相差 `10-5` 以内的答案将被接受。

**示例 1：**

```
输入
["MedianFinder", "addNum", "addNum", "findMedian", "addNum", "findMedian"]
[[], [1], [2], [], [3], []]
输出
[null, null, null, 1.5, null, 2.0]

解释
MedianFinder medianFinder = new MedianFinder();
medianFinder.addNum(1);    // arr = [1]
medianFinder.addNum(2);    // arr = [1, 2]
medianFinder.findMedian(); // 返回 1.5 ((1 + 2) / 2)
medianFinder.addNum(3);    // arr[1, 2, 3]
medianFinder.findMedian(); // return 2.0
```

**提示:**

- `-105 <= num <= 105`
- 在调用 `findMedian` 之前，数据结构中至少有一个元素
- 最多 `5 * 104` 次调用 `addNum` 和 `findMedian`

[力扣题目链接](https://leetcode.cn/problems/find-median-from-data-stream/)

## 二、思路

* 两个有序队列：
  * `qunMax`：存储**大于中位数的元素**。
  * `qunMin`：存储**小于等于中位数的元素**。

```cpp
priority_queue<int, vector<int>, less<int>> queMin;		// 大堆顶
priority_queue<int, vector<int>, greater<int>> qunMax;	// 小堆顶
```

* 当累加添加的元素是
  * 奇数时：`qunMin == qunMax + 1;`，中位数是`qunMin`的队头
  * 偶数时：`qunMin == qunMax`，中位数是它们的队头的平均值。

```cpp
double findMedian()
{
    if (qunMin.size() > qunMax.size())
    {
        return qunMin.top();
    }
    return (qunMin.top() + qunMax.top()) / 2.0;
}
```

* 对于添加的元素：
  * `num <= max(qunMin)`：将其添加进`qunMin`中。新的中位数小于等于原来的中位数，我们可能要将`qunMin`的最大数移动到`qunMax`中。
  * `num > max(qunMin)`：将其添加到`qunMax`中。新的中位数大于等于原来的中位数，可能要将`qunMax`中最小的移动到`qunMin`中。
* 当添加数量位0中，将`num`添加到`qunMin`中。

```cpp
void addNum(int num)
{
    // 判断元素填充进那个队列
    if (qunMin.empty() || num <= qunMin.top())	// 为空时添加qunMin
    {
        qunMin.push(num);
        // 填充后判断平衡
        if (qunMax.size() + 1 != qunMin.size())
        {
            qunMax.push(qunMin.top());
            qunMin.pop();
        }
    }
    else
    {
        qunMax.push(num);
        if (qunMax.size() > qunMin.size())
        {
            qunMin.push(qunMax.top());
            qunMax.pop();
        }
    }
}
```

## 三、代码

```cpp
class MedianFinder {
public:
    // 大堆顶
    priority_queue<int, vector<int>, less<int>> qunMin;
    // 小堆顶
    priority_queue<int, vector<int>, greater<int>> qunMax;

    MedianFinder() {
        
    }
    
    void addNum(int num) {
        // 若为空或小于qunMin最大值，添加进qunMin
        if (qunMin.empty() || num <= qunMin.top())
        {
            qunMin.push(num);
            if (qunMax.size() + 1 != qunMin.size())
            {
                qunMax.push(qunMin.top());
                qunMin.pop();
            }
        }
        else
        {
            qunMax.push(num);
            if (qunMax.size() > qunMin.size())
            {
                qunMin.push(qunMax.top());
                qunMax.pop();
            }
        }
    }
    
    double findMedian() {
        if (qunMin.size() > qunMax.size())
        {
            return qunMin.top();
        }
        return (qunMax.top() + qunMin.top()) / 2.0;
    }
};

/**
 * Your MedianFinder object will be instantiated and called as such:
 * MedianFinder* obj = new MedianFinder();
 * obj->addNum(num);
 * double param_2 = obj->findMedian();
 */
```



