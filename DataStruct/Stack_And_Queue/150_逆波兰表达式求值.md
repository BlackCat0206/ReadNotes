# 150_逆波兰表达式求值

---- Lee

## 一、题目

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + , - , * , / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。

示例 1：

- 输入: ["2", "1", "+", "3", " * "]
- 输出: 9
- 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：

- 输入: ["4", "13", "5", "/", "+"]
- 输出: 6
- 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：

- 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]
- 输出: 22

[力扣题目链接(opens new window)](https://leetcode.cn/problems/evaluate-reverse-polish-notation/)

## 二、思路

* 使用栈
* 将数据向内填充，若遇到运算符将栈内两个元素pop，按对应运算符计算后填充进栈，直至传入数据结束。

## 三、代码

```cpp
class Solution {
public:
    int evalRPN(vector<string>& tokens) {
        // 入参校验
        if (0 == tokens.size())
        {
            return -1;
        }

        // 声明存储数据的栈
        stack<long long> stc;

        // 轮询遍历，遇到一个运算符就pop两个元素，按对应操作计算填充进入栈
        for (int i = 0; i < tokens.size(); i++)
        {
            if ("+" == tokens[i] || "-" == tokens[i] || "*" == tokens[i] || "/" == tokens[i])
            {
                long long num1 = stc.top();
                stc.pop();
                long long num2 = stc.top();
                stc.pop();
                if ("+" == tokens[i])
                {
                    stc.push(num2 + num1);
                }
                else if ("-" == tokens[i])
                {
                    stc.push(num2 - num1);
                }
                else if ("*" == tokens[i])
                {
                    stc.push(num2 * num1);
                }
                else if ("/" == tokens[i])
                {
                    stc.push(num2 / num1);
                }
            }
            else
            {
                stc.push(stoll(tokens[i]));
            }
        }

        long long result = stc.top();
        stc.pop();
        return result;
    }
};
```

