# 739_每日温度

---- Lee

## 一、题目

给定一个整数数组 `temperatures` ，表示每天的温度，返回一个数组 `answer` ，其中 `answer[i]` 是指对于第 `i` 天，下一个更高温度出现在几天后。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。

 

**示例 1:**

```
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

**示例 2:**

```
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

**示例 3:**

```
输入: temperatures = [30,60,90]
输出: [1,1,0]
```

 

**提示：**

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`

## 二、思路

**从右向左**：

* 使用单调栈，从右向左，栈中记录下一个【高温天】的**下标**。
* 从右向左遍历，获取当前的温度`t`，将当前温度与备选温度记录进行比较，记录为空或当前温度小于备选温度。

```cpp
int n = temperature.size();

for (int i = n - 1; i >= 0; --i){
    int t = temperatures[i];
    while (!stk.empty() && t >= temperatures[stk.top()]){
        stk.pop();
    }
}
```

* 若栈内不为空，说明右侧有比当前温度高的下标，更新结果。

```cpp
if (!stk.empty()){
    res[i] = stk.top() - i;
}
```

* 将当前元素添加到备选项中：

```cpp
stk.push(i);
```

**从左向右：**

栈内记录还没有计算出下一个更大元素的那些数的下标。相当于一个`todolist`，在循环过程中不知道答案，在后面循环中满足条件后计算出答案。

```cpp
for (int i = 0; i < n; ++i){
    t = temperature[i];
    while (!stk.empty() && t > temperature[i]){
        int j = skt.top();
        stk.pop();
        res[j] = i - j;
    }
    stk.push[i];
}
```

## 三、代码

**从右向左：**

```cpp
class Solution {
public:
    // 从右向左
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n);
        stack<int> stk;

        for (int i = n - 1; i >= 0; --i){
            int t = temperatures[i];
            while (!stk.empty() && t >= temperatures[stk.top()]){
                stk.pop();
            }

            if (!stk.empty()){
                res[i] = stk.top() - i;
            }
            stk.push(i);
        }
        return res;
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(min(n, U)); U = max(temperatures) - min(temperatures) + 1;

**从左向右：**

```cpp
class Solution {
public:
    vector<int> dailyTemperatures(vector<int>& temperatures) {
        int n = temperatures.size();
        vector<int> res(n);
        stack<int> stk;

        for (int i = 0; i < n; ++i){
            int t = temperatures[i];
            while (!stk.empty() && t > temperatures[stk.top()]){
                int j = stk.top();
                stk.pop();
                res[j] = i - j;
            }
            stk.push(i);
        }
        return res;
    }
};
```

* 时间复杂度：O(n)
* 空间复杂度：O(n)