# 两数相加-链表

## 一、题目

给你两个 **非空** 链表来代表两个非负整数。数字最高位位于链表开始位置。它们的每个节点只存储一位数字。将这两数相加会返回一个新的链表。

你可以假设除了数字 0 之外，这两个数字都不会以零开头。

 

**示例1：**

![img](https://pic.leetcode-cn.com/1626420025-fZfzMX-image.png)

```
输入：l1 = [7,2,4,3], l2 = [5,6,4]
输出：[7,8,0,7]
```

**示例2：**

```
输入：l1 = [2,4,3], l2 = [5,6,4]
输出：[8,0,7]
```

**示例3：**

```
输入：l1 = [0], l2 = [0]
输出：[0]
```

 

**提示：**

- 链表的长度范围为` [1, 100]`
- `0 <= node.val <= 9`
- 输入数据保证链表代表的数字无前导 0

 

**进阶：**如果输入链表不能翻转该如何解决？

[力扣链接](https://leetcode.cn/problems/add-two-numbers-ii/description/)

## 二、思路

* 两个链表反转进行地位运算，注意进位操作。
* 计算结束后，反转结果链表。
* 最后的进位结果要考虑是否在添加一个节点。

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* reversetList(struct ListNode* list, int* size)
{
    if (NULL == list)
    {
        return 0;
    }

    typedef struct ListNode ListNode;
    ListNode* pre = NULL;
    ListNode* cur = list;
    ListNode* temp = NULL;

    int sizeList = 0;

    while (NULL != cur)
    {
        // 获取中间变量
        temp = cur->next;
        // 反转
        cur->next = pre;

        // 双指针移动
        pre = cur;
        cur = temp;

        ++sizeList;
    }
    *size = sizeList;

    return pre;
}

struct ListNode* addTwoNumbers(struct ListNode* l1, struct ListNode* l2){
    // 入参校验
    if (NULL == l1 || NULL == l2)
    {
        return NULL;
    }

    // 将两个链表反转
    typedef struct ListNode ListNode;
    int size1 = 0;
    ListNode* new1 =  reversetList(l1, &size1);
    int size2 = 0;
    ListNode* new2 = reversetList(l2, &size2);

    // 使用较长的链表作为结果
    ListNode* sum = NULL;
    ListNode* base = NULL;
    
    if (size1 >= size2)
    {
        sum = new1;
        base = new2;
    }
    else
    {
        sum = new2;
        base = new1;
    }


    // 按照base的长度进行累加
    int sumNum = 0;
    int currentNum = 0;
    // 标志位判断是否需要进位
    int needUpdate = 0;

    ListNode* result = sum;
    while(NULL != base)
    {
        sumNum = base->val + sum->val;
        // 判断本次运算是否要考虑上一位的进位
        if (1 == needUpdate)
        {
            sumNum++;
            needUpdate = 0;
        }

        // 判断本次运算是否要向上进位
        if (0 < sumNum / 10)
        {
            // 需要进位，保留当前位。改变进位标识符。
            currentNum = sumNum%10;
            needUpdate = 1;
        }
        else
        {
            currentNum = sumNum;
            needUpdate = 0;
        }

        // 修改sum当前位的数据
        sum->val = currentNum;

        // 进行下一位运算
        base = base->next;
        sum = sum->next;
    }

    // 低位数计算完成后，验证是否还需要进位
    while(NULL != sum)
    {
        sumNum = sum->val;
        if (1 == needUpdate)
        {
            sumNum++;
            needUpdate = 0;
        }

        // 判断本次运算是否要向上进位
        if (0 < sumNum / 10)
        {
            // 需要进位，保留当前位。改变进位标识符。
            currentNum = sumNum%10;
            needUpdate = 1;
        }
        else
        {
            currentNum = sumNum;
            needUpdate = 0;
        }

        // 修改sum当前位的数据
        sum->val = currentNum;

        // 位移
        sum = sum->next;
    }

    // 将sum表重新反转
    int finalLength = 0;
    ListNode* resultFinal = reversetList(result, &finalLength);

    // 在此类情况下：{1} {99} = {001} sum已有节点无法完整表达内容，故需要添加新的节点
    if (1 == needUpdate)
    {
        ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
        if (NULL == newNode)
        {
            return NULL;
        }

        newNode->val = 1;
        newNode->next = resultFinal;
        return newNode;
    }

    return resultFinal;
}
```

