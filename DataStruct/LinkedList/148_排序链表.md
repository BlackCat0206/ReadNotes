# 148_排序链表

---- Lee

## 一、题目

给你链表的头结点 `head` ，请将其按 **升序** 排列并返回 **排序后的链表** 。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_1.jpg)

```
输入：head = [4,2,1,3]
输出：[1,2,3,4]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/09/14/sort_list_2.jpg)

```
输入：head = [-1,5,3,4,0]
输出：[-1,0,3,4,5]
```

**示例 3：**

```
输入：head = []
输出：[]
```

**提示：**

- 链表中节点的数目在范围 `[0, 5 * 104]` 内
- `-105 <= Node.val <= 105`

**进阶：**你可以在 `O(n log n)` 时间复杂度和常数级空间复杂度下，对链表进行排序吗？

## 二、思路

* 冒泡（时间超限）

* 归并排序，断开链表重组。

  * 查找中间节点并断开链表（与回文有相似，但核心不同，回文在中间节点反转，此处要在此之前断开，需要留一个pre）

  ```cpp
  ListNode* middleNode(ListNode* node)
  {
      ListNode* pre = node;
      ListNode* slow = node;
      ListNode* fast = node;
      while (nullptr != fast && nullptr != fast->next)
      {
          pre = slow;
          slow = slow->next;
          fast = fast->next->next;
      }
      pre->next = nullptr; // 断开连接
      return slow;		 // 返回中间节点
  }
  ```

  * 合并有序链表

  ```cpp
  ListNode* merageLists(ListNode* head1, ListNode* head2)
  {
      ListNode fakeHead;
      ListNode* cur = &fakeHead;
      while (nullptr != head1 && nullptr != head2)
      {
          if (head1->val < head2-> val)
          {
              cur->next = head1;
              head1 = head1->next;
          }
          else
          {
              cur->next = head2;
              head2 = head2->next;
          }
          cur = cur->next;
      }
      
      // 处理剩余链表节点
      cur->next = (nullptr == head1) ? head2 : head1;
      
      return fakeHead.next;
  }
  ```

  * 归并排序

  ```cpp
  ListNode* sortList(ListNode* head)
  {
      // 若为节点或单个节点，直接返回
      if (nullptr == head || nullptr == head->next){
          return head;
      }
      
      // 对传入链表找到其中间节点并从中间断开, 返回断开链表的头节点
      ListNode* head2 = middleNode(head);
      
      // 分治
      head = sortList(head);
      head2 = sortList(head2);
      
      // 合并
      ListNode* res = merageLists(head, head2);
      return res;
  }
  ```

## 三、代码

```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:

    ListNode* middleNode(ListNode* node)
    {
        ListNode* pre = node;
        ListNode* slow = node;
        ListNode* fast = node;

        while (nullptr != fast && nullptr != fast->next)
        {
            pre = slow;
            slow = slow->next;
            fast = fast->next->next;
        }
        pre->next = nullptr;    // 断开
        return slow;
    }

    ListNode* merageLists(ListNode* head1, ListNode* head2)
    {
        ListNode fakeHead;
        ListNode* cur = &fakeHead;

        // 遍历两个链表，进行合并
        while (nullptr != head1 && nullptr != head2)
        {
            if (head1->val < head2->val)
            {
                cur->next = head1;
                head1 = head1->next;
            }
            else
            {
                cur->next = head2;
                head2 = head2->next;
            }
            cur = cur->next;
        }
        
        // 处理剩余的不为空的链表
        cur->next = (nullptr == head1) ? head2 : head1;

        return fakeHead.next;
    }

    ListNode* sortList(ListNode* head) {
        // 若是空节点，或单个节点，直接返回
        if (nullptr == head || nullptr == head->next)
        {
            return head;
        }

        // 从中间断开传入链表，并返回另一半链表的头节点
        ListNode* head2 = middleNode(head);

        // 分治
        head = sortList(head);
        head2 = sortList(head2);

        // 合并
        ListNode* res = merageLists(head, head2);
        return res;
    }
};
```

