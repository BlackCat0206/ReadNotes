# 160. 链表相交

---- Lee

## 一、题目

同：160.链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://file1.kamacoder.com/i/algo/20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例 1：

![img](https://file1.kamacoder.com/i/algo/20211219221723.png)

示例 2：

![img](https://file1.kamacoder.com/i/algo/20211219221749.png)

示例 3：

![img](https://file1.kamacoder.com/i/algo/20211219221812.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

## 二、思路

* 感谢灵神：
* 如果一切顺利的话，我们一定会相遇。
  * (X+Z) + Y = (Y + Z) + X; 


## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode(int x) : val(x), next(NULL) {}
 * };
 */
class Solution {
public:
    ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
        // 入参校验
        if　(nullptr == headA || nullptr == headB){
            return nullptr;
        }

        ListNode* a = headA;
        ListNode* b = headB;
        while (a != b)
        {
            a = nullptr != a ? a->next : headB;
            b = nullptr != b ? b->next : headA;
        }
        return a;

        return nullptr;
    }
};
```

