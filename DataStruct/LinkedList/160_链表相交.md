# 160. 链表相交

---- Lee

## 一、题目

同：160.链表相交

给你两个单链表的头节点 headA 和 headB ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。

图示两个链表在节点 c1 开始相交：

![img](https://file1.kamacoder.com/i/algo/20211219221657.png)

题目数据 保证 整个链式结构中不存在环。

注意，函数返回结果后，链表必须 保持其原始结构 。

示例 1：

![img](https://file1.kamacoder.com/i/algo/20211219221723.png)

示例 2：

![img](https://file1.kamacoder.com/i/algo/20211219221749.png)

示例 3：

![img](https://file1.kamacoder.com/i/algo/20211219221812.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/intersection-of-two-linked-lists-lcci/)

## 二、思路

* 计算两个链表的长度，计算两个链表的差值。
* 快慢指针，快指针先走差值。
* 之后快慢指针同时移动，判断所指内容是否相同。

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode *detectCycle(struct ListNode *head) {
    // 入参校验
    if (NULL == head)
    {
        return NULL;
    }

    typedef struct ListNode ListNode;
    
    // 快慢指针
    ListNode* slow = head;
    ListNode* fast = head;

    while(NULL != fast->next && NULL != fast->next->next)
    {
        fast = fast->next->next;
        slow = slow->next;

        // 快慢指针相遇，从相遇点开始
        if (slow == fast)
        {
            ListNode* index1 = fast;
            ListNode* index2 = head;
            while(index1 != index2)
            {
                index1 = index1->next;
                index2 = index2->next;
            }
            return index2;
        }
    }
    return NULL;
}
```

