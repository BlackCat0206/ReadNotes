# 92_反转链表2

----Lee

## 一、题目

给你单链表的头指针 `head` 和两个整数 `left` 和 `right` ，其中 `left <= right` 。请你反转从位置 `left` 到位置 `right` 的链表节点，返回 **反转后的链表** 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/19/rev2ex2.jpg)

```
输入：head = [1,2,3,4,5], left = 2, right = 4
输出：[1,4,3,2,5]
```

**示例 2：**

```
输入：head = [5], left = 1, right = 1
输出：[5]
```

 

**提示：**

- 链表中节点数目为 `n`
- `1 <= n <= 500`
- `-500 <= Node.val <= 500`
- `1 <= left <= right <= n`

[力扣题目](https://leetcode.cn/problems/reverse-linked-list-ii/description/)

##  二、思路

画图：假设`-1`是虚拟头节点，反转2与4位

-1 1 2 3 4 5 6

* 位移至反转区间之前：设定`pre`与`cur` 与空的`cur_nextNode`

* step1：
  * 最终目标：-1->1->3->2->4->5->6
  * cur_nextNode = cur->next;
  * cur->next = cur_nextNode->next; -1 1 (2->4<-3)  5 6
  * cur_nextNode->next = pre->next; -1 (1->2<-3)  2->4 5 6
  * pre->next=cur_nextNode; -1 1 3 2 4 5 6
* step2:
  * 最终目标：-1->1->4->3->2->5->6
  * ....
* **可以理解位将`cur`插入到`cur_nextCode`之后**。
* 相同思路：[25_K个一组反转链表.md](./25_K个一组反转链表.md)

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseBetween(struct ListNode* head, int left, int right) {
    // 入参校验
    if (NULL == head || 0 > left || 0 > right || left >= right)
    {
        return head;
    }

    // 创建虚拟头节点
    typedef struct ListNode ListNode;
    ListNode* fakeHead = (ListNode*)malloc(sizeof(ListNode));
    if (NULL == fakeHead)
    {
        return fakeHead;
    }
    fakeHead->next = head;

    // 偏移值翻转区域的前一个节点
    ListNode* pre = fakeHead;
    int i = 0;
    for (i = 0; i < left - 1; ++i)
    {
        pre = pre->next;
    }

    ListNode* cur = pre->next;
    ListNode* cur_nextNode = NULL;
    for (i = 0; i < right - left; ++i)
    {
        cur_nextNode = cur->next;
        cur->next = cur_nextNode->next;
        cur_nextNode->next = pre->next;
        pre->next = cur_nextNode;
    }

    ListNode* result = fakeHead->next;
    free(fakeHead);
    return result;
}
```

