# 146_LRU缓存

---- Lee

## 一、题目

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

**提示：**

- `1 <= capacity <= 3000`

- `0 <= key <= 10000`

- `0 <= value <= 105`

- 最多调用 `2 * 105` 次 `get` 和 `put`

- 请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

  实现 `LRUCache` 类：

  - `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
  - `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
  - `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

  函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

  **示例：**

  ```
  输入
  ["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
  [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
  输出
  [null, null, null, 1, null, -1, null, -1, 3, 4]
  
  解释
  LRUCache lRUCache = new LRUCache(2);
  lRUCache.put(1, 1); // 缓存是 {1=1}
  lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
  lRUCache.get(1);    // 返回 1
  lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
  lRUCache.get(2);    // 返回 -1 (未找到)
  lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
  lRUCache.get(1);    // 返回 -1 (未找到)
  lRUCache.get(3);    // 返回 3
  lRUCache.get(4);    // 返回 4
  ```

  **提示：**

  - `1 <= capacity <= 3000`
  - `0 <= key <= 10000`
  - `0 <= value <= 105`
  - 最多调用 `2 * 105` 次 `get` 和 `put`

## 二、思路

* 题目理解：有一摞书

  * get()：把一本书（key）抽出来，放在最上面。

  * put()：放入一本新书。

    * 如果已经有这本书（key），就把他抽出来放在最上面，并替换它的value。
    * 如果没有这本书(key)，就放在最上面。如果超过`capacity`这本书，就把最下面的书移除。

  * 时间复杂度：`O(1)`。

  * 数据结构：

    * 双向链表，每个节点代表一本书（key和value）。每个节点都有两个指针`prev`和`next`分别指向前一个和下一个节点。
    * 虚拟头节点：`dummy`，`prev`指向末尾元素节点，实现一个**环形链表**。

  * 删除一个节点（抽出一本书）节点x：

    ```cpp
    x->prev->next = x->next;
    x->next->prev = x->prev;
    ```

  * 在链表头添加一个节点：节点x

    ```cpp
    x->prev = dummy;
    x->next = dummy->next;
    x->prev->next = x;
    x->next->prev = x;
    ```

  * 如何快速找到要抽出的书？

    把key映射到链表中的对应节点。

    ```cpp
    unordered_map<int, Node*>
    ```

  * 为什么节点要把key也存下来？

    * 删除链表末尾节点时，也要删除哈希表中的记录，这需要知道末尾节点的Key。

* 链表要实现的内容：
  * 移除节点
  * 在头节点添加一个节点。
  * 根据key获取一个节点，并把节点从原来位置移除并放在链表头。

## 三、代码

```cpp
struct Node{
    int key;
    int value;
    Node* prev;
    Node* next;
    Node(int k = 0, int v = 0) : key(k), value(v){}
};

class LRUCache {
private:
    int capacity;
    Node* dummy;
    unordered_map<int, Node*> key_to_listNode;

    void remove(Node* node)
    {
        node->prev->next = node->next;
        node->next->prev = node->prev;
    }

    void push_front(Node* node)
    {
        node->prev = dummy;
        node->next = dummy->next;
        node->prev->next = node;
        node->next->prev = node;
    }

    Node* get_node(int k){
        auto iter = key_to_listNode.find(k);
        if (iter == key_to_listNode.end()){
            return nullptr;
        }
        Node* node = iter->second;  // 获取节点
        remove(node);                   // 将节点从之前位置移除
        push_front(node);               // 将节点添加在链表头
        return node;
    }

public:
    LRUCache(int capacity):capacity(capacity), dummy(new Node()) {
        dummy->prev = dummy;
        dummy->next = dummy;
    }
    
    int get(int key) {
        Node* node = get_node(key);    // get_node 会把对应节点移动至链表头部
        return nullptr == node ? -1 : node->value;
    }
    
    void put(int key, int value) {
        Node* node = get_node(key);
        if (nullptr != node){
            node->value = value;
            return;
        }

        node = new Node(key, value);
        // 哈希表中添加
        key_to_listNode[key] = node;
        // 双向链表中添加
        push_front(node);
        if (key_to_listNode.size() > capacity){
            Node* backnode = dummy->prev;
            key_to_listNode.erase(backnode->key);
            remove(backnode);
            delete backnode;
        }
        return;
    }
};

/**
 * Your LRUCache object will be instantiated and called as such:
 * LRUCache* obj = new LRUCache(capacity);
 * int param_1 = obj->get(key);
 * obj->put(key,value);
 */
```

