# 00_链表总结

----Lee

## 一、概述

* 链表分为：单向链表、双向链表、循环链表。

* 其存储的方式是分散的，通过指针其内部的指针域联系起来。
* 链表的增删改查需要熟悉。
* 链表在不同场景下的性能分析。

## 二、虚拟头节点

对于链表中一指定节点进行操作时，不能按照数组的思维直接定位到对应节点，而是应该位移值该节点之前。

这就会引入一个问题，链表的头节点怎么办呢？

可以使用虚拟头节点指向链表的头结点，后续可以继续按照数组的思维进行操作了。

## 三、增删改查

对于链表在头部、尾部、中间部的插入。指定节点的删除。在实际操作中`while`循环到底使用何种条件，还是需要不断学习。

* 要时刻考虑入参是空链表、单元素链表。此时`while`循环中的变量若需对其进行解引用访问，是否会引发访问野指针的问题？
* 在`while`循环中将要使用那个节点，就判断其对应内容。
* 先明确 “要操作哪个节点”：

  - 仅访问当前节点 → 条件 `cur != null`（不遗漏最后一个）；
  - 要操作 `cur.next`（删除 / 修改）→ 条件 `cur.next != null`（确保下一个存在）；
  - 要操作 `cur.next.next`（快慢指针 / 跨节点）→ 条件 `cur != null && cur.next != null`（双重防护）。
* 空链表特殊处理：

  所有遍历前先判断 `head == null`，直接返回（避免后续 `cur = head` 后，`cur` 为 null 导致循环内操作报错）。

* 循环链表防死循环：

  必须以 “回到起点” 为终止条件（不能用 `cur != null`，因为循环链表无空节点）。

## 四、双指针

* 快慢指针：
  * [19_删除链表的倒数第N个节点.md](./19_删除链表的倒数第N个节点.md)
  * [160_链表相交.md](./160_链表相交.md)
* `pre`、`cur`、`cur_nextNode`指针（`cur`节点插入至`cur_nextNode`之后）
  * [25_K个一组反转链表.md](./25_K个一组反转链表.md)
  * [92_反转链表2.md](./92_反转链表2.md)
  * [328_奇偶链表.md](./328_奇偶链表.md)
* 双指针
  * [206_反转链表.md](./206_反转链表.md)
  * [445_两数相加_链表.md](./445_两数相加_链表.md)

## 五、传统思维

* 基本操作：
  * [707_设计链表.md](./707_设计链表.md)
  * [203_移除链表元素.md](./203_移除链表元素.md)
* 特殊思路：也可以使用双指针完成
  * [24_两两交换链表中的节点.md](./24_两两交换链表中的节点.md)

## 六、小结

* 动手画！动手画！动手画！一画解千愁(☞ﾟヮﾟ)☞

