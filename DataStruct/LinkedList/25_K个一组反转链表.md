# 25_K个一组反转链表

----Lee

***

## 一、题目

给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。

`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。

你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex1.jpg)

```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/10/03/reverse_ex2.jpg)

```
输入：head = [1,2,3,4,5], k = 3
输出：[3,2,1,4,5]
```

 

**提示：**

- 链表中的节点数目为 `n`
- `1 <= k <= n <= 5000`
- `0 <= Node.val <= 1000`

**进阶：**你可以设计一个只用 `O(1)` 额外内存空间的算法解决此问题吗？

## 二、思路

参考：[92_反转链表2](./92_反转链表2.md)的反转思路: **可以理解位将`cur`插入到`cur_nextCode`之后**。

* 不要被题目所迷惑，本质还是在反转，使用与"反转链表2"中相同的反转思路即可。
* 同时获取链表长度/k（反转组成员数量）= 要进行多少组反转。
* 可以使用简单的链表验证每组要反转多少次（k - 1）;
* 反转后`cur`在新一次反转的`pre`位置：`pre = cur; cur = cur->next;`更新位置即可。

拓展：对于链表的反转不要将思路局限在[24_两两交换链表中的节点.md](./24_两两交换链表中的节点.md)交换方式。

## 三、代码

```c
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */
struct ListNode* reverseKGroup(struct ListNode* head, int k) {
    // 入参校验
    if (NULL == head || k <= 0)
    {
        return head;
    }

    // 设置虚拟头节点
    typedef struct ListNode ListNode;
    ListNode* fakeNode = (ListNode*)malloc(sizeof(ListNode));
    if (NULL == fakeNode)
    {
        return head;
    }
    fakeNode->next = head;

    // 每k个元素倒序
    ListNode* pre =  fakeNode;
    ListNode* cur = pre->next;
    ListNode* cur_nextNode = NULL;
    
    // 计算需要排序的组合数
    int sizeOfList = 0;
    while(NULL != cur)
    {
        cur = cur->next;
        sizeOfList++;
    }

    int countOfRevers = sizeOfList / k;
    cur = pre->next;
    int i = 0;
    for(i = 0; i < countOfRevers; ++i)
    {
        int j = 0;
        for (j = 0; j < k - 1; j++)
        {
            cur_nextNode = cur->next;
            // 可以理解位将cur插入到cur_nextCode之后
            cur->next = cur_nextNode->next;
            cur_nextNode->next = pre->next;
            pre->next = cur_nextNode;       
        }

        pre = cur;
        cur = cur->next;
    } 

    ListNode* result = fakeNode->next;
    free(fakeNode);
    return result;
}
```

