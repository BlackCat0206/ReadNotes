# 28. 实现 strStr()

## 一、题目

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回 -1。

示例 1: 输入: haystack = "hello", needle = "ll" 输出: 2

示例 2: 输入: haystack = "aaaaa", needle = "bba" 输出: -1

说明: 当 needle 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。 对于本题而言，当 needle 是空字符串时我们应当返回 0 。这与C语言的 strstr() 以及 Java的 indexOf() 定义相符。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

## 二、思路

### KMP

* 核心思想：**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了**

* next数组 前缀表有什么作用呢？
  * **前缀表是用来回退的，它记录了模式串与主串(文本串)不匹配的时候，模式串应该从哪里开始重新匹配**。

* 什么是前缀表：**记录下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀**。

![KMP详解1](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B21.gif)

### 最长公共前后缀

* 前缀：不包含最后一个字符的所有以第一个字符开头的连续子串。
* 后缀：不包含第一个字符的所有以最后一个字符结尾的子串。
* **因为前缀表要求的就是相同前后缀的长度**。
* 字符串a的最长相等前后缀为0。 字符串aa的最长相等前后缀为1。 字符串aaa的最长相等前后缀为2。 

### 为什么一定要用前缀表

**下标5之前这部分的字符串（也就是字符串aabaa）的最长相等的前缀 和 后缀字符串是 子字符串aa ，因为找到了最长相等的前缀和后缀，匹配失败的位置是后缀子串的后面，那么我们找到与其相同的前缀的后面重新匹配就可以了。**

既其提供了当前匹配失败后，应该回到那个地址重新匹配。

### 如何计算前缀表

接下来就要说一说怎么计算前缀表。

如图：

![KMP精讲5](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B25.png)

长度为前1个字符的子串`a`，最长相同前后缀的长度为0。（注意字符串的**前缀是指不包含最后一个字符的所有以第一个字符开头的连续子串**；**后缀是指不包含第一个字符的所有以最后一个字符结尾的连续子串**。）

![KMP精讲6](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B26.png)

长度为前2个字符的子串`aa`，最长相同前后缀的长度为1。

![KMP精讲7](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B27.png)

长度为前3个字符的子串`aab`，最长相同前后缀的长度为0。

以此类推： 长度为前4个字符的子串`aaba`，最长相同前后缀的长度为1。 长度为前5个字符的子串`aabaa`，最长相同前后缀的长度为2。 长度为前6个字符的子串`aabaaf`，最长相同前后缀的长度为0。

那么把求得的最长相同前后缀的长度就是对应前缀表的元素，如图： ![KMP精讲8](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B28.png)

可以看出模式串与前缀表对应位置的数字表示的就是：**下标i之前（包括i）的字符串中，有多大长度的相同前缀后缀。**

再来看一下如何利用 前缀表找到 当字符不匹配的时候应该指针应该移动的位置。如动画所示：

![KMP精讲2](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B22.gif)

找到的不匹配的位置， 那么此时我们要看它的前一个字符的前缀表的数值是多少。

为什么要前一个字符的前缀表的数值呢，因为要找前面字符串的最长相同的前缀和后缀。

所以要看前一位的 前缀表的数值。

前一个字符的前缀表的数值是2， 所以把下标移动到下标2的位置继续比配。 可以再反复看一下上面的动画。

最后就在文本串中找到了和模式串匹配的子串了。

### 前缀表与next数组

next数组就可以是前缀表，但是很多实现都是把前缀表统一减一（右移一位，初始位置为-1）之后作为next数组。

为什么这么做呢，其实也是很多文章视频没有解释清楚的地方。

其实**这并不涉及到KMP的原理，而是具体实现，next数组既可以就是前缀表，也可以是前缀表统一减一（右移一位，初始位置为-1）。**

### 使用next数组来匹配

**以下我们以前缀表统一减一之后的next数组来做演示**。

有了next数组，就可以根据next数组来 匹配文本串s，和模式串t了。

注意next数组是新前缀表（旧前缀表统一减一了）。

匹配过程动画如下：

![KMP精讲4](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B24.gif)

### 构造next数组

我们定义一个函数getNext来构建next数组，函数参数为指向next数组的指针，和一个字符串。

**构造next数组其实就是计算模式串s，前缀表的过程。** 主要有如下三步：

1. 初始化
2. 处理前后缀不相同的情况
3. 处理前后缀相同的情况

1.初始化：

定义两个指针i和j，j指向前缀末尾位置，i指向后缀末尾位置。然后还要对next数组进行初始化赋值，如下：

```cpp
int j = -1;
next[0] = j;
```

j 为什么要初始化为 -1呢，因为之前说过 **前缀表要统一减一的操作仅仅是其中的一种实现**，我们这里选择j初始化为-1，下文我还会给出j不初始化为-1的实现代码。

**next[i] 表示 i（包括i）之前最长相等的前后缀长度（其实就是j）**，所以初始化next[0] = j 。

2.处理前后缀不相同的情况

因为j初始化为-1，那么i就从1开始，进行s[i] 与 s[j+1]的比较。

所以遍历模式串s的循环下标i 要从 1开始，代码如下：

```cpp
for (int i = 1; i < s.size(); ++i);
```

如果`s[i]`与`s[j+1]`不同的，就要向前回退。

如何回退？：`next[j]`中记录着`j`（包括`j`）之前的字串的相同前后缀的长度。

那么 `s[i]` 与 `s[j+1]` 不相同，就要找 `j+1`前一个元素在`next`数组里的值（就是`next[j]`）。

所以，处理前后缀不相同的情况代码如下：

```cpp
while(j >= 0 && s[i] != s[j + 1])	// 前后缀不相同
{
    j = s[j];		// 向前回退
}
```

3.处理前后缀相同的情况

如果 `s[i]` 与 `s[j + 1]` 相同，那么就同时向后移动i 和j 说明找到了相同的前后缀，同时还要将j（前缀的长度）赋给next[i], 因为next[i]要记录相同前后缀的长度。

代码如下：

```cpp
if (s[i] == s[j + 1]) { // 找到相同的前后缀
    j++;
}
next[i] = j;
```

整体逻辑是：

```cpp
void getNext(int* next, const string& s)
{
    int j = -1;
    next[0] = j;
    for (int i = 1; i < s.size(); i++)
    {
        if (j >=0; s[i] != s[j+1])	// 前后缀不相同
        {	
            j = s[j];				// 回退
        }
        
        if (s[i] == s[j+1])
        {
            j++;
        }
        next[i] = j;				// 将前缀长度赋值给next[i]
    }
}
```

代码构造next数组的逻辑流程动画如下：

![KMP精讲3](https://file1.kamacoder.com/i/algo/KMP%E7%B2%BE%E8%AE%B23.gif)

构造next数组，不减一

```cpp
void getNext(int* next, const string& s)
{
    int j = 0;
    next[0] = j
    for (int i = 1; i < s.size(); i++)
    {
        //如果不匹配了
        while (j > 0 && s[i] != s[j])
        {
            j = next[j - 1];
        }
        
        // 如果匹配了
        if (s[i] == s[j])
        {
            j++;
        }
        next[i] = j; // 将前缀长度赋值给next[i]
    }
}
```

* 当前字符不匹配，需要缩短前缀长度，避免从头匹配。

## 三、代码

```cpp
class Solution {
public:
    void getNext(int* next, const string& s)
    {
        int j = 0;
        next[0] = j;
        for (int i = 1; i < s.size(); ++i)
        {
            // 如果不匹配的话，进行回退，避免从头开始匹配
            while (j > 0 && s[i] != s[j])
            {
                j = next[j - 1];
            }

            if (s[i] == s[j])
            {
                j++;
            }

            next[i] = j;
        }
        return;
    }


    int strStr(string haystack, string needle) 
    {
        if (0 == haystack.size() || 0 == needle.size())
        {
            return -1;
        }

        // 创建next数组
        vector<int> needleNext(needle.size());
        getNext(&needleNext[0], needle);

        int j = 0;
        int needleLength = needle.size();
        for (int i = 0; i < haystack.size(); i++)
        {
            while (j > 0 && haystack[i] != needle[j])
            {
                j = needleNext[j - 1];
            }

            if (haystack[i] == needle[j])
            {
                j++;
            }

            if (j == needleLength)
            {
                return i - needleLength + 1;
            }
        }
        return -1;
    }
};
```

