# 56_合并区间

---- Chime Lee

## 一、题目

以数组 `intervals` 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回 *一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间* 。

**示例 1：**

```
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

**示例 2：**

```
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```

**示例 3：**

```
输入：intervals = [[4,7],[1,4]]
输出：[[1,7]]
解释：区间 [1,4] 和 [4,7] 可被视为重叠区间。
```

**提示：**

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

[力扣题目链接](https://leetcode.cn/problems/merge-intervals/description/?envType=study-plan-v2&envId=top-100-liked)

## 二、思路

* 左端点排序+lambda表达式

```cpp
sort(nums.begin(), nums.end(), 
    [](const vector<int>& a, const vector<int>& b){
        // 考虑首元素相同的情况
        if (a[0] != b[0]){
            return a[0] < b[0]
        }
        return a[1] < b[1];
    })
```

* 左端点，获取当前右端点，遍历每一个元素。
  * 下一个元素的左端点 <= 当前右端点，合并（**注意判断右端点的最大值**）
  * 下一个元素的左端点 > 当前右端点，记录当前左右端点构成的集合，并更新左右端点重复上述操作

```cpp
vector<vector<int>> res;
for (auto& p : intervals){
    if (!res.empty() && p[0] <= ans.back()[1])	// 可以合并
    {
        ans.back()[1] = max(ans.back()[1], p[1]);	// 更新右端点最大值
    }
    else	// 不相交
    {
        ans.emplace_back(p);	// 添加新的合并区间
    }
}
```

* 时间复杂度：`O(nlogn)`，n是`intervals`的长度，瓶颈在排序上。

* 空间复杂度：`O(1)`

## 三、代码

```cpp
class Solution {
public:
    vector<vector<int>> merge(vector<vector<int>>& intervals) {
        // 入参校验
        if (intervals.empty())
        {
            return {};
        }

        // 按左端点排序
        sort(intervals.begin(), intervals.end(),
            [](const vector<int>& a, const vector<int>& b){
                if (a[0] != b[0]){
                    return a[0] < b[0];
                }
                return a[1] < b[1];
            }
        );

        vector<vector<int>> res;
        for(auto& p : intervals)
        {
            if (!res.empty() && p[0] <= res.back()[1])
            {     // 可以合并
                res.back()[1] = max(res.back()[1], p[1]);   // 更新右端最大值
            }
            else
            {
                res.emplace_back(p);
            }
        }
        return res;
    }
};
```

