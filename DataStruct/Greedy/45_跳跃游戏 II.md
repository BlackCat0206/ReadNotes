# 45_跳跃游戏 II

---- Lee

## 一、题目

给定一个长度为 `n` 的 **0 索引**整数数组 `nums`。初始位置在下标 0。

每个元素 `nums[i]` 表示从索引 `i` 向后跳转的最大长度。换句话说，如果你在索引 `i` 处，你可以跳转到任意 `(i + j)` 处：

- `0 <= j <= nums[i]` 且
- `i + j < n`

返回到达 `n - 1` 的最小跳跃次数。测试用例保证可以到达 `n - 1`。

**示例 1:**

```
输入: nums = [2,3,1,1,4]
输出: 2
解释: 跳到最后一个位置的最小跳跃数是 2。
     从下标为 0 跳到下标为 1 的位置，跳 1 步，然后跳 3 步到达数组的最后一个位置。
```

**示例 2:**

```
输入: nums = [2,3,0,1,4]
输出: 2
```

**提示:**

- `1 <= nums.length <= 104`
- `0 <= nums[i] <= 1000`
- 题目保证可以到达 `n - 1`

## 二、思路

核心思路：与跳跃游戏相同，范围能够覆盖，就满足条件。

* 入参大小为1，直接返回0。

* 当前位置的范围。`curCover`
* 下一步位置的范围。`nextCover`
* 遍历整个数组：
  * 计算当前范围。
  * 当前范围内的**每个元素的覆盖范围取最大值作为下一步的覆盖范围**。
  * 当`i == curCover`时，更新步数+1，将`curCover`更新为`nextCover`，并判断覆盖范围是否超过了数组的范围。 跳出循环，返回结果。
* 若出现首元素是`0`，则返回步数是0。

## 三、代码

```cpp
class Solution {
public:
    int jump(vector<int>& nums) {
        if (nums.size() == 1){
            return 0;
        }

        int curCover = 0;   // 当前覆盖范围
        int nextCover = 0;  // 下一步的覆盖范围
        int ans = 0;
        for (int i = 0; i < nums.size(); ++i){
            // 计算下一步覆盖范围
            nextCover = max(i + nums[i], nextCover);
            
            // 当抵达当前范围后
            if (i == curCover){
                ans++;          // 更新步数
                curCover = nextCover;
                if (nextCover >= nums.size() - 1){
                    break;
                }
            }
        }
        return ans;
    }
};
```

