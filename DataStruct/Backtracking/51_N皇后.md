# 51_N皇后

----Lee

## 一、题目

按照国际象棋的规则，皇后可以攻击与之处在同一行或同一列或同一斜线上的棋子。

**n 皇后问题** 研究的是如何将 `n` 个皇后放置在 `n×n` 的棋盘上，并且使皇后彼此之间不能相互攻击。

给你一个整数 `n` ，返回所有不同的 **n 皇后问题** 的解决方案。

每一种解法包含一个不同的 **n 皇后问题** 的棋子放置方案，该方案中 `'Q'` 和 `'.'` 分别代表了皇后和空位。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/13/queens.jpg)

```
输入：n = 4
输出：[[".Q..","...Q","Q...","..Q."],["..Q.","Q...","...Q",".Q.."]]
解释：如上图所示，4 皇后问题存在两个不同的解法。
```

**示例 2：**

```
输入：n = 1
输出：[["Q"]]
```

**提示：**

- `1 <= n <= 9`

## 二、思路

* 本质是全排列的基础上进行条件限制。
* 决策树：
  * 横向：决策每一行中`Q`的位置
  * 纵向：执行每一个行的`Q`的选择

**递归三要素：**

* 函数返回值和参数

```cpp
vector<vector<string>> ans;
vector<string> cheekboard(n, string(n, '.'));
void backtracing(vector<string>& cheekboard, int row, int n){}
```

* 函数终止条件：当前行数与传入行数匹配

```cpp
if (row == n){
    ans.push_back(checkboard);
    return;
}
```

* 单次执行逻辑：判断当前位置是否符合要求，若符合修改cheekboard对应元素，并，继续递归，结束后回溯。

```cpp
for (int i = 0; i < n; ++i){
    if (isValid(cheekboard,row, i, n)){
        cheekboard[row][i] = 'Q';	// 标记
        backtracking(cheekboard, row + 1, n);
        cheekboard[row][i] = '.';	// 回溯
    }
}
```

**判断当前位置是否符合要求：**

```cpp
bool isVaild(vector<string>& cheekboard, int row, int column, int n){
    // 判断所在之前行中是否有相同列的Q
    for (int i = 0; i < row; ++i){
        if (cheekboard[i][column] == 'Q'){
            return false;
        }
    }
    
    // 判断左上角45度是否有Q
    for (int i = row - 1, j = column - 1; 0 <= i && 0 <=j; --i, --j){
        if (cheekboard[i][j] == 'Q'){
            return false;
        }
    }
    
    // 判断右上角135度是否有Q
    for (int i = row - 1, j = column + 1; 0 <= i && j < n; --i, ++j){
        if (cheekboard[i][j] == 'Q'){
            return false;
        }
    }
    return true;
}
```

## 三、代码

```cpp
class Solution {
    vector<vector<string>> ans;
public:
    bool isValid(vector<string>& cheesboard, int rows, int column, int n)
    {
        // 判断列中是否有棋子
        for (int i = 0; i < rows; i++){
            if (cheesboard[i][column] == 'Q'){
                return false;
            }
        }

        // 向上判断45度是否有棋子
        for (int x = rows -1, y = column - 1;
        x >= 0 && y >= 0; --x,--y)
        {
            if (cheesboard[x][y] == 'Q'){
                return false;
            }
        }

        // 向上判断135度是否有棋子
        for (int x = rows - 1, y = column + 1;
        x >= 0 && y < n; --x,++y)
        {
            if (cheesboard[x][y] == 'Q'){
                return false;
            }
        }
        return true;
    }

    void backtracking(int n, int rows, vector<string>& cheesboard){
        if (rows == n)
        {
            ans.push_back(cheesboard);
        }

        for (int i = 0; i < n; ++i)
        {
            if (isValid(cheesboard, rows, i, n))
            {
                cheesboard[rows][i] = 'Q';
                backtracking(n, rows + 1, cheesboard);
                cheesboard[rows][i] = '.';
            }
        }
        return;
    }

    vector<vector<string>> solveNQueens(int n) {
        vector<string> cheesboard(n, string(n, '.'));
        ans.clear();
        backtracking(n, 0, cheesboard);
        return ans;
    }
};
```

