# 79_单词搜索

---- Lee

## 一、题目

给定一个 `m x n` 二维字符网格 `board` 和一个字符串单词 `word` 。如果 `word` 存在于网格中，返回 `true` ；否则，返回 `false` 。

单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word2.jpg)

```
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCCED"
输出：true
```

**示例 2：**

![img](https://assets.leetcode.com/uploads/2020/11/04/word-1.jpg)

```
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "SEE"
输出：true
```

**示例 3：**

![img](https://assets.leetcode.com/uploads/2020/10/15/word3.jpg)

```
输入：board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = "ABCB"
输出：false
```

## 二、思路

决策树：

* 横向：选中单个元素。纵向：上下左右移动

* 如果当前`word`的遍历下标 == `word.size()`，返回true；

* 判断`board`当前位置的元素是否与`word`对应位置的元素相同，相同则继续搜索。
* 将对应元素置0
* 搜索过程上下左右移动，使用一个二维数组保存。同时判断边界，继续递归。
* 将对应元素恢复
* 每个元素都可以作为起点。

**递归三要素**：

* 函数返回值和参数：

```cpp
bool backtracking(vector<int>& borad, int row, int column, int k, int n);	// 当前元素的行，列，与word元素的下标
```

* 返回条件：word遍历至最后一个元素，或当前元素与遍历元素不相同

```cpp
if (k - 1 == n){
    return true;
}

if (board[rows][columns] != word[k]){
    return false;
}
```

* 单次遍历的元素



## 三、代码

```cpp
class Solution{
    const int DIRC[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
public:
    bool exist(vector<int> board, string& word)
    {
        int rows = board.size();
        int columns = board[0].size();
        auto dfs = [&](this auto&& dfs, int row, int column, int k)->bool{
            if (board[row][column] != word[k]){
                return false;
            }
            
            if (k + 1 = word.size()){
                return true;
            }
            
            // 标记元素已使用
            board[row][column] = 0;
            
            // 进行上下左右搜索
            for (auto& [x, y] : DIRC){
                int i = row + x;
                int j = column + y;
                if (0 <= i && i < rows
                 && 0 <= j && j < columns
                 && dfs(i, j, k + 1))
                {
                    return true;
                }
            }
            // 恢复操作
            board[rows][columns] = word[k];
            return false;
        };
        
        
        // 每个元素都可以作为起点：
        for (int i = 0; i < rwos; ++i){
            for (int j = 0; j < columns; ++j){
                if(dfs(i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }
};
```

**优化一：**

* 统计字符块与字符串中每个字符出现的次数，若字符串的字符在字符块中未出现或出现次数大于字符串中对应字符出现次数，则一定不匹配，直接返回false。

**优化二：**

* 比较字符串中首元素和尾元素在字符块中出现的次数，若尾元素出现次数小于首元素，则反转字符串，让遍历快速返回false。

```cpp
class Solution {
    static constexpr int DIRS[4][2] = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};
public:
    bool exist(vector<vector<char>>& board, string word) {
        unordered_map<char, int> cnt;
        for (auto& ros: board){
            for (char c : ros){
                cnt[c]++;
            }
        }

        // 优化一
        unordered_map<char, int> word_cnt;
        for (char c : word){
            if (++word_cnt[c] > cnt[c]){
                return false;
            }
        }

        // 优化二
        if (cnt[word.back()] < cnt[word[0]]){
            reverse(word.begin(), word.end());
        }

        int rows = board.size();
        int columns = board[0].size();
        auto dfs = [&](this auto&& dfs, int i, int j, int k)->bool
        {
            if (board[i][j] != word[k]){
                return false;
            }

            if (k + 1 == word.size()){
                return true;
            }

            board[i][j] = 0;    // 标记已访问过
            for (auto& [dx, dy] : DIRS)
            {
                int x = i + dx;
                int y = j + dy;
                if (0 <= x && x < rows 
                && 0 <= y && y < columns 
                && (true == dfs(x, y, k + 1)))
                {
                    return true;
                }
            }
            board[i][j] = word[k];  // 恢复
            return false;
        };

        for (int i = 0; i < rows; ++i){
            for (int j = 0; j < columns; ++j){
                if (dfs(i, j, 0)){
                    return true;
                }
            }
        }
        return false;
    }
};
```

