## 560_和为K的子数组

---- Lee

## 一、题目

给你一个整数数组 `nums` 和一个整数 `k` ，请你统计并返回 *该数组中和为 `k` 的子数组的个数* 。

子数组是数组中元素的连续非空序列。

**示例 1：**

```
输入：nums = [1,1,1], k = 2
输出：2
```

**示例 2：**

```
输入：nums = [1,2,3], k = 3
输出：2
```

**提示：**

- `1 <= nums.length <= 2 * 104`
- `-1000 <= nums[i] <= 1000`
- `-107 <= k <= 107`

## 二、思路

* 前缀和 + 哈希表

* 前缀和：`s[0] = 0; s[0]=0, s[i]=nums[0]+nums[1]+⋯+nums[i−1]`。

  * 注意`s`是一个长为`n+1`的数组，第一项一定是0。最后一项下标是`n`。
  * `s[j] - s[i]` 就表示数组：`nus[i]到num[j - 1]的元素和`。

  示例：

  1.前缀和的定义

  前缀和（`preSum`）是指从数组**起始位置**到当前位置的累加和，通常定义：

  - `preSum[0] = 0`（空数组的和，作为基准）；
  - `preSum[i] = nums[0] + nums[1] + ... + nums[i-1]`（前 `i` 个元素的和，对应数组下标 `0~i-1`）。

  2.基础计算示例（数组无负数）

  以数组 `nums = [3, 5, 2, -1, 7]` 为例，手动计算前缀和数组：

  | 前缀和索引  | 对应数组范围              | 计算过程  | 前缀和结果 |
  | ----------- | ------------------------- | --------- | ---------- |
  | `preSum[0]` | 空数组（无元素）          | 0         | 0          |
  | `preSum[1]` | `nums[0]`                 | 0 + 3     | 3          |
  | `preSum[2]` | `nums[0] + nums[1]`       | 3 + 5     | 8          |
  | `preSum[3]` | `nums[0]+nums[1]+nums[2]` | 8 + 2     | 10         |
  | `preSum[4]` | `nums[0]~nums[3]`         | 10 + (-1) | 9          |
  | `preSum[5]` | `nums[0]~nums[4]`         | 9 + 7     | 16         |

  最终前缀和数组：`preSum = [0, 3, 8, 10, 9, 16]`。

  ##### 示例：计算 `nums[1 ... 3]`（即 `5,2,-1`）的和

  - 对应 `j=1`，`i=3`；
  - 计算：`preSum[4] - preSum[1] = 9 - 3 = 6`；
  - 验证：`5 + 2 + (-1) = 6`，结果一致。

* 问题的本质是查找`s[j] - s[i] == k`的个数，那么也可以转换为：`s[i] == s[j] - k`的个数，那这是否就回归了梦开始的两数之和呢？

```cpp
unordered_map<int, int> count;

for (auto sj : s){
    if (0 != count.contains(sj - k)){
        ans += count[sj -k];
    }
    count[sj]++;
}
```

## 三、代码

```cpp
int subarraySum(vector<int>& nums, int k){
    // 入参校验
    if (nums.empty()){
        return 0;
    }
    
    // 计算前缀和
    vector<int> sumFront(nums.size() + 1);
    for (int i = 0; i < nums.size(); ++i){
        sumFront[i + 1] = sumFront[i] + nums[i];
    }
    
    // 参考两数之和，使用unordered_map进行遍历
    unordered_map<int, int> countMap;
    
    // 创建临时变量计算结果
    int result = 0;
    
    for (int sj : sumFront){
        if (0 != countMap.contains(sj - k)){
            result += countMap[sj - k];
        }
        countMap[sj]++;
    }
    
    return result;
}
```

