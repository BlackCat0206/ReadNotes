# 11_盛最多水的容器

---- Lee

## 一、题目

给定一个长度为 `n` 的整数数组 `height` 。有 `n` 条垂线，第 `i` 条线的两个端点是 `(i, 0)` 和 `(i, height[i])` 。

找出其中的两条线，使得它们与 `x` 轴共同构成的容器可以容纳最多的水。

返回容器可以储存的最大水量。

**说明：**你不能倾斜容器。

**示例 1：**

![img](https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/07/25/question_11.jpg)

```
输入：[1,8,6,2,5,4,8,3,7]
输出：49 
解释：图中垂直线代表输入数组 [1,8,6,2,5,4,8,3,7]。在此情况下，容器能够容纳水（表示为蓝色部分）的最大值为 49。
```

**示例 2：**

```
输入：height = [1,1]
输出：1
```

**提示：**

- `n == height.length`
- `2 <= n <= 105`
- `0 <= height[i] <= 104`

## 二、思路

![initial-state](https://pic.leetcode-cn.com/9341a245384b77afda31ed8b4040d7a382be107a2d22c0e1fc2652a21707cf8c.jpg)



* 如何计算最大容器呢？

  * 下标只差 * 下标对应元素的最小值

  ```cpp
  int area = (right - left) * min(height[left], height[right]);
  ```

  * 当前计算的内容与记录内容取最大值

  ```cpp
  int maxArea = max(maxArea, area);
  ```

* 最大的困难是什么？

  * 每次移动下标时，底部的长（`left - right`），和元素最小值（`min(height[left], height[right])`）的宽同时改变。导致除去一个暴力双`for`循环，很难有其他思路。

* 双指针：感谢`leetcode`用户`nettee`题解。[题解链接](https://leetcode.cn/problems/container-with-most-water/solutions/94102/on-shuang-zhi-zhen-jie-fa-li-jie-zheng-que-xing-tu)

  * 如下图所示，在一开始，我们考虑相距最远的两个柱子所能容纳水的面积。水的宽度是两根柱子之间的距离 d=8；水的高度取决于两根柱子之间较短的那个，即左边柱子的高度 h=3。水的面积就是 3×8=24。

  ![initial-state](https://pic.leetcode-cn.com/9341a245384b77afda31ed8b4040d7a382be107a2d22c0e1fc2652a21707cf8c.jpg)

  * 如果选择固定一根柱子，另外一根变化，水的面积会有什么变化吗？稍加思考可得：

    * 当前柱子是最两侧的柱子，水的宽度 d 为最大，其他的组合，水的宽度都比这个小。

    * 左边柱子较短，决定了水的高度为 3。如果移动左边的柱子，新的水面高度不确定，一定不会超过右边的柱子高度 7。

    * 如果移动右边的柱子，新的水面高度一定不会超过左边的柱子高度 3，也就是不会超过现在的水面高度。

  * 由此可见，如果固定左边的柱子，移动右边的柱子，那么**水的高度一定不会增加，且宽度一定减少**，所以水的面积一定减少。这个时候，左边的柱子和任意一个其他柱子的组合，其实都可以排除了。也就是我们可以排除掉左边的柱子了。
  * 个人理解：
    * 左柱子 < 右柱子：	
      * 若右柱子左移：底边一定减少，且高度一定不会高于左柱子。（减少是必然的）
      * 若左柱子右移动：底边一定减少，但高度一定不会高于右柱子。（减少是未知的）
      * 我们选择去除已知而比较未知。

## 三、代码

```cpp
class Solution {
public:
    int maxArea(vector<int>& height) {
        int res = 0;
        int left = 0;
        int right = height.size() - 1;
        while (left < right){
            int area = (right - left) * min(height[left], height[right]);
            res = max(res, area);
            if (height[left] < height[right]){
                ++left;
            }
            else{
                --right;
            }
        }
        return res;
    }
};
```



