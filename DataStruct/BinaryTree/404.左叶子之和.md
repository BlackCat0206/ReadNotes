# 404.左叶子之和

---- Lee

## 一、题目

计算给定二叉树的所有左叶子之和。

示例：

![404.左叶子之和1](https://file1.kamacoder.com/i/algo/20210204151927654.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/sum-of-left-leaves/)

## 二、思路

* 递归三要素：
* 确认返回值类型和传入参数：返回左右子树的左叶子节点的值，处理当前节点。

```cpp
int sumOfLeftLeaves(TreeNode* cur);
```

* 确认终止条件：如果当前节点为空，返回0。

```cpp
if (NULL == cur) return 0;
```

* 单次遍历处理逻辑：判断当前节点的左节点是否是左叶子节点，若是，则将其数值赋值到返回的左叶子节点值中。获取右子树的左叶子节点的值。将二者求和返回。

```cpp
int leftValue = sumOfLeftLeaves(cur->left);
if (NULL != cur->left && NULL == cur->left->left && NULL == cur->right->right){
    leftValue = cur->left->val;
}
int rightValue = sumOfLeftLeaves(cur->right);

return leftValue + rightValue;
```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int sumOfLeftLeaves(TreeNode* root) {
        if (NULL == root){
            return 0;
        }
        int leftValue = sumOfLeftLeaves(root->left);
        // 判断当前节下是否左叶子
        if (NULL != root->left 
        && NULL == root->left->left 
        && NULL == root->left->right){
            leftValue = root->left->val;
        }
        int rightValue = sumOfLeftLeaves(root->right);

        return leftValue + rightValue;
    }
};
```

