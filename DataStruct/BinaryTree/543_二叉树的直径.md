# 543_二叉树的直径

---- Lee

## 一、题目

给你一棵二叉树的根节点，返回该树的 **直径** 。

二叉树的 **直径** 是指树中任意两个节点之间最长路径的 **长度** 。这条路径可能经过也可能不经过根节点 `root` 。

两节点之间路径的 **长度** 由它们之间边数表示。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/03/06/diamtree.jpg)

```
输入：root = [1,2,3,4,5]
输出：3
解释：3 ，取路径 [4,2,1,3] 或 [5,2,1,3] 的长度。
```

**示例 2：**

```
输入：root = [1,2]
输出：1
```

**提示：**

- 树中节点数目在范围 `[1, 104]` 内
- `-100 <= Node.val <= 100`

## 二、思路

* 注意：题中所求为距离最大的两个节点，不一定要经过`root`节点。例如：左子树为空，右子树的左右节点间距100。这就要计算右子树的最长距离了。

* 空节点：链的长度是-1。

* 叶子节点：链的长度是0。

* 每次获取之后+1，既上一个节点到当前节点的距离。

* **实时获取最大左右链长度之和。**第一次编写时，犯了经验主义的错误，很执着于返回根节点后再计算。

  ```cpp
  int ans = 0;	// 全局变量，实时记录最大链路
  ```

* 递归三要素：

  * 函数返回值和参数列表

  ```cpp
  int dfsTree(TreeNode* node);
  ```

  * 终止条件

  ```cpp
  if (nullptr == node){
      return -1;		// 空节点的链长-1
  }
  ```

  * 每次迭代实现的内容

  ```cpp
  int l_len = dfs(node->left) + 1;
  int r_len = dfs(node->right) + 1;
  ans = max(ans, l_len + r_len);
  return max(l_len + r_len);
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    int diameterOfBinaryTree(TreeNode* root) {
        int ans = 0;
        auto dfs = [&](this auto&& dfs, TreeNode* node) -> int{
            if (nullptr == node){
                return -1;
            }

            int l_len = dfs(node->left) + 1;
            int r_len = dfs(node->right) + 1;
            ans = max(ans, l_len + r_len);
            return max(l_len, r_len);
        };
        dfs(root);
        return ans;
    }
};
```

