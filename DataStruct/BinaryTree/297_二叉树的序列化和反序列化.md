# 297_二叉树的序列化和反序列化

---- Lee

## 一、题目

序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。

请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，你只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。

**提示:** 输入输出格式与 LeetCode 目前使用的方式一致，详情请参阅 [LeetCode 序列化二叉树的格式](https://support.leetcode.cn/hc/kb/article/1567641/)。你并非必须采取这种方式，你也可以采用其他的方法解决这个问题。

**示例 1：**

![img](https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg)

```
输入：root = [1,2,3,null,null,4,5]
输出：[1,2,3,null,null,4,5]
```

**示例 2：**

```
输入：root = []
输出：[]
```

**示例 3：**

```
输入：root = [1]
输出：[1]
```

**示例 4：**

```
输入：root = [1,2]
输出：[1,2]
```

**提示：**

- 树中结点数在范围 `[0, 104]` 内
- `-1000 <= Node.val <= 1000`

[力扣题目链接](https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/)

## 二、思路

* **对数据序列化的结果要进行分割**：二叉树节点的元素不一定只是示例中的个位数，也会有负数。故我们对每个元素使用`','`进行分割，对于空节点使用`Null`表示。对于数据元素使用`to_string`进行转换。

* **序列化：**

  * 前序遍历 （`DFS`）：
    * 对传入的空节点：对序列化字符串拼接"`Null,`"，返回即可。
    * 有元素数据的节点：使用`to_string（）`转换，并拼接"`,`"。

  ```cpp
  void serializeHelper(TreeNode* node, string& str){
      if (nullptr == node){
          str += "Null,"
          return;
      }
      
      str += to_string(node->val) + ",";
      serializeHelper(node->left, str);
      serializeHelper(node->right, str);
      return;
  }
  
  string serialize(TreeNode* root){
      string result = "";
      serializeHelper(root, result);
      return result;
  }
  ```

* 反序列化：

  * 节点元素的获取：
    * **将每个分割的字符元素，逐个存入容器(list：要进行频繁的删减，使用vector会超时)中，后序逐个处理**。
    * 将传入序列化的字符串中的**字符逐个遍历**。逐个填充至临时`string`类型遍历中直至“,”，将临时变量填充至容器中，清空临时变量，继续遍历直至结束。
    * 遍历结束后，校验临时遍历是否为空，不为空则继续填充后制空。

  ```cpp
  TreeNode* deserialize(string& data){
      if (data.empty()){
          return nullptr;
      }
      
      string str = "";
      list<string> dataArray;
      for (char c : data){
          if ("," == c){
              dataArray.push_back(str);
              str.clear();
          }
          else{
              str.push_back(c);
          }
      }
      
      if (!str.empty()){
          dataArray.push_back(str);
          str.clear();
      }
      
      // 反序列化
      return deserializeHelper(dataArray);
  }
  ```

  * 前序遍历（`BFS`）: 递归三要素

    * 函数参数和返回值类型：需要构造节点，处理传入数据。

    ```cpp
    TreeNode* deserializeHelper(list<string>& dataArray)
    ```

    * 终止条件：传入节点为空，或者传入数据的首节点是"Null"，销毁首节点，返回`nullptr`。

    ```cpp
    if (dataArray.empty()){
        return nullptr;
    }
    
    if ("Null" == dataArray.front()){
        dataArray.erase(dataArray.begin());	// 使用迭代器！！！
        return nullptr;
    }
    ```

    * 单次遍历要实现的逻辑：创建当前节点,销毁传入链表首节点，并递归处理其左右子树，返回当前节点。

    ```cpp
    TreeNode* node = new TreeNode(stoi(dataArray.front()));
    dataArray.erase(dataArray.begin());
    
    node->left  = deserializeHelper(dataArray);
    node->right = deserializeHelper(dataArray);
    
    return node;
    ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:

/**
 * @brief 序列化二叉树（前序遍历）DFS
 * @param [in] TreeNode* root 二叉树根节点
 * @param [in,out] string& result 序列化结果字符串
 * @return void
 */
void serializeHelper(TreeNode* node, string& str){
    if (nullptr == node){
        str += "Null,";
    }
    else{
        str += to_string(node->val) + ",";
        serializeHelper(node->left, str);
        serializeHelper(node->right, str);
    }
    return;
}

/**
 * @brief 序列化二叉树
 * @param [in] TreeNode* root 二叉树根节点
 * @return string 序列化后的字符串
 */
string serialize(TreeNode* root) {
    string result = "";
    serializeHelper(root, result);
    return result;
}

/**
 * @brief 反序列化二叉树 （前序遍历） DFS
 * @param [in] list<string> strs 序列化各个节点元素
 * @return TreeNode* 构造的新节点
 */
TreeNode* deserializeHelper(list<string>& strs){
    if (strs.empty()){
        return nullptr;
    }

    if ("Null" == strs.front()){
        strs.erase(strs.begin());
        return nullptr;
    }

    TreeNode* node = new TreeNode(stoi(strs.front()));
    strs.erase(strs.begin());
    node->left = deserializeHelper(strs);
    node->right = deserializeHelper(strs);
    return node;
}

/**
 * @brief 反序列化二叉树
 * @param [in] string data 序列化后的字符串
 * @return TreeNode* 二叉树根节点
 */
TreeNode* deserialize(const string& data) {
    list<string> dataArray;
    string str;
    for (char c : data){
        if (',' == c){
            dataArray.push_back(str);
            str.clear();
        }
        else{
            str.push_back(c);
        }
    }

    if (!str.empty()){
        dataArray.push_back(str);
        str.clear();
    }
    return deserializeHelper(dataArray);
}
};

// Your Codec object will be instantiated and called as such:
// Codec ser, deser;
// TreeNode* ans = deser.deserialize(ser.serialize(root));
```

## 四、源码

[serialBinaryTree.cpp](./SourceCode/serialBinaryTree.cpp)

