# 654_最大二叉树

---- Lee

## 一、题目

给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：

- 二叉树的根是数组中的最大元素。
- 左子树是通过数组中最大值左边部分构造出的最大二叉树。
- 右子树是通过数组中最大值右边部分构造出的最大二叉树。

通过给定的数组构建最大二叉树，并且输出这个树的根节点。

示例 ：

![654.最大二叉树](https://file1.kamacoder.com/i/algo/20210204154534796.png)

提示：

给定的数组的大小在 [1, 1000] 之间。

[力扣题目地址(opens new window)](https://leetcode.cn/problems/maximum-binary-tree/)

## 二、思路

* 递归三要素：
* **明确返回值和参数类型**：
  * **返回值类型**：需要返回一个节点，返回值类型：`TreeNode`。
  * **参数类型**：处理传入的数组，参数类型：`vector<int>`。

```cpp
TreeNode* buildTree(vector<int>& nums)
```

* **终止条件**：当传入的数组的长度为1时，既就剩当前一个节点，构建后直接返回。

```cpp
if (1 == nums.size()){
    return new TreeNode(nums[0]);
}
```

* **单次遍历实现的内容**：
  * 查找数组中最大数，并标注其下标。
  * 根据最大数构建节点。
  * 更具下标进行数组左右切割。

```cpp
        // 获取当前数组中最大值与其对应下标
        int maxValue = INT_MIN;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++){
            if (nums[i] > maxValue){
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }

        // 构建当前节点
        TreeNode* node = new TreeNode(maxValue);

        // 切割当前节点左侧数据，同时排除maxValueIndex == 0的情况
        if (0 < maxValueIndex){
            // 左闭右开
            vector<int> numsLeft(nums.begin(), nums.begin() + maxValueIndex);
            node->left = buildTreeNode(numsLeft);
        }

        // 切割当前节点右侧数据，同时排除maxValueIndex == nums.size() - 1
        if (maxValueIndex < nums.size() - 1){
            // 左闭右开
            vector<int> numsRight(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = buildTreeNode(numsRight);
        }
```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTreeNode(vector<int>& nums){
        // 分割数组长度为1，既到达叶子节点
        if (1 == nums.size()){
            return new TreeNode(nums[0]);
        }

        // 获取当前数组中最大值与其对应下标
        int maxValue = INT_MIN;
        int maxValueIndex = 0;
        for (int i = 0; i < nums.size(); i++){
            if (nums[i] > maxValue){
                maxValue = nums[i];
                maxValueIndex = i;
            }
        }

        // 构建当前节点
        TreeNode* node = new TreeNode(maxValue);

        // 切割当前节点左侧数据，同时排除maxValueIndex == 0的情况
        if (0 < maxValueIndex){
            // 左闭右开
            vector<int> numsLeft(nums.begin(), nums.begin() + maxValueIndex);
            node->left = buildTreeNode(numsLeft);
        }

        // 切割当前节点右侧数据，同时排除maxValueIndex == nums.size() - 1
        if (maxValueIndex < nums.size() - 1){
            // 左闭右开
            vector<int> numsRight(nums.begin() + maxValueIndex + 1, nums.end());
            node->right = buildTreeNode(numsRight);
        }

        return node;
    }

    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        if (0 == nums.size()){
            return nullptr;
        }

        TreeNode* root = buildTreeNode(nums);
        return root;
    }
};
```

