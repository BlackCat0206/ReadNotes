# 235. 二叉搜索树的最近公共祖先

---- Lee

## 一、题目

给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉搜索树: root = [6,2,8,0,4,7,9,null,null,3,5]

![235. 二叉搜索树的最近公共祖先](https://file1.kamacoder.com/i/algo/20201018172243602.png)

示例 1:

- 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
- 输出: 6
- 解释: 节点 2 和节点 8 的最近公共祖先是 6。

示例 2:

- 输入: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
- 输出: 2
- 解释: 节点 2 和节点 4 的最近公共祖先是 2, 因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉搜索树中。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/)

## 二、思路

* 二叉搜索树元素是有序，那么p与q的公共节点一定在`[p, q]`范围之内的。

* 递归三部曲：

  * 返回值和参数类型：
  * 返回值类型：节点指针，若查找到[p, q]范围内的节点则直接返回即可。
  * 参数类型：
    * 当前节点指针
    * 要查询的子节点指针 *  2

  ```cpp
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q)
  ```

  * 确认终止条件：当前节点为空就返回

  ```cpp
  if (nullptr == root){
      return nullptr;
  }
  ```

  * 单次遍历要实现的操作：引导遍历方向趋近于[p, q]之内
    * 如果当前的值的返回在`[p, q]`的**右侧**，既比节点`p`，`q`的值都**大**，就要查询去遍历当前节点的**左子树**。
    * 如果当前的值的返回在`[p, q]`的**左侧**，既比节点`p`，`q`的值都**小**，就要查询去遍历当前节点的**右子树**。
    * 去除上述两种情况，既当前节点在`[p, q]`区间之内，返回当前节点。

  ```cpp
  if (p->val < root->val && q->val < root->val){
      TreeNode* left = lowestCommonAncestor(root->left, p ,q);
      if (nullptr != left){
          return left;
      }
  }
  
  if (p->val > root->val && q->val > root->val){
      TreeNode* right = lowestCommonAncestor(root->right, p, q);
      if (nullptr != right){
          return right;
      }
  }
  
  return root;
  ```

  

