# 226_翻转二叉树

----Lee

## 一、题目

翻转一棵二叉树。

![226.翻转二叉树](https://file1.kamacoder.com/i/algo/20210203192644329.png)

这道题目背后有一个让程序员心酸的故事，听说 Homebrew的作者Max Howell，就是因为没在白板上写出翻转二叉树，最后被Google拒绝了。（真假不做判断，全当一个乐子哈）

[力扣题目链接(opens new window)](https://leetcode.cn/problems/invert-binary-tree/)

## 二、思路

* 遍历每个节点，反转它的左右子树。
* 按照递归遍历的方式，最好选择前序和后序。

* 递归三要素

  * 明确参数类型和返回值类型：反转每个节点的左右节点，参数传入当前节点即可。

  ```cpp
  void reserverTreeNode(TreeNode* cur)
  ```

  * 终止条件：当遇到空节点时就返回

  ```cpp
  if (NULL == cur) return;
  ```

  * 单次递归实现的内容：

  ```cpp
  swap(cur->left, cur->right);
  reserverTreeNode(cur->left);
  reserverTreeNode(cur->right);
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:

    void reserverTreeNode(TreeNode* cur)
    {
        if (NULL == cur)
        {
            return;
        }
        swap(cur->left, cur->right);
        reserverTreeNode(cur->left);
        reserverTreeNode(cur->right);
    }
    
    TreeNode* invertTree(TreeNode* root) {
        reserverTreeNode(root);
        return root;
    }
};x
```

