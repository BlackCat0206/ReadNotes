# 106.从中序与后序遍历序列构造二叉树

---- Lee

## 一、题目

根据一棵树的中序遍历与后序遍历构造二叉树。

注意: 你可以假设树中没有重复的元素。

例如，给出

- 中序遍历 inorder = [9,3,15,20,7]
- 后序遍历 postorder = [9,15,7,20,3] 返回如下的二叉树：

![106. 从中序与后序遍历序列构造二叉树1](https://file1.kamacoder.com/i/algo/20210203154316774.png)

[力扣题目链接(opens new window)](https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/)

## 二、思路

如果让我们肉眼看两个序列，画一棵二叉树的话，应该分分钟都可以画出来。

流程如图：

![106.从中序与后序遍历序列构造二叉树](https://file1.kamacoder.com/i/algo/20210203154249860.png)

在次过程中，需要一层一层的切割：

* 第一步：若遇到的遍历数组为空，则说明到空节点，直接返回`nullptr`。
* 第二步：若数组大小为1，说明到了叶子节点，构建一个对应元素值的节点，并将其元素`pop`，返回。
* 第三步：取最后一个元素作为节点元素，构建一个节点。
* 第四步：找到节点元素在中序遍历数组中的位置，准备切割。
* 第五步：切割中序数组，实现中序左子树序列，中序右子树序列，在此过程中：
  * 跳过切割元素的节点。其已经被构建为一个节点。
  * 注意区间，建议使用-前闭后开。
* 第六步：后序遍历序列中**左子树遍历长度**一定**中序遍历的左子树遍历数组长度相同**，依次实现遍历。
  * 注意区间：建议使用-前闭后开。
* 第七步：递归处理左区间和右区间。

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        // 遍历数组为空，返回空节点
        if (0 == inorder.size() || 0 == postorder.size()){
            return nullptr;
        }

        // 以后序遍历的最后一个节点作为切割点
        int rootVal = postorder.back();
        TreeNode* root = new TreeNode(rootVal);
        // 若仅剩一个元素，则其为叶子节点，直接返回即可。
        if (1 == postorder.size()){
            postorder.pop_back();
            return root;
        }

        // 最后一个节点以作为切割点，不能再适用，要去除。
        postorder.pop_back();

        // 找到中序遍历中的切割点位置
        vector<int>::iterator iter = find(inorder.begin(), inorder.end(), rootVal);
        int index = distance(inorder.begin(), iter);

        // 切割中序遍历数组，切割过程中去除找到的中间节点
        // 前闭后开[begin(), index)
        vector<int> inorderLeft(inorder.begin(), inorder.begin() + index);
        // 前闭后开[begin + index + 1, end)
        vector<int> inorderRight(inorder.begin() + index + 1, inorder.end());

        // 后序遍历的左右子树的遍历结果的长度一定是长度的。
        int leftLength = inorderLeft.size();

        // 切割后序遍历，在此之前已经去除原数组中最后一个原节点，不需要多考虑。
        // 前闭后开[begin, begin + leftLength)
        vector<int> postorderLeft(postorder.begin(), postorder.begin() + leftLength);
        // 前闭后开[begin + leftLength, end)
        vector<int> postorderRight(postorder.begin() + leftLength, postorder.end());

        root->left = buildTree(inorderLeft, postorderLeft);
        root->right = buildTree(inorderRight, postorderRight);

        return root;
    }
};
```

