# 501.二叉搜索树中的众数

---- Lee

## 一、题目

给定一个有相同值的二叉搜索树（BST），找出 BST 中的所有众数（出现频率最高的元素）。

假定 BST 有如下定义：

- 结点左子树中所含结点的值小于等于当前结点的值
- 结点右子树中所含结点的值大于等于当前结点的值
- 左子树和右子树都是二叉搜索树

例如：

给定 BST [1,null,2,2],

![501. 二叉搜索树中的众数](https://file1.kamacoder.com/i/algo/20201014221532206.png)

返回[2].

提示：如果众数超过1个，不需考虑输出顺序

进阶：你可以不使用额外的空间吗？（假设由递归产生的隐式调用栈的开销不被计算在内）

[力扣题目链接(opens new window)](https://leetcode.cn/problems/find-mode-in-binary-search-tree/)

## 二、思路

* 题目提示：**可能不止一个众数！！！**

* 中序遍历：使用外部遍历记录上一节点与相同节点的个数，当一元素频率等于另一元素时，填充元素。若频率大于记录最大频率，清空之前记录，更新现有元素与频率。

* 递归三要素：

  * 确认返回值类型和参数
    * 返回值类型：普通遍历，需要数据返回，void.
    * 参数：当前节点：`TreeNode*`。

  ```cpp
  void findMode(TreeNode* cur);
  ```

  * 终止条件：
    * 当前节点为空，就返回。

  ```cpp
  if (nullptr == cur){
      return true;
  }
  ```

  * 单次遍历要实现的内容：
    * 计算左子树的众数
    * 判断上一节点与当前节点是否相同，相同计数变量累加。若不同，更新记录最大值（取二者最大值），计数变量回归为1。
    * `pre`节点更新为当前节点
    * 计算右子树的众数

  ```cpp
  findMode(cur->left);
  if (nullptr == pre){
      count = 1;
  }
  eles if (pre->val == cur->val){
      count++;
  }
  else{
      count = 1;
  }
  
  if (count == countMax){
      countMax = count;
      res.push_back(cur->val);
  }
  
  if (count > countMax){
      countMax = count;
      res.clear();
      res.push_back(cur->val);
  }
  
  pre = cur;
  findMode(cur->right);
  ```

## 三、代码

```cpp
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int count = 1;
    vector<int> res;
    int countMax = 1;
    TreeNode* pre = nullptr;
    void traversal(TreeNode* cur){
        if (nullptr == cur){
            return;
        }

        traversal(cur->left);
        
        if (nullptr == pre){
            count = 1;
        }
        else if (pre->val == cur->val){
            count++;
        }
        else{
            count = 1;
        }
        pre = cur;
        
        if (count == countMax){
            countMax = count;
            res.push_back(cur->val);
        }

        if (count > countMax){
            countMax = count;
            res.clear();
            res.push_back(cur->val);
        }

        findMode(cur->right);
        return;
    }
    
    vector<int> findMode(TreeNode* root) {
        traversal(root);
        return res;
    }
};
```



