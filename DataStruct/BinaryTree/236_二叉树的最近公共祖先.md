# 236. 二叉树的最近公共祖先

## 一、题目

给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。

百度百科中最近公共祖先的定义为：“对于有根树 T 的两个结点 p、q，最近公共祖先表示为一个结点 x，满足 x 是 p、q 的祖先且 x 的深度尽可能大（一个节点也可以是它自己的祖先）。”

例如，给定如下二叉树: root = [3,5,1,6,2,0,8,null,null,7,4]

![236. 二叉树的最近公共祖先](https://file1.kamacoder.com/i/algo/20201016173414722.png)

示例 1: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 输出: 3 解释: 节点 5 和节点 1 的最近公共祖先是节点 3。

示例 2: 输入: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 输出: 5 解释: 节点 5 和节点 4 的最近公共祖先是节点 5。因为根据定义最近公共祖先节点可以为节点本身。

说明:

- 所有节点的值都是唯一的。
- p、q 为不同节点且均存在于给定的二叉树中。

[力扣题目链接(opens new window)](https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/)

## 二、思路

* 对于共同的祖先节点会有两种情况：
* 情况一：

![img](https://file1.kamacoder.com/i/algo/20220922173502.png)

* 情况二

  ![img](https://file1.kamacoder.com/i/algo/20220922173530.png)

* 本题的过程中需要对节点从下向上进行遍历：后序遍历。

* 递归三要素

  * 确认函数返回值和参数类型：
    * 返回值：节点指针（若为子节点或nullptr则返回）。
    * 参数类型：
      * 当前节点指针，处理当前节点，获取其左右子树遍历的结果。
      * 查询`节点指针 * 2`

  ```cpp
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q);
  ```

  * 终止条件：
    * 若当前节点是空，则返回nullptr
    * 若当前节点为查找节点，返回当前节点。

  ```cpp
  if (nullptr == root || p == root || q == root){
      return root;
  }
  ```

  * 单次遍历要执行的内容:
    * 获取当前节点的左右节点遍历的结果。
    * 若返回左节点为空，右节点不为空，则返回右节点。
    * 若返回左节点不为空，右节点为空，则返回左节点。
    * 若返回的左右节点均不为空，则返回当前节点。

  ```cpp
  TreeNode* left = lowestCommonAncestor(root->left, p, q);
  TreeNode* right = lowestCommonAncestor(root->right, p, q);
  
  if (nullptr != left && nullptr == right){
      return left;
  }
  else if (nullptr == left && nullptr != right){
      return right;
  }
  else if (nullptr != left && nullptr != right){
      return root;
  }
  else{
      return nullptr;
  }
  ```

  ## 三、代码

  ```cpp
  /**
   * Definition for a binary tree node.
   * struct TreeNode {
   *     int val;
   *     TreeNode *left;
   *     TreeNode *right;
   *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
   * };
   */
  class Solution {
  public:
      TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
          if (nullptr == root || p == root || q == root){
              return root;
          }
  
          TreeNode* left = lowestCommonAncestor(root->left, p , q);
          TreeNode* right = lowestCommonAncestor(root->right, p, q);
  
          if (nullptr != left && nullptr == right){
              return left;
          }
          else if (nullptr == left && nullptr != right){
              return right;
          }
          else if (nullptr != left && nullptr != right){
              return root;
          }
          else{
              return nullptr;
          }
      }
  };
  ```

  