# 202_快乐数

---- Lee

## 一、题目

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

**示例 1：**

```
输入：n = 19
输出：true
解释：
12 + 92 = 82
82 + 22 = 68
62 + 82 = 100
12 + 02 + 02 = 1
```

**示例 2：**

```
输入：n = 2
输出：false
```

**提示：**

- `1 <= n <= 231 - 1`

[202.快乐数](https://leetcode.cn/problems/happy-number/description/)

## 二、思路

* 注意题目中的描述“**无限循环**”，既若一个结果重复出现一次，就会陷入无限循环。
* 计算操作：对于输入数的每一个进行平方和，并进行数据清除。
* 容器选择：可以使用`set`或`unordered_set`对每次计算的结果进行存储和查询，若有则返回false，若无则将结果填充，继续计算。
* `unorderded_set`使用原因：`Hash`表虽然有数据开销的风险，但是为了对结果的快速查找，选择`unordered_set`

## 三、代码

```cpp
class Solution {
public:
    /**
    * @brief 计算传入数据各位的平方和
    * @param [in] num
    * @return int newNum
    */
    int getSum(int num)
    {
        int newNum = 0;
        while(0 != num)
        {   
            // 计算各位的平方和
            newNum += (num%10) * (num%10);

            // 清除已经计算过的位
            num /= 10;
        }
        return newNum;
    }

    bool isHappy(int n) {
        // 入参校验
        if (n <= 0)
        {
            return false;
        }

        // 数据范围相对较小，将每次的结果放入unordered_set<int>中，对每次计算的结果进行快速查找
        unordered_set<int> unSet;
        int newSum = 0;
        while(1)
        {
            newSum = getSum(n);
            if (1 == newSum)
            {
                // 结果为1，返回true
                return true;
            }
            
            if (unSet.find(newSum) != unSet.end())
            {
                // 陷入循环，返回false
                return false;
            }
            else
            {
                unSet.insert(newSum);
            }
            n = newSum;
        }
    }
};
```

- 时间复杂度: O(logn)
- 空间复杂度: O(logn)