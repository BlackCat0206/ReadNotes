# 00_图论

---- Lee

## 一、概念

二维坐标中，两点可以连成线，多个点连成的线构成了图。

图也可以就一个节点，甚至没有节点。

## 二、图的种类

**有向图：**

有向图是指 图中边是有方向的：

![img](https://file1.kamacoder.com/i/algo/20240510195737.png)

**无向图：**

无向图是指 图中边没有方向：

![img](https://file1.kamacoder.com/i/algo/20240510195451.png)

加权有向图，就是图中边是有权值的，例如：

![img](https://file1.kamacoder.com/i/algo/20240510195821.png)

加权无向图也是同理

## 三、度

无向图有几个边连接该节点，该节点就有几度。

例如，该无向图中，节点4的度为5，节点6的度为3。

![img](https://file1.kamacoder.com/i/algo/20240511115029.png)

在有向图中，每个节点有出度和入度。

出度：从该节点出发的边的个数。

入度：指向该节点边的个数。

例如，该有向图中，节点3的入度为2，出度为1，节点1的入度为0，出度为2。

![img](https://file1.kamacoder.com/i/algo/20240511115235.png)

## 连通性

在图中表示节点的连通情况，我们称之为连通性。

### 连通图

在无向图中，任何两个节点都是可以到达的，我们称之为连通图 ，如图：

![img](https://file1.kamacoder.com/i/algo/20240511102351.png)

如果有节点不能到达其他节点，则为非连通图，如图：

![img](https://file1.kamacoder.com/i/algo/20240511102449.png)

节点1 不能到达节点4。

**强连通图**是在有向图中**任何两个节点是可以相互到达**

下面这个有向图才是强连通图：

![img](https://file1.kamacoder.com/i/algo/20240511113101.png)

### 连通分量

在无向图中的**极大连通子图**称之为该图的一个连通分量。

只看概念大家可能不理解，我来画个图：

![img](https://file1.kamacoder.com/i/algo/20240511111559.png)

该无向图中 节点1、节点2、节点5 构成的子图就是 该无向图中的一个连通分量，该子图所有节点都是相互可达到的。

同理，节点3、节点4、节点6 构成的子图 也是该无向图中的一个连通分量。

**那么无向图中 节点3 、节点4 构成的子图 是该无向图的联通分量吗？**

不是！

因为必须是**极大联通子图**才能是连通分量，所以 必须是节点3、节点4、节点6 构成的子图才是连通分量。

在图论中，连通分量是一个很重要的概念，例如岛屿问题（后面章节会有专门讲解）其实就是求连通分量。

### 强连通分量

在有向图中极大强连通子图称之为该图的强连通分量。

如图：

![img](https://file1.kamacoder.com/i/algo/20240511112951.png)

节点1、节点2、节点3、节点4、节点5 构成的子图是强连通分量，因为这是强连通图，也是极大图。

节点6、节点7、节点8 构成的子图 不是强连通分量，因为这不是强连通图，节点8 不能达到节点6。

节点1、节点2、节点5 构成的子图 也不是 强连通分量，因为这不是极大图。

## 图的构造

* 朴素存储

**邻接矩阵**：

* `nxn`矩阵，下标表示节点，元素表示权值。

* 适用于边很多的情况下，使用邻接矩阵。稠密图，点少边多。

**邻接表**：

* 数组和链表组合而成。
* 适用于节点很多，边很少的情况。稀疏图，点多边少

## 图的遍历

深度优先搜索（`DFS`）:

* 遇到终点或起点，曾经访问过的节点后，回溯最近一次搜索操作，改变搜索方向，继续搜索。

* 深度搜索三部曲：

  * 确认函数和参数：

  ```cpp
  vector<vector<int>> result;
  vector<int> path;
  void dfs(图，目前搜索的节点)
  ```

  * 终止条件：

  ```cpp
  if (终止条件){
      存放结果；
      return;
  }
  ```

  * 单词处理过程：

  ```cpp
  for (选择：本节点连接的节点){
      处理节点；
      dfs(图，选择的节点)；
      回溯，撤销处理结果；
  }
  ```

* 整体模板：

```cpp
vector<vector<int>> result;
vector<int> path;
void dfs(图，目前搜索的节点)
{
	if (终止条件){
    	存放结果；
    	return;
	}
    
	for (选择：本节点连接的节点){
    	处理节点；
    	dfs(图，选择的节点)；
    	回溯，撤销处理结果；
	}    
}
```

**广度优先搜索**（`BFS`）：

* 搜索方向：上下左右
* 搜索方式：使用队列进行遍历，使用额外的数组对已遍历的元素进行标记。

```cpp
int dir[4][2] = {0, 1, 1, 0, -1, 0, 0, -1}; // 表示四个方向
// grid 是地图，也就是一个二维数组
// visited标记访问过的节点，不要重复访问
// x,y 表示开始搜索节点的下标
void bfs(vector<vector<char>>& grid, vector<vector<bool>>& visited, int x, int y) {
    queue<pair<int, int>> que; // 定义队列
    que.push({x, y}); // 起始节点加入队列
    visited[x][y] = true; // 只要加入队列，立刻标记为访问过的节点
    while(!que.empty()) { // 开始遍历队列里的元素
        pair<int ,int> cur = que.front(); que.pop(); // 从队列取元素
        int curx = cur.first;
        int cury = cur.second; // 当前节点坐标
        for (int i = 0; i < 4; i++) { // 开始想当前节点的四个方向左右上下去遍历
            int nextx = curx + dir[i][0];
            int nexty = cury + dir[i][1]; // 获取周边四个方向的坐标
            if (nextx < 0 || nextx >= grid.size() || nexty < 0 || nexty >= grid[0].size()) continue;  // 坐标越界了，直接跳过
            if (!visited[nextx][nexty]) { // 如果节点没被访问过
                que.push({nextx, nexty});  // 队列添加该节点为下一轮要遍历的节点
                visited[nextx][nexty] = true; // 只要加入队列立刻标记，避免重复访问
            }
        }
    }

}
```

