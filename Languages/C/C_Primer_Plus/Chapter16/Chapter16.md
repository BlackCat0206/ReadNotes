# Chapter16_C预处理器和C库

本章系统讲解 C 预处理器的工作机制与常用指令，以及 C 标准库的核心组件与使用方法，是编写高效、可移植 C 代码的基础。

***---- Li Jinsheng***

## 一、翻译阶段：预处理前的准备
在预处理开始前，编译器会对源代码进行3步转换，确保预处理器能正确解析：
1. **字符映射**：将源代码字符映射到源字符集，处理多字节字符和三字符序列，提升C语言的国际化支持。
2. **物理行合并**：删除反斜杠（\）后跟换行符的组合，将多个物理行合并为一个逻辑行，允许预处理指令跨多行书写。
3. **文本划分**：将代码拆分为预处理记号（token）、空白序列和注释序列，注释会被单个空格替换，避免干扰宏展开。

## 二、明示常量：#define
### 2.1 基本用法
`#define`用于定义宏（符号常量或类函数宏），语法为：
```c
#define 宏名 替换体
```
- **类对象宏**：如`#define PI 3.14159`，用于定义常量，提升代码可读性和可维护性。
- **类函数宏**：如`#define SQUARE(x) ((x)*(x))`，通过参数实现类似函数的功能，宏展开时直接替换文本，无函数调用开销。

### 2.2 关键特性
- **记号化替换**：预处理器将替换体视为记号序列而非字符串，空格仅作为分隔符，不参与替换。
- **重定义规则**：若新定义与旧定义的记号序列完全一致，重定义合法；否则可能报错或警告，建议避免重定义。
- **括号保护**：类函数宏的参数和整体需用括号包裹，防止运算符优先级导致的计算错误，例如`SQUARE(x+2)`展开为`((x+2)*(x+2))`。

## 三、带参数宏的高级用法
### 3.1 #运算符：字符串化
将宏参数转换为字符串常量，语法为`#参数`：
```c
#define STR(x) #x
printf("%s\n", STR(hello)); // 输出 "hello"
```
常用于调试信息输出，快速生成变量名对应的字符串。

### 3.2 ##运算符：记号连接
将两个记号合并为一个新记号，语法为`参数1##参数2`：
```c
#define JOIN(a, b) a##b
int JOIN(num, 123) = 456; // 定义变量 num123 = 456
```
适用于动态生成变量名、函数名，减少重复代码。

### 3.3 变参宏：...与__VA_ARGS__
支持不定长参数，`...`表示可变参数列表，`__VA_ARGS__`在替换体中展开为参数：
```c
#define LOG(format, ...) printf(format, __VA_ARGS__)
LOG("x = %d, y = %d\n", 10, 20); // 等价于 printf("x = %d, y = %d\n", 10, 20)
```
常用于日志输出、调试信息打印等场景。

## 四、宏与函数的选择
| 特性         | 宏                                 | 函数                               |
| :----------- | :--------------------------------- | :--------------------------------- |
| **执行效率** | 高，无调用开销，直接内联替换       | 低，存在函数调用/返回开销          |
| **内存占用** | 高，多次调用生成多份代码副本       | 低，仅一份函数体，多次调用共享     |
| **类型检查** | 无，参数类型由替换上下文决定       | 有，编译器严格检查参数和返回值类型 |
| **调试难度** | 高，宏展开后代码变长，不易定位问题 | 低，可通过断点调试逐行执行         |
| **适用场景** | 简单运算、频繁调用的短代码         | 复杂逻辑、需类型安全或递归的场景   |

**选择建议**：简单常量用`const`，频繁调用的短逻辑用宏，复杂功能优先用函数。

## 五、文件包含：#include
### 5.1 两种形式
- **系统头文件**：`#include <stdio.h>`，编译器从系统标准库路径查找文件。
- **自定义头文件**：`#include "myheader.h"`，编译器先从当前目录查找，再搜索系统路径。

### 5.2 头文件保护
避免头文件被重复包含导致的重复定义错误，常用两种方式：
1. **#pragma once**：非标准但主流编译器支持，直接放在头文件第一行，编译器确保文件仅包含一次。
2. **#ifndef...#define...#endif**：标准兼容，语法为：
    ```c
    #ifndef HEADER_NAME_H
    #define HEADER_NAME_H
    // 头文件内容
    #endif
    ```
    **推荐方案**：日常开发可用`#pragma once`，跨平台或兼容老旧编译器时用传统保护，也可两者混用提升兼容性。

## 六、其他预处理指令
### 6.1 #undef：取消宏定义
用于移除已定义的宏，语法为`#undef 宏名`，之后可重新定义该宏，即使宏未定义，`#undef`也不会报错。

### 6.2 条件编译
通过指令控制编译器是否编译某段代码，常用于跨平台适配和调试：
| 指令           | 功能                             |
| :------------- | :------------------------------- |
| `#ifdef 宏名`  | 若宏已定义，编译后续代码         |
| `#ifndef 宏名` | 若宏未定义，编译后续代码         |
| `#if 表达式`   | 若表达式为真，编译后续代码       |
| `#elif 表达式` | 前一个条件为假时，判断当前表达式 |
| `#else`        | 所有条件为假时，编译后续代码     |
| `#endif`       | 结束条件编译块                   |

**示例**：
```c
#ifdef DEBUG
#define LOG_LEVEL 3
#else
#define LOG_LEVEL 1
#endif
```
也可用`#if defined(宏名)`替代`#ifdef`，支持与`#elif`组合使用。

### 6.3 预定义宏
C标准提供多个预定义宏，用于获取编译信息，常用如下：
| 宏         | 功能                            |
| :--------- | :------------------------------ |
| `__FILE__` | 当前源文件名（字符串常量）      |
| `__LINE__` | 当前行号（整数常量）            |
| `__DATE__` | 编译日期（格式："Mmm dd yyyy"） |
| `__TIME__` | 编译时间（格式："hh:mm:ss"）    |
| `__STDC__` | 若为1，表示编译器遵循ANSI C标准 |

**示例**：调试时输出错误位置：
```c
#define ERROR(msg) fprintf(stderr, "Error in %s at line %d: %s\n", __FILE__, __LINE__, msg)
ERROR("Invalid input");
```

### 6.4 #error与#line
- **#error**：强制编译器报错并输出指定信息，用于检查编译条件，如`#error "This code requires C99 or later"`。
- **#line**：修改当前行号和文件名，语法为`#line 行号 "文件名"`，主要用于代码生成工具，调整调试信息的准确性。

## 七、C11新特性
### 7.1 泛型选择：_Generic
根据表达式类型选择对应的代码分支，语法为：
```c
#define GEN_TYPE(x) _Generic((x), \
    int: "int", \
    float: "float", \
    double: "double", \
    default: "other")
printf("%s\n", GEN_TYPE(3.14)); // 输出 "double"
```
常用于编写类型通用的宏，提升代码复用性。

### 7.2 静态断言：_Static_assert
在编译期检查常量表达式，若为假则报错，语法为`_Static_assert(表达式, "错误信息")`：
```c
_Static_assert(sizeof(int) == 4, "int must be 4 bytes");
```
与运行时的`assert()`不同，静态断言能提前发现问题，避免程序运行时崩溃。

### 7.3 _Noreturn关键字
用于标记函数不会返回主调程序，如`exit()`函数，帮助编译器优化代码并提供更准确的静态检查。

## 八、C标准库核心组件
### 8.1 数学库（math.h）
提供三角函数、指数、对数、取整等数学运算，如`sqrt()`、`sin()`、`log()`，使用时需链接数学库（`-lm`选项）。
- **类型专用函数**：如`sqrtf()`（float）、`sqrtl()`（long double），提升精度或效率。
- **常用函数**：`pow(x, y)`计算x的y次幂，`fabs(x)`求浮点数绝对值，`ceil(x)`向上取整，`floor(x)`向下取整。

### 8.2 通用工具库
- **assert.h**：`assert(表达式)`用于调试，若表达式为假则终止程序并输出错误位置，`NDEBUG`宏可禁用断言。
- **stdlib.h**：包含内存分配（`malloc()`、`free()`）、数值转换（`atoi()`、`atof()`）、排序（`qsort()`）等函数，是C语言的核心工具库。
- **string.h**：提供字符串操作（`strcpy()`、`strcmp()`、`strlen()`）和内存操作（`memcpy()`、`memmove()`）函数，注意区分字符串与内存操作的差异。

### 8.3 可变参数处理（stdarg.h）
通过`va_list`、`va_start`、`va_arg`、`va_end`宏处理不定长参数，常用于实现printf-like函数：
```c
#include <stdarg.h>
void print_args(int count, ...) {
    va_list args;
    va_start(args, count); // 初始化参数列表
    for (int i = 0; i < count; i++) {
        printf("%d ", va_arg(args, int)); // 依次获取int类型参数
    }
    va_end(args); // 清理参数列表
}
print_args(3, 10, 20, 30); // 输出 10 20 30
```
**注意**：`va_arg`需明确指定参数类型，避免类型不匹配导致的未定义行为。

### 8.4 程序退出处理（stdlib.h）
- **exit(int status)**：终止程序，执行`atexit()`注册的清理函数，刷新输出流并关闭文件，`status`为退出状态（0表示正常）。
- **atexit(void (*func)(void))**：注册程序退出时调用的函数，最多可注册32个，调用顺序与注册顺序相反，用于资源释放、日志记录等清理工作。

## 九、关键编程实践
1. **头文件保护**：所有自定义头文件必须添加`#pragma once`或`#ifndef...#define...#endif`保护，防止重复包含。
2. **宏定义规范**：类函数宏的参数和整体用括号包裹，避免运算符优先级问题；复杂宏拆分多行时用反斜杠连接，保持可读性。
3. **库函数使用**：
    - 数学函数需链接`-lm`库。
    - 字符串操作注意缓冲区溢出，优先使用`strncpy()`、`snprintf()`等安全函数。
    - 动态内存分配后需检查是否成功，避免空指针访问。
4. **调试技巧**：结合`__FILE__`、`__LINE__`和`assert()`输出详细调试信息，快速定位问题；发布版本通过`NDEBUG`禁用断言，提升性能。

## 十、总结
本章覆盖了C预处理器的核心指令（`#define`、`#include`、条件编译等）和C标准库的关键组件，掌握这些知识能帮助你编写更高效、可移植、易维护的C代码。预处理器的文本替换特性虽强大，但需谨慎使用，避免宏展开导致的隐蔽错误；标准库则提供了丰富的工具函数，合理利用可大幅提升开发效率。

---

需要我把本章的**预处理器指令**和**常用库函数**整理成一份可直接复制的**速查清单**吗？这样你复习时能快速定位关键语法和用法。
