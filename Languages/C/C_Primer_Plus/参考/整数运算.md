# 整数运算

***---- Li Jinsheng***

***

## 一、概述

本章用于记录在C/C++中整数运算时具体内容。

## 二、内容

### 2.5 拓展： 整数的计算（按位）

在计算前，必须先将正数和负数转换为补码（计算机中存储的就是补码）：

- **正数**：符号位（最高位）为 `0`，数值位为二进制原码。
  例：`+5` 的 8 位补码 = `00000101`（符号位 0，数值位 0000101）。
- **负数**：符号位为 `1`，数值位为 “原码取反 + 1”（补码计算规则）。
  例：`-5` 的 8 位补码计算：
  1. 原码（假设）：`10000101`（符号位 1，数值位 0000101）；
  2. 取反（符号位不变，数值位反转）：`11111010`；
  3. 加 1：`11111011` → 最终 `-5` 的补码为 `11111011`。

#### 2.5.1 核心运算：加法（正数 + 正数、正数 + 负数、负数 + 负数）

所有加法均遵循 “**补码相加 → 舍弃超出位数的进位 → 结果按补码解释**” 的规则，无需区分参与运算的数是正还是负。

##### 1. 正数 + 正数（无进位 / 有进位）

本质是二进制原码相加，结果仍为正数。
例 1：`+3 + +4 = +7`

- `+3` 补码：`00000011`
- `+4` 补码：`00000100`
- 补码相加：`00000011 + 00000100 = 00000111`
- 结果解释（补码→十进制）：`00000111` 是 `+7`（正确）。

例 2：`+120 + +10 = +130`（8 位有符号数溢出）

- `+120` 补码：`01111000`
- `+10` 补码：`00001010`
- 补码相加：`01111000 + 00001010 = 10000010`（最高位产生进位 `1`，但 8 位存储时舍弃）
- 结果解释：`10000010` 是 8 位有符号数的补码，对应十进制 `-126`（溢出导致结果错误，需注意范围）。

##### 2. 正数 + 负数（本质是 “减法” 的转化）

例如 `+5 + (-3) = +2`，相当于 `5 - 3 = 2`，通过补码将减法转为加法。

- `+5` 补码：`00000101`
- `-3` 补码：`11111101`（计算过程：原码 10000011 → 取反 11111100 → 加 1=11111101）
- 补码相加：`00000101 + 11111101 = 100000010`（共 9 位，舍弃最高位的进位 `1`，保留 8 位 `00000010`）
- 结果解释：`00000010` 是 `+2`（正确）。

##### 3. 负数 + 负数

例如 `-4 + (-5) = -9`，补码相加后结果仍为负数补码。

- `-4` 补码：`11111100`
- `-5` 补码：`11111011`
- 补码相加：`11111100 + 11111011 = 111110111`（舍弃最高位进位 `1`，保留 8 位 `11110111`）
- 结果解释：`11110111` 是负数补码，反向计算原码：
  1. 减 1：`11110110`；
  2. 取反（符号位不变）：`10001001` → 对应十进制 `-9`（正确）。

#### 2.5.2 关键运算：减法（转化为 “加负数的补码”）

计算机中**没有专门的减法电路**，减法会被统一转化为 “被减数 + 减数的补码”（即 `a - b = a + (-b)`），再按加法规则计算。

例：`+7 - (+4) = +3`（即 `7 + (-4)`）

- `+7` 补码：`00000111`
- `-4` 补码：`11111100`（由 `+4` 补码 `00000100` 取反 + 1 得到）
- 补码相加：`00000111 + 11111100 = 100000011`（舍弃进位 `1`，保留 8 位 `00000011`）
- 结果解释：`00000011` 是 `+3`（正确）。

再例：`-3 - (-6) = +3`（即 `-3 + (+6)`）

- `-3` 补码：`11111101`
- `+6` 补码：`00000110`
- 补码相加：`11111101 + 00000110 = 100000011`（舍弃进位 `1`，保留 `00000011`）
- 结果解释：`+3`（正确）。

#### 2.5.3 乘法与除法的位运算逻辑

有符号整数的乘除也基于补码，但运算过程更复杂，核心是 “先按无符号数计算位，再处理符号”：

##### 1. 乘法

- 规则：**符号位单独计算（异或：正 × 正 = 正，正 × 负 = 负，负 × 负 = 正），数值位按无符号整数的二进制乘法计算**，最后将符号位与数值位组合成补码。
- 例：`+3 × (-2) = -6`
  1. 符号位：`0（正） XOR 1（负）= 1（负）`；
  2. 数值位：`3（00000011） × 2（00000010）= 6（00000110）`；
  3. 组合补码：符号位 1 + 数值位 00000110 → 原码 `10000110` → 补码 `11111010`（对应 `-6`，正确）。

##### 2. 除法

- 规则：**符号位同样用异或判断，数值位按 “移位减法” 实现**（类似十进制除法的 “试商”），结果向 0 取整（与 “向下取整” 不同，如 `-5 / 2 = -2`，而非 `-3`）。
- 例：`-7 ÷ 2 = -3`（实际数学结果是 `-3.5`，向 0 取整为 `-3`）
  1. 符号位：`1（负） XOR 0（正）= 1（负）`；
  2. 数值位：`7（00000111） ÷ 2（00000010）= 3（00000011）`；
  3. 组合补码：符号位 1 + 数值位 00000011 → 原码 `10000011` → 补码 `11111101`（对应 `-3`，正确）。

#### 2.5.4 负数赋值给无符号的整数

* 规则对负数进行“模运算”：

  * 1.对负数取绝对值；2.取补码；3.赋值
  * 当负数 `x` 赋值给 `n` 位无符号整数类型（如 `unsigned int` 通常为 32 位）时，结果为：

  ```c
  x + 2ⁿ  （直到结果落在 [0, 2ⁿ-1] 范围内）
  ```

* 例：

  ```c
  unsigned int u = -1;  // 32位系统中，结果为 4294967295（0xFFFFFFFF）
  unsigned int v = -5;  // 结果为 4294967291（0xFFFFFFFB）
  ```

#### 2.5.4 总结：有符号整数计算的核心逻辑

1. **统一编码**：所有有符号数（正 / 负）在计算机中均以 **补码** 形式存储和参与运算，无需单独处理符号位。
2. **减法转加法**：减法通过 “加减数的补码” 转化为加法，简化硬件设计。
3. **位运算驱动**：加减乘除的本质是二进制位的操作（移位、与、或、异或、相加），运算规则与无符号整数一致，仅在 “结果解释” 时按补码规则还原为有符号数。
4. **溢出风险**：加减乘运算可能导致结果超出有符号数的表示范围（如 8 位 `+127 + 1` 会溢出为 `-128`），实际开发中需通过范围判断避免。