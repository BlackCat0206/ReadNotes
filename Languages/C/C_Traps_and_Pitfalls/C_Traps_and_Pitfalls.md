# C_Traps_and_Pitfalls

***---- Li Jinsheng***

***

## 一、概述

本章为《C陷阱与缺席》读书笔记，书本章节相对较少，将本书所有笔记均记录在本章。

在阅读本书前，笔记已经读完《C Prime Plus》，故本书中一些基本概念不做记录，只记录笔者认为是重点的内容。

## 二、内容

### 2.1 词法“陷阱”

#### 2.1.1 词法中的“贪心法”

```c
a---b;	// 如何解析？

a - -- b;	// 如何解析？
```

* **贪心法**：编译器会一个字符一个字符读入，当读入的字符可能组成一个**有效的符号**时，就继续读入下一个字符，判断二者组成的**字符串**是否可能时组成**有效符号**的一部分，若是则继续读入分析。重复上述步骤，直到没有读入的字符已经没有可能组成有效字符。

根据贪心法，可以分析上述内容为：

```c
(a--) - b;

a - (--b);
```

#### 2.1.2 贪心法和递增运算符的问题

练习1-4 解析

```c
a+++++b;	// 如何解析？
```

* 递增运算符：
  * 前缀运算符：其结果是**左值**。例：`++a = 20` 合法的，等价于`a = 20`;。
  * 后缀运算符：其结果是递增前的值，该值是临时值（没有内存地址），是**右值**。
* 分析：若按照贪心法，解析的结果应该是`((a++)++) + b`但是，后缀递增的结果不是左值，故只能解析为：

```c
(a++) + (++b);
```

### 2.2 语法“陷阱”

#### 2.2.1 指针和类型转换

```c
(*(void(*)())0)();	// 解析这个语句
```

* 解析：
  * `void(*)()`是一个指向返回值类型为`void`的**函数的指针**。
  * `0`前使用`(void(*)())`是进行**类型转换**，初始化一个地址为0的函数指针。
  * 对这个函数指针解引用并调用。

#### 2.2.2 返回值为指向用户提供的函数的指针

`signal()`函数的参数有两个：一个是代表“被捕获”的整数值，一个是用户提供的处理函数的指针。其返回值为指向用户提供的函数的指针。

* 声明用户提供的函数的指针

```c
void (*sftp)(int);
```

* 声明`signal()`函数

```c
void (*signal(something))(int);
```

* 解析：
  * `something`代表`signal()`函数的参数类型。传递适当的参数给函数`signal()`
  * 对函数`signal()`的返回值（用户提供的函数的指针）解应用，并传递一个整数形参。解引用后的返回值是一个`void`类型。
  * `signal()`的返回值是指向一个返回值为`void`类型的函数的指针。
* 填充`siganl()`的参数

```c
void (*signal(int n, void (*)(int)))(int);
```

* 用`typedef`简化

```c
typedef void (*HANDLE)(int); 
HANDLE signal(int, HANDLE);
```

#### 2.2.3 `switch`语句的穿透性

```c
int switchTest(int n)
{
    switch (n)
    {
    case 1:
        printf("case 1\n");
		// 忘记编写break
    case 2:
        printf("case 2\n");
		// 忘记编写break
    case 3:
        printf("case 3\n");
        break;
    default:
        printf("default case\n");
        break;
    }

    return 0;
}

/*
Result:
Enter a positive integer: 1
case 1
case 2
case 3
Enter a positive integer: 2
case 2
case 3
*/
```

* 若对控制语句后不编写`break`，控制语句会顺序执行下去。

#### 2.2.4 函数调用

```c
void fun();

int main()
{
    fun();	// 函数调用
    
    fun;	// 函数的地址。
}
```

### 2.3 语义“陷阱”、

#### 2.3.1 指针与数组

* C语言中数组需要注意以下两点：
  * C语言中只有**一维数组**，且必须在编译期间有明确的常量表示数组的大小。可以通过将其元素设置为数组，“仿真”一个多维数组。
  * 对于数组我们所能做的事情只有：1.明确其类型和数组大小。2.获取其指向首元素的地址。任何的数组下标访问等同于指针运算。

按上述的理解，我们推断下指向二维数组的指针应该是怎样的。

```c
int *p1;
int nums1[10] = {0};
p1 = nums1;			// 指针p1指向int类型的变量。

int (*p2)[10];
int num2[10][10] = {0};
p2 = nums2;			// 指针p2指向内含10个int类型的数组。
p1 = num2[0];		// 
```

#### 2.3.2 作为函数的参数数组声明

数组被声明为函数形参，我们无法将一个数组作为参数传递，实参传递为数组名时，编译器将其认为时指向数组首元素的指针。

```c
char hello[] = "Hello World!";
pirntf("%s\n", hello);
printf("%S\n", &hello[0]);			// 等价
```

#### 2.3.3 避免“举隅法”

```c
char *p, *q;
p = "xyz";			// p是指向字符串“xyz”的首元素，不是字符串本身。"xyz"作为常量，其被视为指针。
p = q;				// p和q同时指向字符串"xyz"的首元素。
```

#### 2.3.4 空指针不是空的字符串

将整数转换为指针的结果是位置的，但`0`转换为指针，编译器保证其指针是一个**无效指针**。其也被定义为一个符号`NULL`。

```c
if ((int*)0 == p)...	// 可以
```

#### 2.3.5 求值顺序

* 分隔函数参数列表的逗号，不是逗号运算符。其求值顺序是未知的。

### 2.4 链接

《C Primer Plus》在第一章中提到：链接器的作用是将编译器转换的**目标代码**、**标准系统启动函数**、和**库代码**合并起来生成一个可执行文件。

**外部类型命名冲突检查**：链接器将外部模块视为有多个外部对象构成，即所有的**外部函数**和**外部变量**，都是一个**外部对象**。在生成可执行文件的过程中，链接器会读入每一个外部对象检查当前生成可执行文件中是否有同类命名，若有则要处理命名冲突。

**外部引用的标记**：链接器会对外部模块中所欲外部对象的引用，并标记这些外部对象不是未定义的。

### 2.5 库函数

#### 2.5.1 `getchar()`函数

`getchar()`函数的返回值是一个整数，其不是一个函数，而是一个宏（《C Primer Plus》 第8章）

#### 2.5.2 更新顺序文件

* 使用`fopen()`打开的文件句柄，使用`fread()`于`fwrite()`函数对文件进行重写，需要使用`fseek()`函数进行偏移。

```c
FILE *p
struct record rec;

while(1 == fread((char*)&rec, sizeof(rec), 1, fp))
{
    /*对rec进行操作*/
    if (/* rec必须被重写 */)
    {
        feek(fp, -(long)sizeof(record), 1);			/* fseek()函数第二个参数要求是long类型 */
        fwrite((char*)&rec, sizoef(rec), 1, fp);
        feek(fp, 0L, 1);
    }
}
```

#### 2.5.3 缓冲区于分配

标准输入和输出，部分系统有缓冲区，有的没有，可以使用`setbuf(stdout, buf)`函数设置缓冲区。直到buf缓冲区填满或调用`fflush()`更新缓冲区。

```c
/**
 * @brief 错误示例
*/
#include <stdio.h>

int main(void)
{
    char buf[1024];
    setbuf(stdout, buf);
    int c;
    
    while ((c = getchar()) != EOF)
    {
        putchar(c);
    }
}


/*
Result:
在main()函数执行结束，控制交还之前，Buf已经被清除了。
*/

```

* 经验：在调试中，遇到异常退出时，部分内容未被输出，导致开发者误判错误发生地。解决方案：设置调试时不允许有缓冲。`setbuf(stdout, NULL)`

#### 2.5.4 使用errno检测错误。

* 调用库函数时，应先判断返回的错误值，再检查errno。

```c
/* 调用库函数 */
if (/* 返回的错误值 */)
{
    /* 检查errno */
}
```

### 2.6 预处理器

#### 2.6.1 不能忽视宏中的空格

```c
#define f(x) ((x) - 1)

#define f (x) ((x) - 1)	// 被调用时会报错：x undefine，展开的内容时(x) ((x) - 1)
```

#### 2.6.2 宏不是函数

宏在使用时于函数有所相似，但实则大有不同。

```c
#define abs(x) (((x) >= 0) ? (x) : -(x))

#define max(a,b) ((a)>(b)?(a):(b))
```

* 上述定义时使用括号的作用是为了避免优先级相关的问题。
* 若使用宏定义函数，对于其中**变量和运算符最好都添加括号，规避运算优先级问题**。
* 下面我们来看看一些定义不明确的例子。

```c
#define abs(x) x>0?x:-x

abs(a-b)	// a-b>0?a-b:-a-b	这时第三个参数的结果与预期不符合
	
abs(a)+1   // a>0?a:-a+1		
```

* 即使我们对变量和对应的运算都添加了括号规避优先级问题，但还是有潜在的问题：**一个操作数被用到两次**。

```c
biggest = x[0];
i = 1;
while(i < n)
{
	biggest = max(biggest, x[i++]);		// biggest = biggest > x[i++] ? biggest : x[i++];数组`x`被访问了两次
}
```

* 
