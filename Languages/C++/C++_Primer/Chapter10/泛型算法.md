# 泛型算法

***---- Li Jinsheng***

***

## 一、概述



## 二、内容

`algorithm`头文件，`numeric`头文件中定义了一些通用算法。

### 2.1 泛型算法（*generic algorithm*）

泛型算法的核心：算法和数据类型分离！！！即算法不感知容器，只依托于迭代器进行操作。

#### 2.1.1 只读算法

* `accumulate`求和

```cpp
#include <algorithm>

/**
 * @brief 将序列的内容求和
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] args 初始值
*/
value_type accumulate(b, e, args);

// vector中int类型求和
int sum = accumulate(vec.begin(), vec.end(), 0);

// vector中string类型求和
string sumstr = accumulate(vec.begin(), vec.end(), string(""));		// 这里不能隐式转换！！！
```

* `equal`判断两个序列是否相等。**第二个序列的元素至少要与第一个序列一样多**。

```cpp
/**
 * @brief 判断两个需求是否相等
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] iterator beign2
 * @return bool true/false
*/
bool equal(b, e, b2);
```

#### 2.1.2 写容器算符

**标准库算法只进行迭代器操作，不进行容器操作，即标准库算法不会改变容器大小！！！，能否插入和删除元素，取决去迭代器本身是否具有这样的能力。**

* `fill`对容器进行元素填充

```cpp
/**
 * @brief 对容器进行元素填充
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] args 填充值
*/
未知 fill(b, e, args);

vector<int> vec = {0, 1, 2, 3, 4};
fill(vec.begin(), vec.end(), 0);
```

* `fill_n`对给定范围进行填充

```cpp
/**
 * @brief 对容器进行元素填充
 * @param [in] iterator begin
 * @param [in] unsigned int size
 * @param [in] args 填充值
*/
未知 fill_n(b, size, args);

vector<int> vec = {0, 1, 2, 3, 4};
fill_n(vec.begin(), vec.size(), 0);		
```

* ***注意：不要操作空容器！！！***
* `back_inserter`插入迭代器：对其迭代器解引用赋值，等同于执行`push_back`操作

```cpp
vector<int> vec;
auto iter = back_inserter(vec);
*iter = 42;


// 这里就可以使用fill_n
fill_n(back_inserter(vec), 10, 0);
```

* `copy`拷贝一个序列到第二个序列中

```cpp
/**
 * @brief 判断两个需求是否相等
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] iterator beign2	目标序列的起始位置
 * @return iterator 第二个序列尾元素之后的位置
*/
iterator copy(b, e, b2);

int a1[] = {0, 1, 2, 3, 4, 5};
int a2[sizeof(a1)/sizeof(int)];

auto ret = copy(begin(a1), end(a1), a2);
```

* `replace`替换序列中指定元素
* `replace_copy`将替换后的序列拷贝到第二个序列中。

```cpp
/**
 * @brief 判断两个需求是否相等
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] args 被替换值
 * @param [in] args2 替换值
 * @return iterator 第二个序列尾元素之后的位置
*/
未知 replace(b, e, args, args2);

/**
 * @brief 判断两个需求是否相等
 * @param [in] iterator begin
 * @param [in] iterator end
 * @param [in] iterator begin2
 * @param [in] args 被替换值
 * @param [in] args2 替换值
 * @return iterator 第二个序列尾元素之后的位置
*/
未知 replace(b, e, b2, args, args2);

replace(vec.begin(), vec.end(), 0, 42);
replace(vec.begin(), vec.end(), vec2.begin(), 1, 23);
```

#### 2.1.3 重排容器元素的算法

* `sort`对输入序列进行从小到大排序，依托于运算符`<`。
* `stable_sort`对相同的元素不改变其顺序

```cpp
/**
 * @brief 对输入元素进行从小到大排序
 * @param [in] iterator begin
 * @param [in] iterator end
*/
未知 sort(b, e);

vector<int> vec = {4, 3, 2, 3, 0};
sort(vec.begin(), vec.size());	
```

* `unique`删除重复元素，不改变容器大小，只是将不重复的元素放在前边，重复的元素结果是未知的。

```cpp
/**
 * @brief 判断两个需求是否相等
 * @param [in] iterator begin
 * @param [in] iterator end
 * @return iterator 返回最后一个不重复元素之后的位置
*/
iterator unique(b, e);
```

### 2.2 谓词、lambda

对于上述`sort`我们可以传递我们自己的排序规则，其有对应的重载版本，第三个参数是**谓词（*predicate*）**

#### 2.2.1 谓词（*predicate*）

谓词：其返回类型是**可作为条件判断的值**，其分为两种类型：**一元谓词和二元谓词**（表示接受几个参数）。

```cpp
bool isShorter(const string& s1, const string& s2)
{
    return s1.size() < s2.size();
}

// 
sort(word.begin(), word.end(), isShorter);
// 按长度重新排序，长度相同的单词维持字典序
stable_sort(word.begin(), word.end(), isShorter);
```

#### 2.2.2 lambda表达式

```cpp
[captuer list](parameter list) -> return type { function body };
```

* 参数列表和返回类型可省略，返回类型由编译器推断（**若函数体中出现了`return`之外的任何语句，推测都是`void`类型，建议此时指定返回类型**）。

```cpp
auto f = [] {return 42;};

cout << f() << end();		// 输出42
```

* 向`lambda`**传递参数**，将2.2中函数改写。

```cpp
stable_sort(word.begin(), word.end(), [](const string& s1, const string& s2){ return s1.size() < s2.size()} );
```

* 使用**捕获列表**，用逗号分隔名称的列表
* `find_if`第三个参数可以接受一个一元谓词。

```cpp
// 对查找字符长度大于10的元素
int sz = 10;
stable_sort(word.begin(), word.end(), [](const string& s1, const string& s2){ return s1.size() < s2.size()} );
auto wc = find_if(word.begin(), word.end(), [sz](const string& s1) { return s1.size() >= sz} );
```

* `for_each`此算法接受一个可调用对象

```cpp
// 对查找字符长度大于10的元素
int sz = 10;
stable_sort(word.begin(), word.end(), [](const string& s1, const string& s2){ return s1.size() < s2.size()} );
auto wc = find_if(word.begin(), word.end(), [sz](const string& s1) { return s1.size() >= sz} );
for_each(wc, word.end(), [](const string& s1){ cout << s1 << ""; });
```

#### 2.2.3 lambda捕获和返回

* 值捕获：被捕获的值**在创建时拷贝**，而不是在调用时：

```cpp
void fcn1()
{
    size_t v1 = 42;
    auto f = [v1] { return v1; };
    v1 = 0;
    auto j = f();		// 42;  创建时拷贝的结果是42
}
```

* 引用捕获

```cpp
void fcn2()
{
    size_t v1 = 42;
    auto f2 = [&v1] { return v1; };
    v1 = 0;
    auto j = f2();		// 0; f2保存的是v1的引用
}
```

* 隐式捕获 （必须在捕获列表中第一个）`&`告诉编译器捕获一个引用，`=`采用值捕获

```cpp
[]								空
[names]							显示捕获
[&]								隐式引用捕获
[=]								隐式值捕获
[&, identifier_list]
[=, identifier_list]
```

* 如何使用成员变量：捕获当前的类的`this`指针

```cpp
    connect(m_win1ptr, &window1::customWindow1Signal, this,
            [this](){
        m_win1ptr->hide();		// 相当于this->m_win1ptr->hide();
        m_win2ptr->show();
    });
```

示例：

```cpp
int sz = 10;
auto wc = find_if(word.begin(), word.end(), [=](const string& s1) { return s1.size() >= sz} );
```

* 可变`lambda`：**对捕获的值可进行修改，必须添加`mutable`。**引用取决于其是否被`const`修饰。

```cpp
void fcn3()
{
    size_t v1 = 42;
    auto f = [v1] mutable { return ++v1; };
    v1 = 0;
    auto j = f();		// 43;  创建时拷贝的结果是42
}

void fcn4()
{
    size_t v2 = 42;
    auto f2 = [&v1] { return ++v2; };
    v1 = 0;
    auto j = f2();		// 1; 
}
```

#### 2.2.4 参数绑定`bind()`

```cpp
#include <functional>
/**
 * @brief 函数适配器，执行会调用callable，并将arg_list传递给它
 * @param [in] callable 函数
 * @param [in] arg_list 参数列表，支持_n的名字，表示占位符，_1表示newCallable的第一个参数，_2表示为newCallable第二个参数
*/
auto newCallable = bind(callable, arg_list);
```

示例：`find_if`只能接受一个一元谓词，故在2.2.2中我们使用了`lambda`，现在用`bind()`尝试用函数替换

```cpp
bool check_size(const string& s1, size_t sz)
{
    return s1.size() >= sz;
}
// lambda
auto wc = find_if(word.begin(), word.end(), [sz](const string& s1) { return s1.size() >= sz} );
// 函数
auto wc = find_if(word.begin(), word.end(), bind(check_size, _1, sz) );
```

* `_1`源于`std::placeholders::_1` 或者直接使用`using namespace std::placeholders;`，注意：绑定的后执行顺序的固定的。

```cpp
#include <functional>
using namespace std::placeholders;

auto g = bind(f, a, b, _2, c, _1);

// 传递给g可以看错占位符
g(_1, _2);

g(X, Y);
f(a, b, Y, c, X);
```

* 绑定引用：`ref()`函数，不能直接绑定。

```cpp
for_each(vec.begin(), vec.end(), bind(print, ref(os), _1, ''));
```

### 2.3 迭代器拓展（插入、流、反向、移动）

#### 2.3.1 插入迭代器

* 支持操作

```cpp
it = t;			// 假设it绑定在容器c上，对插入迭代器而言，此赋值会分别调用push_back(), push_front()或c.insert(t, p), p为传递给inserter的位置。
*it、++it、it++
```

* `back_inserter`：创建一个使用`push_back()`的迭代器。
* `front_inserter`：创建一个使用`push_front()`的迭代器。
* `inserter`：接受第二个参数，其为给定容器的迭代器。

```cpp
vector<int> vec = {0, 1, 2};
vector<int>::iteartor it = inserter(-1, vec.begin());
*it = val;

// 等价于
it = c.insert(it, val);
it++;
```

#### 2.3.2 iostream迭代器

* `istream_iterator`

```cpp
istream_iterator<T> in(is);			// in从isc中读取数据类型为T的值
istream_iterator<T> end;			// 读取数据类型为T的值的迭代器的尾后迭代器
in1 == in2;							// 必须读取相同的类型。若都是尾后或绑定在同一个流中则相同。
in1 != in2;
*in									// 返回流中的输入
in->mem								// 解引用操作成员(*in).mem
++in、in++
```

* 示例：

```cpp
// 对输入整数进行求和。
istream_iterator<int> in(cin), eof;
cout << accumulate(in, eof, 0) << end;
```

* `ostream_iterator`

```cpp
ostream_iterator<T> out(os);			// out从os中输出数据类型为T的值
ostream_iterator<T> out(os, d);			// 对输出的T类型值后都输出一个d, 必须是C风格的字符串
out = val;								// 将val输出
*out、++out、out++					   // 
```

* 示例：

```cpp
ostream_iterator<int> out_iter(cout, " ");
for (auto e : vec)
{
    *out_iter++ = e;
}
cout << endl;
```

#### 2.3.3 reverse_iterator

* `reverse_iterator`反向迭代器，源于`rbegin()` `rend()` `crbegin()` `crend()`。
* 反向迭代器转换为普通迭代器：`base()`其结果为反向迭代器的前一个元素！！！

```cpp
#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
using namespace std;

int main() {
    vector<int> vec = {1, 2, 3, 4, 5};

    // Using reverse iterator to traverse the vector in reverse order
    cout << "Vector elements in reverse order: ";
    for (auto rit = vec.rbegin(); rit != vec.rend(); ++rit) {
        cout << *rit << " ";
    }
    cout << endl;

    auto rcomma = find(vec.rbegin(), vec.rend(), 3);

    cout << *rcomma.base() << endl;		// 4

    return 0;
}
```



