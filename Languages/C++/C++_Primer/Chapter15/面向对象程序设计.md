# 面向对象程序设计

***---- Li Jinsheng***

## 一、概述



## 二、内容

### 2.1 OOP：概述

**OOP（*object-oriented programming*）**核心思想：

* 数据抽象（封装）：将类的接口与实现分离。
* 继承：定义相似类型并对其相似关系建模。
* 动态绑定（多态）：忽略相似类的区别，用同一的方式使用它们的对象。

### 2.2 定义基类和派生类

#### 2.2.1 定义基类：

```cpp
class Base
{
public:
    Base(int i = 0) : mi_base(i) {}
    virtual ~Base() {}

    virtual void print() const;
protected:
    int getBase() const { return mi_base; }

private:
    int mi_base;
};


void Base::print() const
{
    cout << "Base: " << mi_base << endl;
}
```

* `virtual`修饰的为虚函数，可以定义自己的版本，同时允许其派生类覆盖（`override`）。若派生类不覆盖，在动态绑定时使用基类自己的定义。
* **虚析构**：**保证动态绑定时内存的释放**。即，当基类指针或引用绑定派生类对象时，对其的释放不能按照基类的方式进行，而是先释放派生类资源，后释放基类资源。**其会阻止合成移动操作**。且不必遵守由析构，就有拷贝构造函数和拷贝赋值运算符函数的规则。
* `protected`：派生类的成员或友元有权限访问的成员（**通过派生类的对象进行访问！！！**），禁止其他用户（基类和派生类的对象）访问。

```cpp
class Base
{
public:
    Base(int i = 0) : mi_base(i) {}
    virtual ~Base() {}

    virtual void print() const;
protected:
    int getBase() const { return mi_base; }
private:
    int mi_base;
};


class Derived; // Forward declaration
void getBaseTest(const Derived& d); // Function prototype
void getBaseTest2(const Base& b); // Function prototype

class Derived : public Base
{
    friend void getBaseTest(const Derived& d); // Friend function declaration
    friend void getBaseTest2(const Base& b); // Friend function declaration
public:
    Derived(int i = 0, int j = 0) : Base(i), mi_derived(j) {}
    void print() const override;

private:
    int mi_derived;
};


void getBaseTest(const Derived& d)
{
    cout << "Derived getBaseTest: " << d.getBase() << endl; // Accessing protected member function
}

// 基类对象是没有权限访问受保护的成员的！！！
void getBaseTest2(const Base& b)
{
    cout << "Base getBaseTest2: " << b.getBase() << endl; // Accessing protected member function is NOT allowed
}
```

#### 2.2.2 定义派生类

```cpp
class Derived : public Base		// 派生列表:
{
public:
    Derived(int i = 0, int j = 0) : Base(i), mi_derived(j) {}	// 每个类控制自己的成员初始化过程
    void print() const override;								// 虚函数覆盖

private:
    int mi_derived;
};

void Derived::print() const
{
    Base::print();												// 访问基类的`public`成员函数	
    cout << "Derived: " << mi_derived << endl;
}
```

* 派生类中含有基类的组成部分，故需要在派生类构造函数中使用基类的构造函数初始化基类的成员变量。
* 类派生列表（*class derivation list*）：由**继承权限符**和类名组成。有关继承权限符号作用如下：
  * `public`：
    * **用户代码**可以实现派生类向基类的转换。（转换过程中只是将派生类中基类的内容拷贝，其余部分被切除）。其余权限不可。
    * 派生类的友元或成员可以实现派生类向基类的转换。
  * `protected`：
    * 派生类的友元或成员可以实现派生类向基类的转换。
  * `private`：
    * **派生类的成员函数或友元不能实现派生类向基类的转换**。
* `override`：
  * 位置：参数列表后`const`、引用限定符（`&`）和尾置类型之后，表示覆盖基类的虚函数。
* 派生类可以访问基类的`public`和`protected`成员

#### 2.2.3 动态绑定与示例

* **当基类的指针和引用绑定子类的对象才能触发！！！**

```cpp
#include <iostream>

using namespace std;

class Base
{
public:
    Base(int i = 0) : mi_base(i) {}
    virtual ~Base() {}

    virtual void print() const;		// 基类的虚函数
protected:
    int getBase() const { return mi_base; }
private:
    int mi_base;
};

class Derived : public Base
{
public:
    Derived(int i = 0, int j = 0) : Base(i), mi_derived(j) {}
    void print() const override;		// 派生类覆盖的虚函数函数

private:
    int mi_derived;
};


void Base::print() const
{
    cout << "Base: " << mi_base << endl;
}

void Derived::print() const
{
    int baseNum = Base::getBase();    // Accessing protected member function
    cout << "Base: " << baseNum << " Derived: " << mi_derived << endl;
}

int main()
{
    Base b(1);
    Derived d(2, 3);

    Base* pb = &b;						
    Base* pd = &d;						// 基类指针指向派生类对象

    pb->print(b);
    pd->print(d);						// 调用是派生类覆盖的函数
    // pd->getBase(); // Accessing protected member function - Not allowed


    return 0;
}
```

#### 2.2.4 继承与静态成员

* 如果基类中定义一个静态成员，对于其所有的派生类，该成员都是唯一的！！！

#### 2.2.5 派生类的声明

* 与其他类相同，`class`与类名，不需要类继承列表。

```cpp
class Derived;					// 正确!
class Derived : public Base;	// 错误！
```

#### 2.2.6 被用作基类的类必须完成定义

```cpp
class Base;						// 声明但未定义
class Derived : public Base		// 错误！
{
  ... ...  
};
```

#### 2.2.7 防止继承发生`final`（C++11）

防止类被继承：C++11提供了关键字`final`用户阻止被修饰的类被继承，在**类名后**加关键字。

```cpp
class Base
{
    ... ...
};

class NoDerived final : public Base
{
  	... ...  
};

class Bad : public Noderived	// 错误！！！
{
    ... ...
};
```

#### 2.2.8 静态类型和动态类型

* 静态类型：表达式的类型在编译时就可以确认，它是变量声明时的类型或表达式自己生成的。

* 动态类型：在运行时才能确认，它是变量或者表达式表示内存中对象的类型。（动态绑定）

#### 2.2.9 类型转换与继承

* 动态绑定：**不会改变变量的静态类型**，即基类指针或引用绑定派生类对象，其还是只能访问基类中声明的。
* 不存在基类向派生类的隐式转换！！！

```cpp
class Base
{};
class Derived : public Base		
{};

Base b1;
Derived d1 = b1;		// 错误的！

Base* pb = &d1;		// 正确，动态绑定
Derived* pd = pb	// 错误，不能将基类对象转换未派生类。
```

* 派生类可以构造和拷贝赋值给基类，但只会拷贝基类中的成员。

```cpp
class Base
{};
class Derived : public Base		
{};

Derived d1;
Base b1 = d1;		// 调用，Base& operator=(const Base& base);
Base b2(d1);		// 调用 Base(const Base&)
```

* 根据上述示例：**派生类向基类转换调用的是基类的拷贝构造函数和拷贝赋值运算符，使用基类引用绑定派生类对象，拷贝内容是基类中的内容，派生类中独有的内容被切除了。**
* 派生类转换基类可以实现；基类转换派生类，不行！！！

### 2.3 虚函数

#### 2.3.1 虚函数的调用只有在运行时才能确认

* 当派生类向基类拷贝，不会改变基类的成员函数

```cpp
class Base
{
public:
    virtual void print() const;
};

void Base::print() const
{
    cout << "Base" << end1;
}

class Derived : public Base		
{
    virtual void print() const overried;
};

void Derived::print() const
{
  	cout << "Derived" << endl;
};

Derived d1;
Base b1 = d1;		// 调用，Base& operator=(const Base& base);
Base b2(d1);		// 调用 Base(const Base&)

b1.print();			// Base
```

#### 2.3.2 派生类中的虚函数覆盖（例外）

* 派生类覆盖的虚函数的函数名，返回值类型和参数列表必须要和基类中虚函数一致。例外：基类的返回值类型是类本身的引用和指针，且可以完成转换。派生类中虚函数的返回值类型可以是其本身，

#### 2.3.3`final`和`override`说明符

* 派生类在函数声明时使用`voerride`表示对基类虚函数的覆盖，可以方便编译器检查参数类别，函数名和返回值类型是否相同。
* 使用`final`表示之后覆盖是不允许的

```cpp
class Base
{
public:
    virtual void print() const;
};

void Base::print() const
{
    cout << "Base" << end1;
}

class Derived : public Base		
{
public:
	virtual void print() const final;	// 不允许后续覆盖
};

void Derived::print() const
{
  	cout << "Derived" << endl;
};

class Derived2 : public Derived
{
public:
    void print() const;		// 错误！不允许的
};
```

#### 2.3.4 虚函数和默认实参

* 虚函数的默认实参由其动态类型决定，最好基类的派生类的默认实参一样。

#### 2.3.5 回避虚函数

```cpp
Derived d1;
Base* pd = &d1;
pd->Base::print(b); // Calling Base class print metho
```

### 2.4 抽象基类

#### 2.4.1 纯虚函数

类内部虚函数声明时，参数列表后添加`=0`表示是此虚函数是纯虚函数。可以在类外定义，通过上述的规避虚函数调用。

```cpp
class Base2
{
public:
    Base2(int i = 0) : mi_base(i) {}
    virtual ~Base2() {}

    virtual void print()const=0;

private:
    int mi_base;
};

void Base2::print() const
{
    cout << "Base2: " << mi_base << endl;
}


class Derived2 : public Base2
{
public:
    Derived2(int i = 0, int x) : Base2(i), mi_derived(x) {}
    void print() const override
    {
        Base2::print();
    }
private:
    int mi_derived;
};

int main()
{
    // Base2 b2; // This line will cause a compilation error because Base2 is abstract
    Derived2 d23(6, 7);
    d23.Base2::print();

    return 0;
}
```

#### 2.4.2 含有纯虚函数的类是抽象基本类，其不能创建一个抽象基类的对象

### 2.5 访问控制与继承

#### 2.5.1 受保护的成员

* 和`private`类型，其不能被类对象访问。
* 和`public`类型、可以被派生类的成员和友元访问。
* 派生类的成员函数或友元访问时要通过派生类的对象访问，基类的对象时没有权限访问的。

#### 2.5.2 公有、私有和受保护继承

* 不影响派生类的访问：`public`、`protected`和`private`权限继承，不影响类成员和友元的正常访问。

```cpp
class Base
{
public:
    int m_pbbase;
protected:
    int m_prtbase;
};

class Pub_Derived : public Base
{
public:
    void print(){ cout << m_pbbase << m_prtbase; }
};

class Pri_Derived2 : private Base		// 私有继承
{
    void print2(){cout << m_pbbase << m_prtbase; }		// 不影响正常访问！
};
```

* **派生访问符控制继承派生类的新类的访问权限**：

```cpp
class Base
{
public:
    int m_pbbase;
protected:
    int m_prtbase;
};

class Pub_Derived : public Base
{
public:
    void print(){ cout << m_pbbase << m_prtbase; }
};

class Pri_Derived2 : private Base		// 私有继承
{
    void print2(){cout << m_pbbase << m_prtbase; }		// 不影响正常访问！
};

class Derived_from_Public : public Pub_Derived
{
  	  void print() {cout << m_prtbase }		// Base::m_prtbase 在Pub_Derived还是protected
};

class Derived_from_Pri : public Pri_Derived2
{
      void print() {cout << m_prtbase }		// 错误！Base::m_prtbase 在Pub_Derived还是private!
}
```

* 影响派生类向基类转换：
  * 用户代码派生类向基类转换：只有`public`继承可以，其余均不行。
  * 对成员函数和友元访问：继承权限不影响其访问，对于`protected`需要通过派生类的对象。
  * 对成员函数和友元转换：只有`public`和`protected`权限在友元和成员函数中才可以实现派生类向基类的转换。`private`不行。

#### 2.5.3 友元和继承

* 友元不能继承：但友元可以访问派生类中内嵌的基类部分。
* 访问权限：**对基类的访问权限由基类控制**，即使是派生类中的内嵌基类。

```cpp
class Pal;
class Base
{
    friend class Pal;
public:
    int m_base;
};

class Derived : public Base;
{
    ...
protected:
    int m_prodata;
}

class Pal
{
public:
    int f(Base b) { return b.m_base; }			// 正确
    int f1(Derived d) {return d.m_base;}		// 正确
    int f2(Derived d) {return d.m_prodata;}		// 错误，Pal不是Derived的友元！！！
};
```

#### 2.5.4 改变个别成员的访问权限

* 可以使用`using baseName::memberName`改变派生类对于基类的**继承权限**。

```cpp
class Base
{
public:
    int m_pbbase;
protected:
    int m_prtbase;
};

class Pri_Derived2 : private Base		// 私有继承
{
 public:
  	using Base::m_pbbase;								// 改变基类中成员m_pbbase的访问权限为public
    void print2(){cout << m_pbbase << m_prtbase; }		
};
```

### 2.6 继承中类的作用域



### 2.7 构造函数与拷贝控制



## 三、小结