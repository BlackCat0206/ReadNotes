# 表达式

***---- Li Jinsheng***

***

## 一、概述

本篇为《C++ Primer》（第5版）第4章读书笔记，主要内容为各类运算符与类型转换。整体内容与《C++ Primer Plus》（第6版）**第5章**与**第15章**类型。本篇重点在于`C++`中一些特性。

## 二、内容

### 2.1 左值和右值

《C Prime Plus》（第6版）第5章读书笔记：**2.2.1.1 左值、右值、数据对象和运算符**。

* `C`中：

  * 左值：可以出现在赋值运算符左边，可以访问其内存地址。它可以标识一个特定数据存储的位置。
  * 右值：可以给可修改左值赋值。一般是常量、基本类型的算数表达式。

* `C++`中：引入了**右值引用（*rvalue reference*）**和**语义移动（*move semantics*）**。

  * 左值：与`C`相同，其是一个对象或者函数。
  * 右值：
    * 纯右值（*prvalue*）：字面量、表达式。
    * 将亡值（xvalue）：即将被销毁的对象。（返回右值引用的表达式）
  * 可以通过`&&`绑定右值，实现资源高效转移（避免复制）

  ```cpp
  int x = 10;				// x是左值、10是纯右值
  int&& rref = x + 5;		// rref是右值引用，x+5是右值
  ```

* `decltype`**中若表达式的结果是左值，其返回的是引用**。

```cpp
int *p;

decltype(*p)		// *p的结果是左值，int&		
decltype(&p)		// &p的结果是右值，int**
```

### 2.2 求值顺序（不要自作聪明）

`C/C++`中有固定求值顺序的运算符是：`&&`、`||`、`?:`、`,`，其余运算符的对对象的求值顺序是不固定的，故不要**在一个语句中对于同一个变量进行多次改变。**

《C Primer Plus》（第6版）第5章读书笔记：**2.3.6 不要自作聪明**

```cpp
int i = 0;
cout << i << " " << i++ << endl;		// 结果是未定义的。
```

### 2.3 整数除法取整（C++11）

* C++11规定整数除法结果向0取整（丢弃小数位）。

### 2.4 递增运算符（前缀、后缀和解引用的优先级）

* 前缀：运算对象是左值，其结果是左值。
* 后缀：运算对象是左值，其结果是右值（递增前的副本）。

* 前缀、后缀和解引用的优先级。**后缀高于解引用、前缀和解引用相同**。

```c
int *p;
*p++;		// 
++*p;		//
```

### 2.5 条件运算符

```c
condition ? expr1 : expr2;
```

* condition为`true`：计算`expr1`，若为`false`计算`expr2`。

### 2.6 `sizeof`运算符（指针、数组和引用）

* 返回类型：`size_t`，打印是转换说明使用`%zd`或`%zu`。
* 结合律从右向左。
* 列举一些典型的计算：
  * 引用：绑定对象的大小。
  * 指针：指针的大小。
  * 解引用指针：指针所指**元素**的大小。
  * 数组名：整个数组的大小。
  * 解引用数组名：首个元素的大小。

### 2.7 逗号运算符（特殊示例）

* 计算顺序：先计算左侧，后计算右侧。
* 结果：右侧结果，若右侧是左值，其结果是左值；若右侧对象是右值，则结果是右值。

**特殊示例**：（练习4.33）

```c
someValue ? ++x, ++y : --x, --y;
// 等价于
(someValue ? ++x, ++y : --x), --y;			// 逗号运算符

/*
someValue == true， 执行++x、++y、--y
someValue == false, 执行--x,--y
*/
```

### 2.8 类型转换

《C Prime Plus》（第6版）读书笔记：**2.5 类型转换**

### 2.9 显示类型转换

命名的强制类型转换格式：

```cpp
cast-name<type>(expreesion);
```

`cast-name`分别有：`static_cast`、`dynamic_cast`、`const_cast`和`reinterpret_cast`

#### 2.9.1 `static_cast`

在**编译时**完成类型转换，主要用于 “相关类型” 之间的转换，**不进行运行时类型检查**。

* 使用条件：作用于**非底层`const`类型**
* 使用场景：
  * **基本数据类型之间的转换**：如 `int` ↔ `double`、`char` ↔ `int` 等（C 风格转换的安全替代）。
  * **void 指针与其他类型指针的转换**：如 `void*` 转 `int*`（需确保指针指向的类型匹配）。
  * **类层次结构中 “上行转换”**：派生类指针 / 引用转换为基类指针 / 引用（安全，编译器可验证）。

示例：

```cpp
// 大算数类型转换为较小的算数类型
int i = 10;
double d = static_cast<double>(i);

// void* 指针转换为
void* p = &d;							// void*接受任何指向任何类型。
double* dp = static_cast<double*>(p);	// 

// 派生类指针指向基类
Derived* d = new Derived(); 
Base* b = static_cast<Base*>(d);
```

* 风险：
  * 不会进行运行时类型检查；
  * **不能转换不相关的类型**：如 `int*` 不能直接转为 `double*`（需用 `reinterpret_cast`）。
  * 不能去除`const`/`volatile`限定符。

#### 2.9.2 `const_cast`

作用于底层`const`/`volatile`对象，用于**去除或添加**`const`/`volatile`限定符，不改变类型本身，只改变其“**常量性**”。

```cpp
// 去除const
const int x = 10;
int *px = const_cast<int*>(&x);

// 添加const
int y = 5;
const int* py = const_cast<const int*>(&y);
```

* 风险与限制

  - **仅能修改 cv 限定符**：不能用于类型转换（如 `int` 不能转为 `double`）。

  - **修改 “本质 const” 变量的风险**：若原变量是用 `const` 定义的（本质 const），通过 `const_cast` 去除 `const` 后修改，会导致未定义行为（可能崩溃或结果异常）。

  - **不能转换类型**：如 `const int*` 不能直接转为 `int`（需先解引用）。

#### 2.9.3 `reinterpret_cast`

最**底层的转换**，直接将一种类型的二进制表示 “重新解释” 为另一种类型，几乎**不进行类型检查**，完全依赖程序员保证正确性。

* 应用场景

  - **不相关类型的指针 / 引用转换**：如 `int*` 转 `double*`、`void (*)()`（函数指针）转 `int*` 等。例：

    ```cpp
    int* p = reinterpret_cast<int*>(0x123456);
    ```

    （将整数视为指针地址）

  - **指针与整数之间的转换**：如将指针转为 `uintptr_t`（用于地址存储或调试）。

  - **跨类型的位模式复用**：如将 `float` 的二进制位按 `int` 解析（需注意大小端问题）。

* 风险：
  * **几乎无类型安全保证**：转换结果完全依赖平台和编译器实现（如指针大小、对齐方式），可移植性极差。
  * **易导致未定义行为**：若转换后的类型与实际内存布局不匹配（如 `int*` 转 `double*` 后解引用），会导致内存访问错误。
  * **不能用于类层次结构转换**：如需安全的上下行转换，应使用 `static_cast` 或 `dynamic_cast`。

#### 2.9.4 类型转换小结

| 转换方式           | 核心用途                         | 检查时机 | 主要限制                                | 风险级别       |
| ------------------ | -------------------------------- | -------- | --------------------------------------- | -------------- |
| `static_cast`      | 相关类型转换（基本类型、类层次） | 编译时   | 不能去除 const，下行转换无安全检查      | 中             |
| `dynamic_cast`     | 多态类的下行 / 交叉转换          | 运行时   | 仅用于多态类型（含虚函数）的指针 / 引用 | 低（安全）     |
| `const_cast`       | 修改 `const`/`volatile` 限定符   | 编译时   | 仅能修改 cv 属性，不能转换类型          | 高（误用风险） |
| `reinterpret_cast` | 底层二进制重解释                 | 无检查   | 依赖平台，几乎无类型安全                | 极高           |

## 三、C和C++相关内容

整体内容与《C++ Primer Plus》（第6版）**第5章**与**第15章**类似。

## 四、小结

本章主要内容为：

左值和右值的区别：C++11中引入的纯右值、右值引用、将亡值。

在语句中进行算数运算时，不要自作聪明，在一条语句中对同一个变量多次修改，因对运算符的求值顺序的不固定的，故上述操作很多结果是未知的。

类型转换：

* `static_cast`：相关类型转换、`void*`指针的类型转换。风险：不会进行运行时类型检查，不会转换不相关类型（`reinterpret_cast`）。
* `const_cat`：唯一可以添加和去除`const`和`volatile`限定符，不修改对象本身。风险：去除`const`限定后，对对象进行修改其结果未定义，不能进行类型转换。
* `reinterpret_cast`：底层转换，将一种二进制解释未另一种。不相关指针的转换、指针和整数的转换、跨类型的转换。风险：没有安全保证，不能用于类层次的转换。