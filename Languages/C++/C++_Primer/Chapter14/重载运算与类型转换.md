# 重载运算与类型转换

***---- Li Jinsheng***

## 一、概述

C++ 中的重载运算与类型转换是面向对象编程中增强类功能、提升代码可读性和灵活性的重要机制。通过重载运算符，我们可以为自定义类定义与内置类型相似的运算行为，使得类的使用更加直观自然，就像使用基本数据类型一样。而类型转换运算符则允许在自定义类与其他类型之间进行合理的转换，方便不同类型数据之间的交互。

重载运算符并非可以随意进行，存在诸多规则限制，例如某些运算符必须作为成员函数重载，某些则更适合作为非成员函数；同时，还需注意避免因重载不当导致的二义性问题。类型转换同样需要谨慎设计，防止隐式转换带来的意外行为，必要时可使用`explicit`关键字加以限制。本章围绕这些核心内容，详细阐述了各类运算符的重载方法、类型转换的实现以及相关的注意事项，旨在帮助开发者正确、高效地运用这些特性。

## 二、内容

### 2.1 基本概念

* 参数类型：至少有一个类类型参与计算。

* 参数个数：重载和函数运算符的参数应该和运算符相同。
* 成员函数：其左侧会绑定到`*this`指针，参数与普通的运算符少一个。
* 计算顺序：很多普通对象的求值顺序无法应用到重载运算符中。
* 无法重载的运算符：
  * `::`
  * `.*`**指向成员的指针运算符（pointer-to-member operator）**
  * `.`
  * `: ?`
* 不建议重载的运算符：
  * `&&`：逻辑与
  * `||`：逻辑或
  * `,`：逗号
  * `&`：取地址
* 必须是成员函数：
  * 下标访问：`[]`
  * 函数调用：`()`
  * 赋值运算符：`=`
  * 成员访问箭头：`->`
  * 递增/递减：`++/--`
* 非成员函数：
  * 算数
  * 逻辑
  * 关系
  * 位运算
  * 与`iostream`相关的输入输出重载

### 2.2 输入和输出运算符

* 是否是成员函数：与`<iostream>`相关的输入输出重载是**非成员函数**。

```cpp
Class data;
data << cout;		// 如果operator<<是Class成员函数
```

#### 2.2.1 重载输出运算符`<<`

* 格式：

```cpp
ostream& operator<<(ostream &os, const Class& item)
{
    os << item.mem << " ";
    return os;
}
```

* 注意：不要在输出重载运算符中打印换行。

#### 2.2.2 重载输入运算符`>>`

* 格式：

```cpp
istream& operator>>(istream& is, Class &item)
{
    int x;
    is >> x;
    // 注意输入重载要考虑输入失败的情况。
    if (is)
    {
	    item.mem = x;    
    }
    else
    {
        item.mem = 0;
    }
    return is;
}
```

### 2.3 算数和关系运算符（非成员函数）

* 非成员函数，允许左右参数进行类型转换，形参是常量引用。返回局部变量的副本。

#### 2.3.1 相等运算符

```cpp
bool operator==(const Class& lhs, const Class& rhs)
{
    return lhs.item == rhs.item;
}
```

* 相等运算符与不等运算符最好伴生声明与定义的！！！

#### 2.3.2 关系运算符

很多算法依赖于`<`运算符。

### 2.4 赋值运算符（成员函数）

* 普通赋值

```cpp
// 拷贝赋值运算符
Class& operator=(const Class& item)
{
    
    return *this;
}

// 移动赋值运算符
Class& operator=(Class&& item) noexcept
{
    // 注意将item置为可析构状态
    
    return *this;
}

// 初始化参数列表
Class& operator=(initializer_list<T>())
{
    return *this;
}

void swap(Class& lhs, Class& rhs)
{

}

Class& operator=(Class rhs)

```

* 复合赋值运算符法

```cpp
Class& operator+=(const Class& item)
{
    return *this;
}
```

### 2.5 下标运算符(成员函数)

* 格式两个版本，一个返回普通引用，一个返回常量引用（常量成员函数）

```cpp
#include <iostream>
#include <string>

using namespace std;

class Base
{
public:
    Base(int data, string str = "") : m_baseData(data), m_baseStr(new string(str)) {}
    ~Base() { delete m_baseStr; }


    // 下标运算符重载
    char& operator[](size_t index)
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

    const char& operator[](size_t index) const
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

private:
    int m_baseData;
    string* m_baseStr;
};

int main(void)
{
    Base b(10, "hello");

    // 通过下标运算符访问字符串中的字符
    cout << b[0] << endl; // 访问第一个字符

    return 0;
}
```

### 2.6 递增和递减运算符（成员函数）

* 格式：

```cpp
#include <iostream>
#include <string>

using namespace std;


class Base;
// 重载输出运算符
ostream& operator<< (ostream& os, const Base& b);

class Base
{

    friend ostream& operator<< (ostream& os, const Base& b);
public:
    Base(int data, string str = "") : m_baseData(data), m_baseStr(new string(str)) {}
    ~Base() { delete m_baseStr; }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

    const char& operator[](size_t index) const
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

    // 递增运算符重载
    Base& operator++() // 前置递增
    {
        ++m_baseData;
        return *this;
    }

    Base operator++(int) // 后置递增
    {
        Base temp = *this;
        ++m_baseData;
        return temp;
    }

    // 递减运算符重载
    Base& operator--() // 前置递减
    {
        --m_baseData;
        return *this;
    }

    Base operator--(int) // 后置递减
    {
        Base temp = *this;
        --m_baseData;
        return temp;
    }


private:
    int m_baseData;
    string* m_baseStr;
};

int main(void)
{
    Base b(10, "hello");

    // 通过下标运算符访问字符串中的字符
    cout << b[0] << endl; // 访问第一个字符

    // 通过递增运算符修改数据成员
    Base b1 = ++b; // 前置递增
    cout << b1 << endl;
    Base b2 = b++; // 后置递增
    cout << b2 << endl;

    
    return 0;
}
```

* 前置于后置的区别:
  * 返回值类型：前置（类类型的引用）、后置（类的源值）。
  * 参数：前置（空），后置（int类型，占位但不使用，用来实现重载）。

### 2.7 成员访问运算符

#### 2.7.1 重载解引用运算符

* 格式：返回所指对象的引用

```cpp
Mem& operator*() const
{
    if (nullptr != m_memPtr)
    {
    	return (*m_memPtr);
    }
}
```

#### 2.7.2 重载成员访问箭头运算符

* 格式：返回所指对象的指针

```cpp
Mem* operator->() const
{
    return &(this->operator*());
}
```

#### 2.7.3 示例：

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <functional>

using namespace std;

class Base;
ostream& operator<< (ostream& os, const Base& b);

class Base
{
    friend ostream& operator<< (ostream& os, const Base& b);
public:
    Base(int data, string str = "") : m_baseData(data), m_baseStr(new string(str)) {}
    ~Base() { delete m_baseStr; }

    Base(const Base& other) : m_baseData(other.m_baseData), m_baseStr(new string(*(other.m_baseStr))) {}
    Base& operator=(const Base& other)
    {
        if (this != &other)
        {
            m_baseData = other.m_baseData;
            m_baseStr = new string(*(other.m_baseStr));
        }
        return *this;
    }

    // 下标运算符重载
    char& operator[](size_t index)
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

    const char& operator[](size_t index) const
    {
        if (index >= m_baseStr->size())
        {
            throw out_of_range("Index out of range");
        }
        return (*m_baseStr)[index];
    }

    // 递增运算符重载
    Base& operator++() // 前置递增
    {
        ++m_baseData;
        return *this;
    }

    Base operator++(int) // 后置递增
    {
        Base temp = *this;
        ++m_baseData;
        return temp;
    }

    // 递减运算符重载
    Base& operator--() // 前置递减
    {
        --m_baseData;
        return *this;
    }

    Base operator--(int) // 后置递减
    {
        Base temp = *this;
        --m_baseData;
        return temp;
    }

    // 简单成员函数
    int getData() const { return m_baseData; }
    string getStr() const { return *m_baseStr; }
    void setData(int data) { m_baseData = data; }
    void setStr(const string& str) { *m_baseStr = str; }
private:
    int m_baseData;
    string* m_baseStr;
};

ostream& operator<< (ostream& os, const Base& b)
{
    os << "Base(data: " << b.m_baseData << ", str: " << *b.m_baseStr << ")";
    return os;
}

// 
class BasePtr
{
public:
    BasePtr(Base* base) : m_basePtr(base) {}
    ~BasePtr() {}

    bool check() const
    {
        if (!m_basePtr)
        {
            throw runtime_error("Unbound BasePtr");
        }
        return true;
    }

    // 重载解引用运算符
    Base& operator*() const
    {
        if (check())
        {
            return *m_basePtr;
        }
        throw runtime_error("Unbound BasePtr");
    }

    // 重载成员访问运算符
    Base* operator->() const
    {
        return &this->operator*();
    }

private:
    unique_ptr<Base>  m_basePtr;
};

int main(void)
{
    Base b(10, "hello");

    // 通过下标运算符访问字符串中的字符
    cout << b[0] << endl; // 访问第一个字符

    // 通过递增运算符修改数据成员
    Base b1 = ++b; // 前置递增
    cout << b1 << endl;
    Base b2 = b++; // 后置递增
    cout << b2 << endl;

    // 解引用和成员访问运算符
    BasePtr bp(new Base(20, "world"));
    cout << (*bp).getData() << endl; // 使用解引用运算符
    cout << bp->getStr() << endl; // 使用成员访问运算符

    return 0;
}
```

### 2.8 函数调用运算符（成员函数）

* 将类的对象称作函数对象，因为调用这种对象向调用函数一样。
* `lambda`也是函数对象（*第10章：2.2.2 lambda表达式*）。未命名类的未命名对象。
* 对象的捕获：通过类的成员变量实现于`lambda`相同的数据捕获。

#### 2.8.1 调用运算符重载示例：

```cpp
#include <iostream>
#include <string>
#include <memory>
#include <functional>
#include <algorithm>
#include <vector>

using namespace std;

class BaseFunc
{
public:
    BaseFunc(int data) : m_baseData(data) {}
    ~BaseFunc() {}

    // 函数调用运算符重载
    void operator()(int& value) const
    {
        value += m_baseData;
        return;
    }
private:
    int m_baseData;
};

int main(void)
{
    // 函数调用运算符
    vector<int> vewtor = {1, 2, 3, 4, 5};
    for_each(vewtor.begin(), vewtor.end(), BaseFunc(5)); // 使用函数调用运算符   为每个元素加5
    for (const auto& val : vewtor)
    {
        cout << val << " "; // 输出修改后的元素
    }
    cout << endl;
	
    // 使用lambda表达式 
    for_each(vewtor.begin(), vewtor.end(), [](int& value) { value += 10; }); // 使用lambda表达式   为每个元素加10
    for (const auto& val : vewtor)
    {
        cout << val << " "; // 输出修改后的元素
    }
    cout << endl;
    return 0;
}
```

#### 2.8.2 标准库中定义的函数对象

* 头文件：`<functional>`
* 算数运算：

```cpp
plus<T>
miuns<T>
multiplies<T>
divides<T>
modules<T>
negate<T>
```

* 关系运算

```cpp
equal_to<T>
not_equal_to<T>
greater<T>
greater_equal<T>
less<T>
less_equal<T>
```

* 逻辑

```cpp
logical_and<T>
logical_or<T>
logical_not<T>
```

* 示例：

```cpp
#include <iostream>
#include <memory>
#include <functional>
#include <algorithm>
#include <vector>

void standardAlgorithmFunc(void)
{
    // 使用标准库中的函数对象
    
    // 算数
    plus<int> intAdd; // 使用标准库中的函数对象
    cout << intAdd(3, 4) << endl; // 输出7

    // 关系
    vector<int> vec = {1, 2, 3, 4, 5};
    int count = count_if(vec.begin(), vec.end(), bind2nd(less<int>(), 3)); // 统计小于3的元素个数
    cout << count << endl; // 输出2

    // 逻辑
    vector<bool> boolVec = {true, false, true, true, false};
    int trueCount = count_if(boolVec.begin(), boolVec.end(), logical_not<bool>()); // 统计false的个数
    cout << trueCount << endl; // 输出2

    // 位
    int a = 5; // 0101
    int b = 3; // 0011
    bit_and<int> bitAnd; // 使用标准库中的位运算函数对象
    cout << bitAnd(a, b) << endl; // 输出1 (0001)

    // 其他
    negate<int> intNegate; // 使用标准库中的取反函数对象
    cout << intNegate(a) << endl; // 输出-5

    // 适配器
    vector<int> vec2 = {1, 2, 3, 4, 5};
    transform(vec2.begin(), vec2.end(), vec2.begin(), bind1st(multiplies<int>(), 2)); // 每个元素乘以2
    for (const auto& val : vec2)
    {
        cout << val << " "; // 输出2 4 6 8 10
    }
    cout << endl;

    return;
}
```

#### 2.8.3 可调用对象

* C++中可调用对象：
  * 函数、
  * 函数指针、
  * `lambda`、
  * `bind`创建的对象、
  * 重载函数调用运算符的类。
* 调用：**`lambda`是未命名类的未命名对象，不是函数指针！！！**

```cpp
[](int& x1, int&x2)->int {return x1 + x2};
vector<int (*)(int&, int)> = { [](int& x1, int&x2)->int {return x1 + x2} }; // 是错误的！！！
```

#### 2.8.4 标准库`function`类型

* 头文件：`<functional>`
* 作用：**存储可调用对象！！！**
* 操作

```cpp
function<T> f;				// f是来存储可调用对象的空function，T是函数的类型
function<T> f(nullptr);		// 显示构造一个空的function
function<T> f(obj);			// f中存储可调用对象obj对象
f							// 在条件语句中若f不为空返回true,否则返回false。
f(args)						// 调用f中对象，参数args

定义为function<T>的成员的类型
result_type
argument_type
first_argument_type
second_argument_tyep
```

* 函数重载如何区分？：`function`无法区分，建议用函数指针进行填充即可区分。

* 示例：

```cpp
#include <iostream>
#include <functional>
#include <vector>

void standardFunctionTest(void)
{
    // 普通函数
    function<int(int, int)> func = customAdd; // 使用标准库中的function封装函数指针
    cout << func(3, 4) << endl; // 输出7

    // lambda表达式
    function<int(int, int)> lambdaFunc = [](int a, int b) { return a + b; }; // 使用lambda表达式
    cout << lambdaFunc(5, 6) << endl; // 输出11

    // 成员函数
    Base b(10, "hello");
    function<int(const Base&)> memFunc = &Base::getData; // 使用成员函数指针
    cout << memFunc(b) << endl; // 输出10

    return;
}

int main(void)
{
    standardFunctionTest();

    return 0;
}
```

### 2.9 重载、类中换行与运算符

#### 2.9.1 类型转换运算符(成员函数)

* 格式：`operator type () const;`

* 作用：将类类型的值转换为其他类型。
* 限制：
  * 不允许转换为数组或函数类型
  * 可以转换为数组指针已经函数指针
* 示例：（隐式转换）

```cpp
class SmallInt
{
public:
    SmallInt(int value) : m_value(value) 
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
    }

    SmallInt& operator=(int value)
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
        m_value = value;
        return *this;
    }

    operator int() const
    {
        return m_value;
    }

private:
    int m_value;
};


void smallIntTest(void)
{
    SmallInt si(100);
    int value = si; // 隐式转换为int
    cout << value << endl; // 输出100

    si = 200; // 使用赋值运算符
    cout << static_cast<int>(si) << endl; // 输出200

    try
    {
        si = 300; // 超出范围，抛出异常
    }
    catch (const out_of_range& e)
    {
        cout << e.what() << endl; // 输出异常信息
    }

    return;
}
```

#### 2.9.2 `istream`含有`bool`的类型转换

```cpp
#include <iostream>

int x = 42;
cin << 42;			// bool值被左移42位
```

#### 2.9.3 `explicit`显示的类中转换运算符

* 特殊语句：判断（`if`）、循环（`for`、`while`、`do`）、逻辑（`!`、`||`、`&&`）和条件语句（`:?`）显示的类型转换还是会被隐式地执行。
* 特殊示例：

```cpp
while(std::cin >> value)		// cin被隐式转换为bool
```

* 普通示例：

```cpp
class SmallInt
{
public:
    SmallInt(int value) : m_value(value) 
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
    }

    SmallInt& operator=(int value)
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
        m_value = value;
        return *this;
    }

    explicit operator int() const
    {
        return m_value;
    }

private:
    int m_value;
};


void smallIntTest(void)
{
    SmallInt si(100);
    // int value = si; // 隐式转换为int				这里的隐式转换被规避
    // cout << value << endl; // 输出100

    si = 200; // 使用赋值运算符
    cout << static_cast<int>(si) << endl; // 输出200

    try
    {
        si = 300; // 超出范围，抛出异常
    }
    catch (const out_of_range& e)
    {
        cout << e.what() << endl; // 输出异常信息
    }

    return;
}
```

#### 2.9.4 二义性问题

##### 2.9.4.1 实参匹配和相同类型转换

```cpp
class B;
class A
{
public:
    A() = default;
    A(const B&) {}
};

class B
{
public:
    B() = default;
    operator A() const { }
};

void ambiguousTest(void)
{
    A f(const A&);
    A a1;
    B b1;
    A a2 = f(b1); // 二义性调用		无法判断b1使用类型转换，还是直接使用A中构造函数
    
    A a2 = f(b1.operator A());		// 正确，使用类型B的类型转换运算符
    A a2 = f(A(b1));				// 正确，使用类型A的构造函数
    
    return;
}
```

##### 2.9.4.2 内置类型转换二义性问题

```cpp
class A
{
public:
    A(int x) = default;
    A(double x) {}
    operator int () const;
    operator double () const;
};

void test(void)
{
  	void f(long double)  ;
    A a;
    f(a);		// 二义性
    
    int x = 0;
    A a(x);		// 二义性
}
```

##### 2.9.4.3 重载函数与转换构造函数

```cpp
class C
{
    C(int)；
};

class D
{
    D(int);
}
void manip(const C&);
void manip(const D&);

manip(10);		// 二义性调用

manip(C(10));		// 可以，调用重载函数时需要显示调用构造函数或强制类型转换，其属于是设计缺陷。
```

##### 2.9.4.4 重载函数与用户自定义的类型转换

* 若两个或多个自定义的类提供了类型转换，我们认为其是一样好的，没有优先级区别。

```cpp
class C
{
    C(int)；
};

class E
{
    E(double);
};

void manip(const C&);
void manip(const E&);

manip(10);		// 二义性
```

##### 2.9.4.5 重载函数与标准类型

```cpp
class C
{
    C(int)；
};
void manip(int);
void manip(const C& c);
double dval;
manip(dval);		// which one? void manip(int);
```

* 标准转换优先级高于自定义转换。

##### 2.9.4.6 建议：

* 转换源不要定义多个算数类型
* 两个对象直接尽量不要转换
* 调用重载函数时需要显示调用构造函数或强制类型转换，其属于是设计缺陷。

#### 2.9.5 函数匹配与重载运算符

* 当使用类对象调用时，只考虑类内的成员函数。

* 对同一个提供了**转换目标是*算数类型*的类型转换**，也提供**重载的运算符**，则会遇到**重载运算符**与**内置运算符**的**二义性问题**。

```cpp
class SmallInt; // 前向声明
SmallInt operator+(const SmallInt& lhs, const SmallInt& rhs); // 声明加法运算符

class SmallInt
{
    friend SmallInt operator+(const SmallInt& lhs, const SmallInt& rhs);
public:
    SmallInt(int value) : m_value(value) 
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
    }

    SmallInt& operator=(int value)
    {
        if (value < 0 || value > 255)
        {
            throw out_of_range("Value must be between 0 and 255");
        }
        m_value = value;
        return *this;
    }

    operator int() const
    {
        return m_value;
    }

private:
    int m_value;
};

SmallInt operator+(const SmallInt& lhs, const SmallInt& rhs)
{
    int sum = lhs.m_value + rhs.m_value;
    if (sum > 255)
    {
        throw out_of_range("Sum exceeds maximum value of 255");
    }
    return SmallInt(sum);
}

void smallIntTest(void)
{
    SmallInt si(100);
    // int value = si; // 隐式转换为int
    // cout << value << endl; // 输出100

    si = 200; // 使用赋值运算符
    cout << static_cast<int>(si) << endl; // 输出200

    try
    {
        si = 300; // 超出范围，抛出异常
    }
    catch (const out_of_range& e)
    {
        cout << e.what() << endl; // 输出异常信息
    }

    SmallInt si1(100);
    SmallInt si2(150);

    SmallInt si3 = si1 + si2; // 使用加法运算符
    cout << static_cast<int>(si3) << endl; // 输出250

    int x = si3 + 5; // 二义性调用  // SmallInt + int 还是 int + SmallInt

    return;
}
```

## 三、小结

本章全面介绍了 C++ 中重载运算与类型转换的相关知识。首先明确了重载运算符的基本规则，包括参数要求、成员函数与非成员函数的适用场景、不可重载和不建议重载的运算符等，为正确重载运算符奠定了基础。

接着，分别详细讲解了输入输出运算符、算数和关系运算符、赋值运算符、下标运算符、递增和递减运算符、成员访问运算符以及函数调用运算符的重载方式，并通过示例展示了具体实现。其中，函数调用运算符的重载使得类对象可以像函数一样被调用，结合标准库中的`function`类型，能更灵活地处理可调用对象。

在类型转换方面，阐述了类型转换运算符的定义、限制以及`explicit`关键字的作用，重点分析了各类二义性问题及其解决方法，强调了合理设计类型转换的重要性。

总的来说，重载运算与类型转换是 C++ 中强大的特性，合理使用能显著提升代码的表达力和易用性，但也需要严格遵循相关规则，避免因滥用导致代码晦涩难懂或出现难以排查的错误。

## 四、建议

1. **遵循运算符原意**：重载运算符时，应尽量保证其功能与内置运算符的语义一致，避免让使用者产生理解困惑。例如，加法运算符应实现类似 “相加” 的功能，而非其他不相关的操作。
2. **谨慎选择重载形式**：明确哪些运算符适合作为成员函数，哪些适合作为非成员函数。如赋值运算符、下标运算符等必须作为成员函数，而算数、关系运算符等作为非成员函数更利于实现左右操作数的类型转换。
3. **避免不必要的重载**：对于不常用或容易引起混淆的运算符，尽量不要重载。例如，`&&`、`||`、逗号运算符等，其重载可能会改变原有求值顺序或逻辑，增加代码复杂性。
4. **控制类型转换**：除非必要，否则尽量将类型转换运算符声明为`explicit`，以防止意外的隐式转换。同时，避免在一个类中定义多个可能导致二义性的类型转换路径。
5. **处理二义性问题**：在设计类的转换构造函数和类型转换运算符时，要充分考虑可能出现的二义性，通过显式转换、调整函数参数等方式消除歧义。
6. **借助标准库**：熟悉并合理使用标准库中提供的函数对象（如`<functional>`头文件中的各类对象）和`function`类型，它们能简化代码实现，提高开发效率。
7. **注重代码测试**：重载运算符和类型转换涉及复杂的类型交互，需编写充分的测试用例，验证各种边界情况和可能的交互场景，确保代码的正确性。