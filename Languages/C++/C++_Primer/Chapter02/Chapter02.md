# 变量和基本类型

***---- Li Jinsheng***

***

## 一、概述

本章为《C++ Primer》（第5版）第二章读书笔记，分别记录本章的重点内容与《C Primer Plus》（第6版）中C语言和C++的区别。以及`C++11`标准的记录。

### 二、内容

`C++`将数据类型分类：内置类型与自定义类型，本章将阐述内置类型。

内置类型分为：算数类型（整形、浮点型）和空类型

### 2.1 基本内置类型

#### 2.1.1 `char`类型新增内容

* 新增`Unicode`字符：

| 类型       | 含义          | 最小尺寸 |
| ---------- | ------------- | -------- |
| `wchar_t`  | 宽字符        | 16位     |
| `char16_t` | `Unicode`字符 | 16位     |
| `char32_t` | `Unicdoe`字符 | 32位     |

* `char`和类型`signed char`并不一样。具体那种类型由编译器决定。（《C Primer Plus》 第3章：ReadNote中2.4.3.5 有符号还是无符号亦有记录）

#### 2.1.2 类型转换

* 表达式中是有符号和无符号混合运算时，会将有符号类型转换为**无符号**类型。

* 整数和浮点数运算符时，结果是浮点数。
* 整数的除法结果都是“趋零截断”。

* 浮点数赋值给整数，其结果有两种情况（若浮点数在整数表达的范围，向零截断。若超出范围，其结果未定义。）（《C Prime Plus》第5章 ReadNote:2.5 类型转换）

#### 2.1.3 字面值常量

##### 2.1.3.1 浮点型字面值是一个`double`类型。

##### 	（《C Prime Plus》 第三章 2.4.6.2 浮点型常量）

##### 2.1.3.2 转义序列

与C不同的是C++中`\xhh`要用到后面跟的所有数字，而C的范围是1~3。（《C Prime Plus》第3章  2.4.3.3 非打印字符（转义序列））

##### 2.1.3.3 新增字符类型的前缀

| 前缀 | 含义            | 类型       |
| ---- | --------------- | ---------- |
| `u`  | `Unicode`16字符 | `char16_t` |
| `U`  | `Unicode`32字符 | `char32_t` |
| `L`  | 宽字符          | `wchar_t`  |
| `u8` | `UTF-8`         | `char`     |

其余后缀与C语言中相同见《C Prime Plus》 第3章。

### 2.2 变量

#### 2.2.1 初始化列表（C++11）

使用花括号进行初始化`{}`可以广泛使用。对于内置类型，在初始化时，若存在**数据丢失（类型不匹配）**，编译器会报错。

```cpp
int i{0};
int j = {0};
```

### 2.3 复合类型

在C++中对象（object）和变量（variable）基本可以互换。

#### 2.3.1 引用

##### 2.3.1.1 右值引用 （C++11）

C++中引用指“左值引用”。

C++11中引入“右值引用”。将在第13章介绍。

引用（*reference to*）是一个对象的别名，它**本身不是对象**，没有对应的内存空间。初始引用时，将初始值和引用**绑定**（*bind*）在一起。一旦初始化完成，引用就会和其对象绑定在一起，**无法让一个已初始化的引用绑定其他对象**。

```c
int i = 0;
int &ci = i;
```

* 引用不是对象，**不能定义引用的引用**。
* 引用与其绑定的对象的类型必须一致。
* **不能将引用与常量表达式绑定**。

#### 2.3.2 指针

* 引用与指针的区别见：

[引用和指针的区别]: ../../Tips/引用和指针的区别.md	"引用和指针的区别"

##### 2.3.2.1 **空指针（C++11）**：C++11引入`nullptr`用来初始化指针，它可以转换为任意类型的指针。

### 2.3 `const`限定符

#### 2.3.1 初始化和`const`

* `const`修饰的全局对象默认是**内部链接**，若要在其他文件中使用，需要使用`extern`声明。若其他文件有同名，则视为其他文件有各自的对象。

```cpp
// file1.cpp（定义外部可见的 const 变量）
extern const int const_var = 300;  // 显式 extern 使其具有外部链接

// file2.cpp（使用该变量）
extern const int const_var;  // 正确：可跨文件访问
```

* C语言中`const`修饰的全局变量默认是外部链接。

#### 2.3.2 `const`引用

##### 2.3.2.1 初始化和`const`引用

```c
int i = 0;
const int &ci = i;	// 正确

const int i2 = 0;
int &c2 = i2;		// 错误，不允许非常量引用绑定一个常量对象。
```

* 不能通过引用来修改绑定对象的内容。
* 不允许非常量引用绑定一个常量对象

* 初始化特殊性：
  * 允许用**任意表达式**作为初始化，只要该表达式的值**可以转换**为相同的类型。
  * 允许用常量引用**绑定一个非常量的对象**。
  * 允许绑定一个对象。

```c
int i = 42;
const int &ci = i;		// 允许，常量引用绑定一个非常量的对象。
const int &c2 = i + 1;	// 允许，表达式的结果可以转换为
const int &c3 = 42;		// 允许，c3是一个常量
int &c4 = c1 * 2;		// 错误，c4是一个非常量引用。
```

* 绑定一个临时值，若常量引用语法上被绑定的对象和其类型不同，它会绑定一个临时值。

```c
double dval = 3.1415;
const int &ri = dval;

/*
实际运行过程
const int temp = dval;
const int &ri = temp;
*/
```

#### 2.3.3 指针和`const`

指向常量的指针（*pointer to const*）：不允许通过指针修改其所指对象的内容。

```cpp
const int *p;
```

常量指针（*const pointer*）:不允许修改指针本身。

```cpp
int *const p;
```

#### 2.3.4 顶层`const`

* 顶层`const`：指针是一个常量，或**对象本身是常量**。

* 底层`const`：**指针指向一个常量**。

| 场景         | 顶层 const                                   | 底层 const                                                   |
| ------------ | -------------------------------------------- | ------------------------------------------------------------ |
| 修饰对象     | **变量本身**（如 `int const`、`int* const`） | 变量指向的内容（如 `const int*`、`const int&`）              |
| 复制规则     | 复制时可忽略顶层 const 属性                  | 复制时必须保持底层 const 兼容（非常量 → 常量允许，反之不允许） |
| 函数参数传递 | 实参可以是常量或非常量                       | 实参必须是常量（或可转换为常量的对象）                       |

```cpp
int x = 5;
const int y = 10;  // 顶层const

// 顶层const复制：允许，忽略顶层const
int a = y;         // 正确：y是顶层const，复制其值给a（a是非常量）

const int* p = &x;  // 底层const：p指向的内容是常量
int* q = p;         // 错误：q是非常量指针，不能指向p指向的常量内容
const int* r = p;   // 正确：r也是底层const，兼容

int* const s = &x;  // 顶层const：s本身是常量指针
int* t = s;         // 正确：复制时忽略顶层const（t是非常量指针，指向x）
```

### 2.3.4 `constexper`和常量表达式（C++11）

常量表达式（*const experssion*）是指值不会改变，且在编译时就可以得到。可以用常量表达式来初始化常量。比`const`更加严格。

* 修饰变量，表示编译时可确定值。对于指针其修饰的是指针本身。

```cpp
constexpr int MAX_SIZE = 100;  // 编译期常量
int arr[MAX_SIZE];  // 合法：数组大小必须是编译期常量

const int a = 10;
constexpr int b = a + 5;  // 合法：a是const且初始化值是常量，可在编译期计算

int b = 2;
constexpr int *p = &b;	 //  这里p时常量指针。
```

* 定义函数：表明函数在编译传入常量参数时，可以在编译器计算出结果。

```c
// 编译期可计算的函数：求阶乘
constexpr int factorial(int n) {
    return (n <= 1) ? 1 : n * factorial(n - 1);
}

int main() {
    constexpr int val = factorial(5);  // 编译期计算，结果为120
    int arr[factorial(3)];  // 合法：编译期计算出3! = 6，作为数组大小
    return 0;
}
```

* 修饰构造函数。

```cpp
class Point {
public:
    // constexpr构造函数：允许在编译期创建对象
    constexpr Point(int x, int y) : x_(x), y_(y) {}
    
    constexpr int getX() const { return x_; }
    constexpr int getY() const { return y_; }

private:
    int x_, y_;
};

int main() {
    constexpr Point p(3, 4);  // 编译期创建对象
    constexpr int x = p.getX();  // 编译期获取属性，x = 3
    return 0;
}
```

### 2.4 处理类型

#### 2.4.1 `auto`类型说明符（C++11）

`auto`让编译器根据表达式推测的类型。

* 可以使用`auto`语句声明多个变量，但是这些变量必须类型相同。

```c
auto i = 2, &r = i;		// 错误，i 和 r的类型不相同
```

* 使用`auto`推测类型会忽略引用与顶层`const`但会**保留底层**`const`(**对一个常量对象取地址是一种底层`const`**)

```c
int i = 1;
int &r = i;

auto r1 = r;		// r1是int类型
auto &r2 = i;		// r2是变量i的引用

const int i1 = 42;

auto n1 = i1;		// n1是int类型


const auto p1 = &i;	// p1是一个指向int类型的指针
const auto p2 = &i1 // p2是一个指向int类型的常量指针
```

#### 2.4.2 `decltype`类型说明符(C++11)

`decltype`返回操作数(变量或者表达式)的数据类型

* 会保留**引用**和**顶层`const`**
* 对**指针解引用**和对**变量进行括号运算**其返回类型均为**引用**.

```c
const int ci = 0, &cj = ci;
decltype(ci) x = 0;		// x的类型是 const int
decltype(cj) y = x;		// y的类型是 const int&, y绑定到x

int i = 42, j = 43, K = 44, *p = &i, &r = i;
decltype(r + 0) b;		// 正确, b的类型是int
decltype(*p) c = j;		// 正确, j的类型是int &, c绑定到j
decltype((i)) e = k;	// 正确, e的类型是int&, e绑定到k
```

## 三、C和C++的差异

### 3.1 对const修饰变量初始化

[C与C++对const修饰内容初始化的不同]: ../../Tips/C与C++对const修饰内容初始化的不同.md

## 四、小结

本章主要介绍了C++中基本数据类型、指针和引用。

* 其中指针与引用的区别：

[引用和指针的区别]: ../../Tips/引用和指针的区别.md	"引用和指针的区别"

* C和C++对`const`修饰的全局变量，以及C++将`const`修饰的变量默认为内部链接。

[C与C++对const修饰内容初始化的不同]: ../../Tips/C与C++对const修饰内容初始化的不同.md	"C与C++对const修饰内容初始化的不同"

* 顶层`const`：修饰对象本事，即对象本身是常量。
* 底层`const`：修复所指向的内容，即对象本身可以修改，但不能对象修改所指内容。
* `auto`与`decltype`说明符的区别：
  * `auto`会忽略顶层`const`与引用。
  * `decltype`会保留顶层`const`与引用。
* 对常量取地址的操作是底层`const`。

