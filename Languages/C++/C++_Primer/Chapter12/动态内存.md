# 动态内存

***---- Li Jinsheng***

***

## 一、概述

本章围绕 C++ 动态内存管理展开，系统介绍了动态内存的核心管理方式及相关工具。内容以智能指针为重点，详细阐述了`shared_ptr`（通过引用计数实现共享所有权）、`unique_ptr`（独占对象所有权）、`weak_ptr`（不影响引用计数，解决循环引用问题）三种智能指针的定义、支持的操作、使用场景及注意事项，包括它们与`new`的结合、自定义删除器的使用、对动态数组的处理等。

同时，本章也涵盖了直接管理内存的方式，讲解了`new`和`delete`的使用、动态分配`const`对象的方法以及空悬指针的风险。对于动态数组，介绍了其通过`new[]`和`delete[]`的管理方式，以及智能指针对动态数组的支持差异。

此外，还引入了`allocator`类，说明其将内存分配与对象构造分离的特性，及其支持的操作和配套算法，展示了更底层的内存管理能力。

整体而言，本章旨在帮助理解 C++ 中动态内存的管理机制，对比不同管理方式的特点与适用场景，强调智能指针在减少内存泄漏风险方面的优势。

## 二、内容

### 2.1 动态内存和智能指针

归属头文件`<memory>`

### 2.2 `shared_ptr`类

模板，会自己进行引用计数，当计数为0，自动销毁所指对象并释放内存。**默认使用delete释放它所关联的对象**。

#### 2.2.1 支持操作

```cpp
shared_ptr<T> sp
p
*p
p->mem
p.get()					// 返回p中保存的指针。注意若智能指针释放了其对象，返回指针所指的对象也会消失。
swap(p, q)
p.swap(q)

make_shared<T>(args)		// 返回一个shared_ptr指针，指向一个动态分配的类型为T的对象。
shared_ptr<T>p(q)			// p 是 q 的拷贝；q的引用计数会增加
shared_ptr<T>p (q, d)		// p接管了q所指的对象，并用可调对象（第10章：2.2 谓词、lambda）替换了delete用来释放p所指的内容
p = q						// p会递减引用计数，q会增加引用计数
p.unique()					// p.use_count()是1，返回true,否则返回false
p.use_count()				// 返回引用计数
p.reset()					// 若p是唯一指向对象的shared_ptr，reset会释放对象，否则将p置为空
p.reset(q)					// p指向非空的内置类型指针q
p.reset(q, d)				// 用可调对象（第10章：2.2 谓词、lambda）替换了delete用来释放p所指的内容
```

#### 2.2.2 `make_shared`使用

```cpp
// 直接构造
shared_ptr<int> pi = make_shared<int>(42);

auto pi2 = make_shared<int>(43);

// 函数返回值
shared_ptr<int> initSharedPtrTest(int x)
{
    return make_shared<int>(x);
}
```

#### 2.2.3 引用计数

```cpp
// 直接构造
shared_ptr<int> pi = make_shared<int>(42);

auto pi2 = make_shared<int>(43);

pi = pi2;		// pi2的引用计数增加，pi引用计数归0，释放。

// 函数返回值
shared_ptr<int> initSharedPtrTest(int x)
{
    return make_shared<int>(x);		// 离开作用域，但作为返回值会被拷贝，引用计数不会归0
}

void useSharedPtr(void)
{
    shared_ptr<int> sp = initSharedPtrTest(10);		
    // 使用 sp
}   // sp离开作用域，它指向的内存会被自动释放掉
```

#### 2.2.4 使用动态内存的原因

* 不知道自己需要使用多少对象
* 不知道所需对象的准确类型
* 需要在多个对象中共享数据

#### 2.2.5 和`new`的结合

* `shared_ptr`构造函数中接受指针类型，注意这个构造函数是`explicit`（*第7章，2.3.6 `explicit`抑制构造函数的隐式转换*）。只能拒绝隐式转换、拷贝构造、只能直接初始化。

```cpp
shared_ptr<int> pi(new int(42));		// 合法
shared_ptr<int> pi = new int(42);		// 不合法！！！
```

#### 2.2.6 接受自定义释放操作！！！

```cpp
shared_ptr<T> p(q, d)		// p接管了q所指的对象，并用可调对象（第10章：2.2 谓词、lambda）替换了delete用来释放p所指的内容
    
shared_ptr<int> pnum(new int[10], [](int* p){ delete []p;});
```

#### 2.2.7 `shared_ptr`不支持对动态数组的操作

```cpp
shared_ptr<int> pnum(new int[10], [](int* p){ delete []p;});

// 若需要对数组进行访问需要用get()返回指针本身
auto p = pnum.get();
for (size_t i = 0; i < 10; ++i)
{
    cout << *p++ << endl;
}
```

#### 2.2.8 `get()`返回托管指针本身是高风险操作！！！

```cpp
#include <memory>
#include <iostream>

using namespace std;

void sharedPtrTest(void)
{
    shared_ptr<int> p1(new int(42));
    shared_ptr<int> p2 = make_shared<int>(43);
    auto p3 = p1.get();

    delete p3; // Undefined behavior: p1 now points to a deleted object

    // cout << "*p1: " << *p1 << endl;
    cout << "*p2: " << *p2 << endl;
    cout << "p1.use_count(): " << p1.use_count() << endl;			// Result:1 
    cout << "p2.use_count(): " << p2.use_count() << endl;

    return;

}

int main(void)
{
    sharedPtrTest();

    return 0;
}
```

#### 2.2.9 风险注意：

* 不要使用相同的内置指针初始化或`reset`多个智能指针
* 不`delete``get()`返回的指针
* 不使用`get()`初始化或`reset()`另一个智能指针
* 如果使用`get()`，切记当智能指针引用归0，所指对象被释放，返回的指针也无效了

### 2.3 `unique_ptr`类

只能绑定一个`new`返回的指针，不能通过**隐式转换和拷贝构造（传参和返回值除外）**，**要直接初始化**。

#### 2.3.1 支持操作

```cpp
unique_ptr<T> up
unique_ptr<T, D> up2		// up2对调用一个D的可调用对象释放它的指针
unique_ptr<T, D> u(d)		// 空unique_ptr, 用类型D的对象替代delete

up = nullptr				// 释放所指对象，将up置为空
up.relase()					// up放弃控制权，返回绑定指针，up置空。
up.reset()					// 释放up所指对象
up.reset(q)					// 若q为内置指针，则up指向q。否则u置为空。
up.reset(nullptr)
    
p
*p
p->mem
p.get()					// 返回p中保存的指针。注意若智能指针释放了其对象，返回指针所指的对象也会消失。
swap(p, q)
p.swap(q)
```

#### 2.3.2 `release()`和`reset()`的理解

*    `release()` 交出控制权限，但不释放所指内存。

```cpp
unique_ptr<int> p1(new int(42));
p1.release();		// 错误：p1不会释放内存，但是p1本身已经被置空了。
auto p2 = p1.release();		// 正确，但现在就需要我们手动delete了。
```

*    `reset()`会直接释放所指内存。

```cpp
#include <memory>
#include <iostream>

using namespace std;

void uniquePtrTest(void)
{
    unique_ptr<int> p1(new int(42));
    unique_ptr<int> p2 = make_unique<int>(43);
    
    // release() 交出控制权限，但不释放所指内存
    // reset()会直接释放所指内存。
    p2.reset(p1.release()); // Transfer ownership from p1 to p2

    unique_ptr<int> p3(p2.release()); // Transfer ownership from p2 to p3

    // cout << "*p2: " << *p2 << endl; // Undefined behavior: p2 is now nullptr
    cout << "*p3: " << *p3 << endl;

    return;

}

int main(void)
{
    uniquePtrTest();
    return 0;
}
```

#### 2.3.3 可以拷贝将要销毁的对象（传参和返回值）

```cpp
unique_ptr<int> createUniquePtr(void)
{
    unique_ptr<int> p(new int(100));
    return p; // Return by value, ownership is transferred to the caller
}

int main(void)
{
    unique_ptr<int> p4 = createUniquePtr();

    int* p5 = new int(200);
    unique_ptr<int> p6(p5); // Take ownership of p5

    cout << "*p4: " << *p4 << endl;		// *p4: 100

    cout << "*p6: " << *p6 << endl;		// *p6: 200

    return 0;
}
```

#### 2.3.4 传递删除器（函数指针类型）

* *第6章：2.8.1 `decltype`返回函数类型*

```cpp
class connection;

void end_connect()
{
    ...
}

connection* c = new connection();
unique_ptr<connection, dealtype(end_connect)*> p(c, end_connect);
```

#### 2.3.5 `unique_ptr`支持动态数组的操作与释放

```cpp
int main(void)
{
    unique_ptr<int[]> p7(new int[5]{1, 2, 3, 4, 5}); // Unique pointer to an array

    for (size_t i = 0; i < 5; ++i)
    {
        cout << "p7[" << i << "]: " << p7[i] << endl;
    }
    return 0;
}

/*
Result:
p7[0]: 1
p7[1]: 2
p7[2]: 3
p7[3]: 4
p7[4]: 5
*/
```

### 2.4 `weak_ptr`类

绑定一个`shared_ptr`类，不会改变其引用计数。`shared_ptr`被销毁后，对象就会被释放。

#### 2.4.1 支持操作

```cpp
weak_ptr<T> w
weak_ptr<T> w(sp)			// 与shared_ptr指向相同的类型
w = q

w.reset()					// 将w置为空
w.use_count()				// 与shared_ptr共享数量
w.expired()					// 若use_count()为0，则返回true，否则返回false
w.lock()					// weak_ptr不能直接访问，需要通过lock返回一个shared_ptr进行访问。若expired返回为true，则返回一个空的shared_ptr
```

```cpp
if (shared_ptr<int> np = wp.lock())
{
    ...
}
```

### 2.5 直接管理内存

#### 2.5.1 申请和释放

```cpp
// 申请
Type* identifer = new Type construct function()
int* pi = new int(10);
int* pi2 = new int;

// 释放
delete pointer;
```

#### 2.5.2 动态分配`const`对象

```cpp
const int* pi = new const int(1024);
```

#### 2.5.3 空悬指针

空悬指针（*dangling pointer*）：`delete`释放内存之后，未将指针置为空指针（`nullptr`）。即指向一块已经释放内存的指针。

### 2.6 动态数组

#### 2.6.1 `new`和数组

* new分配数组返回的是**一个元素类型的指针**。

```cpp
int* pnum = new int[size];
```

* 数组大小可以为0，但不能解引用。

```cpp
int* pnum2 = new int[0];		// 合法，但不能解引用
```

* 释放

```cpp
delete []pnum;
delete []pnum2;
```

#### 2.6.2 智能指针和动态数组

* `unique_ptr`支持下标访问数组操作，自动调用`delete []`销毁内存，模板类型为：`Type[]`

```cpp
int main(void)
{
    unique_ptr<int[]> p7(new int[5]{1, 2, 3, 4, 5}); // Unique pointer to an array

    for (size_t i = 0; i < 5; ++i)
    {
        cout << "p7[" << i << "]: " << p7[i] << endl;
    }
    return 0;
}

/*
Result:
p7[0]: 1
p7[1]: 2
p7[2]: 3
p7[3]: 4
p7[4]: 5
*/
```

* `shared_ptr`不支持数组下标访问，不会自动调用`delete []`销毁，模板类型是元素类型Type。

```cpp
shared_ptr<int> pnum(new int[10], [](int* p){ delete []p;});

// 若需要对数组进行访问需要用get()返回指针本身
auto p = pnum.get();
for (size_t i = 0; i < 10; ++i)
{
    cout << *p++ << endl;
}
```

### 2.7 `allocator`类

`allocator`是模板。`new`会将内存分配与构造整合在一起，`allocator`会将内存分配（一段原始的、未被构造的）和初始化分开。

#### 2.7.1 支持操作

```cpp
allocator<T> a				// 定义一个名为a的allocator对象，它可以为T类型分配内存

a.allocate(n)				// 分配一段原始的，未被构造的内存，保存n个类型为T的对象。返回一个T类型的指针

a.construct(p, args)		// p是allocate返回的指针，args是T*类型的构造参数。

a.destroy(p)				// p是T*类型指针，对p所指对象进行析构
    
a.deallocate(p, n)			// 释放从T*指针p开始的内存，其保存了n个类型为T的对象，n必须是创建时的大小，在此之前必须先调用destory销毁对象
```

#### 2.7.2 配套算法（只能和allocator配套！！！）

```cpp
// 返回一个指针，指向最后一个构造元素的下一个位置
uninitialized_copy(b, e, b2)		// 将迭代器b开始到e指定范围的元素拷贝到b2指定的未构造的内存中
uninitialized_copy_n(b, n, b2)		// 从迭代器b指向的元素开始，拷贝n个元素到b2开始的内存中取
uninitialized_fill(b, e, t)			// 迭代器b和e指定范围的原始内存中创建对象，对象值均为t的拷贝
uninitialized_fill_n(b, n, t)		// 从迭代器b创建n个对象，对象值均为t的拷贝
```

#### 2.7.2 示例

```cpp
#include <memory>
#include <iostream>
#include <vector>

using namespace std;

// 通用
void allocatorTest(void)
{
    // Allocator usage example
    allocator<int> alloc; // Create an allocator for int
    int * p = alloc.allocate(5); // Allocate space for 5 ints

    for (size_t i = 0; i < 5; ++i)
    {
        alloc.construct(&p[i], static_cast<int>(i) * 10); // Construct ints in allocated space
    }

    for (size_t i = 0; i < 5; ++i)
    {
        cout << "p[" << i << "]: " << p[i] << " ";
    }
    cout << endl;

    for (size_t i = 0; i < 5; ++i)
    {
        alloc.destroy(&p[i]); // Destroy the constructed ints
    }

    alloc.deallocate(p, 5); // Deallocate the space

    return;
}

// 结合算法
void allocatorAlgrothmTest(void)
{
    allocator<int> alloc; // Create an allocator for int
    int * p = alloc.allocate(10); // Allocate space for 5 ints

    vector<int> vecNum({0, 1, 2, 3, 4, 5, 6, 7, 8, 9});

    uninitialized_copy(vecNum.begin(), vecNum.end(), p); // Copy elements to allocated space

    for (size_t i = 0; i < 10; ++i)
    {
        cout << "p1[" << i << "]: " << p[i] << " ";
    }
    cout << endl;

    auto end = uninitialized_fill_n(p, 10, 0); // Fill allocated space with 42

    unsigned size = end - p;

    cout << "size: " << size << endl;

    for (size_t i = 0; i < 10; ++i)
    {
        cout << "p2[" << i << "]: " << p[i] << " ";
    }
    cout << endl;

    while(end != p)
    {
        alloc.destroy(--end); // Destroy the constructed ints
    }

    alloc.deallocate(p, 10); // Deallocate the space

    return;
}

int main(void)
{
    allocatorTest();

    allocatorAlgrothmTest();

    return 0;
}

/*
Result:
p[0]: 0 p[1]: 10 p[2]: 20 p[3]: 30 p[4]: 40 
p1[0]: 0 p1[1]: 1 p1[2]: 2 p1[3]: 3 p1[4]: 4 p1[5]: 5 p1[6]: 6 p1[7]: 7 p1[8]: 8 p1[9]: 9
size: 10
p2[0]: 0 p2[1]: 0 p2[2]: 0 p2[3]: 0 p2[4]: 0 p2[5]: 0 p2[6]: 0 p2[7]: 0 p2[8]: 0 p2[9]: 0
*/
```

### 三、小结

1. **智能指针**：
   - **`shared_ptr`**：通过引用计数实现共享所有权，计数为 0 时自动释放内存。支持`make_shared`创建（高效首选），可自定义删除器，但不直接支持动态数组操作，需手动指定数组删除器。使用时需避免多个智能指针绑定同一内置指针、误用`get()`返回的指针等风险。
   - **`unique_ptr`**：独占对象所有权，不可拷贝（除销毁前的移动场景）。支持动态数组的下标访问，自动用`delete[]`释放，也可自定义删除器，通过`release()`移交所有权、`reset()`释放内存。
   - **`weak_ptr`**：绑定`shared_ptr`但不影响引用计数，用于解决循环引用问题。需通过`lock()`获取`shared_ptr`才能访问对象，可通过`expired()`判断所指对象是否已释放。
2. **直接管理内存**：
   - 用`new`动态分配对象（支持`const`对象），`delete`释放内存，需避免空悬指针（释放后未置空）。
   - 动态数组通过`new[]`分配、`delete[]`释放，返回元素类型指针，`unique_ptr`可直接管理，`shared_ptr`需手动指定数组删除器。
3. **`allocator`类**：
   - 分离内存分配与对象构造，通过`allocate()`分配原始内存，`construct()`构造对象，`destroy()`析构对象，`deallocate()`释放内存。配套`uninitialized_copy`等算法用于批量初始化未构造内存，适用于需精细控制内存的场景。

整体而言，智能指针是动态内存管理的推荐方式，可大幅减少内存泄漏风险；直接管理内存需手动控制生命周期，易错；`allocator`则提供了更底层的内存与对象分离管理能力。