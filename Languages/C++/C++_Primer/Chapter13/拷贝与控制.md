# 拷贝与控制

***---- Li Jinsheng***

***

## 一、概述

本章围绕 C++ 中类的拷贝控制机制展开，详细讲解了拷贝构造函数、拷贝赋值运算符、析构函数的定义、作用及编译器合成规则，延伸至 C++11 引入的移动语义（右值引用、移动构造、移动赋值）、交换操作的异常安全实现，以及引用限定符对成员函数调用的限制。通过代码示例说明拷贝控制成员的实现逻辑，帮助理解如何管理类的资源（如动态内存）及避免常见错误（如重复释放、浅拷贝问题）。

## 二、内容

### 2.1 拷贝、赋值和销毁

#### 2.1.1 合成拷贝构造函数

* 作用：将其参数（非static）成员进行逐个拷贝到正在创建的对象中。

* 风险：
  * 成员的**析构函数**是删除的或不可访问（是`private`的），则合成拷贝构造函数被定义为删除的。
  * 成员的**拷贝构造函数**是删除或无法访问的，则合成拷贝构造函数被定义为删除的。
* 格式：

```cpp
#include <iostream>

using namespace std;

class Base {
public:
    Base(int y = 0):x(y) { cout << "Base Constructor" << endl; }
    Base(const Base& rhs):x(rhs.x) { cout << "Base Copy Constructor" << endl; }
    ~Base() { cout << "Base Destructor" << endl; }
private:
    int x;
};


int main() 
{
    Base b1(10);
    Base b2 = b1; // Copy constructor is called here
    return 0;
}

/*
Exiting main
Base Constructor
Base Copy Constructor
Base Destructor
Base Destructor
*/
```

* 使用场景：

  * 实参传递给非引用形参。

  * 函数为非引用类型的返回值。
  * 花括号初始化列表一个数组中的元素或聚合类。

#### 2.1.2 拷贝赋值运算符

* 作用：将赋值运算符右边对象的（非static）成员拷贝至左边对象中。
* 合成拷贝赋值运算符的风险：
  * 若成员的**赋值运算符**被定义为删除或不访问（`private`）。
  * 若**引用成员**：合成拷贝赋值运算符被定义为删除。
  * 若**有`const`的成员**：合成拷贝赋值运算符被定义为删除。
* 格式：

```cpp
#include <iostream>

using namespace std;

class Base {
public:
    Base(int y = 0):x(y) { cout << "Base Constructor" << endl; }
    Base(const Base& rhs):x(rhs.x) { cout << "Base Copy Constructor" << endl; }
    // 拷贝赋值运算
    Base& operator=(const Base& rhs);
    ~Base() { cout << "Base Destructor" << endl; }
private:
    int x;
};

Base& Base::operator=(const Base& rhs) 
{
    cout << "Base Assignment operator" << endl;
    if (this != &rhs) {
        x = rhs.x;
    }
    return *this;
}

int main() 
{
    cout << "\nExiting main" << endl;

    Base b1(10);
    Base b2 = b1; // Copy constructor is called here
    
    Base b3;
    b3 = b1;      // Assignment operator is called here
    
    return 0;
}
```

#### 2.1.3 析构函数

* 作用：释放对象所用资源，并销毁类中（非`static`）数据成员。
* 数据成员：
  * 数据成员销毁的位置：**数据成员的销毁在析构函数体执行后的析构阶段。**即先执行函数体，后销毁成员（按构造的逆序）。
  * 内置指针成员：对内置指针类型成员，析构函数不会调用`delete`释放内存。

* 合成构造函数风险：
  * 若成员的析构函数是删除或不访问的，则合成析构函数被定义为删除的。
* **删除析构函数的风险**：**不能构造类对象，可以动态分配指向类的指针，但不能delete指针。**
* 类的引用或指针的析构：当对象的引用或指针离开作用域，析构函数不会执行。

#### 2.1.4 三/五法则

* 三个基本控制类的拷贝操作：拷贝构造函数、拷贝赋值运算符和析构函数。C++11拓展了：**移动构造函数**和**移动赋值运算符**。
* 需要析构函数的类型也需要拷贝和赋值运算符。
* 拷贝构造函数和赋值运算符是伴生的。

#### 2.1.5 `=default`

* 作用：生成对应默认函数。
* 示例：注拷贝赋值运算符在类外使用。

```cpp
class Base {
public:
    Base()=default;
    Base(const Base& rhs)=default;
    Base& operator=(const Base& rhs);
    ~Base()=default;
private:
    int x;
};

Base& Base::operator=(const Base& rhs) = default;
```

#### 2.1.6 阻止拷贝

* 使用场景：`istream`、`ostream`和`unique_ptr`不允许拷贝，但编译器会自动生成拷贝构造函数和拷贝赋值运算符，故有了这一场景。

* `=delete`示例：

```cpp
class Base {
public:
    Base()=default;
    Base(const Base& rhs)=delete;			// 删除拷贝构造函数
    Base& operator=(const Base& rhs)=delete;// 删除拷贝赋值运算符
    ~Base()=default;
private:
    int x;
};
```

* `priavet`设置为不可访问，风险：类的友元可以访问。

```cpp
class Base {
public:
    Base()=default;
    ~Base()=default;
private:
    Base(const Base& rhs)=default;			// 删除拷贝构造函数
    Base& operator=(const Base& rhs)=default;// 删除拷贝赋值运算符
    int x;
};
```

* 建议：若要删除对应的拷贝构造函数或拷贝赋值运算符用`=delete`。

#### 2.1.7 综述：

若类中存在成员无法默认进行构造、拷贝、赋值或销毁（如成员的对应操作被删除），则类的对应拷贝控制成员会被编译器定义为删除的。

### 2.2 拷贝控制和资源管理

当类中有指针或其他动态内存分配成员时，开发者要明确类的行为：值还是指针。

* **值语义**：指针成员指向独立内存，拷贝时复制数据（深拷贝）。例如`string`类，每个对象拥有独立的字符数组。

* **指针语义**：指针成员共享同一块内存，需通过**引用计数**管理资源（类似`shared_ptr`）。引用计数存储在动态内存中，拷贝时计数 + 1，析构时计数 - 1，计数为0时释放资源
* 为什么类似值的引用计数不放在`static`成员中？（笔者自己第一反应）：因为`static`时类的对象共享的，在拷贝赋值的过程中，左侧对象的引用计数要-1，右侧对象引用计数要+1。`static`成员无法实现了共享但未实现独立，故不行。动态内存中拷贝时只要向对应指针成员指向同一内存即可。

### 2.3 交换操作

自定义`swap`函数可提升赋值操作的**异常安全性**，避免深拷贝的性能开销。

* 使用场景：
  * 将自定义`swap`定义为类的友元。
  * 内部使用`using std::swap`启用参数依赖查找（ADL）。
  * 拷贝赋值运算符中（注，其形参是类的对象）

```cpp
Base& Base::operator=(Base b)
{
    using std::swap;
    swap(*this, b);
    return *this;
}
```

* 传统`swap`的工作方式（以深拷贝为例）：

```cpp
class Buffer {
private:
    int* data;
    size_t size;
public:
    // 构造、拷贝构造、赋值运算符（均需深拷贝）
    // ...
};

// 默认std::swap的效果等价于：
void bad_swap(Buffer& a, Buffer& b) {
    Buffer temp(a);   // 深拷贝：分配新内存并复制数据
    a = b;            // 深拷贝：释放a旧内存，复制b的数据
    b = temp;         // 深拷贝：释放b旧内存，复制temp的数据
}
```

* 当前自定义（高效、仅交换指针）：

```cpp
#include <iostream>
#include <string>

using namespace std;

class Base;
void swap(Base& lhs, Base& rhs);

class Base 
{
    // 友元授权
    friend void swap(Base& lhs, Base& rhs);
public:
    Base(int y = 0, string s = string("")):x(y), str(new string(s)) { cout << "Base Constructor" << endl; }
    Base(const Base& rhs):x(rhs.x), str(new string(*(rhs.str))) { cout << "Base Copy Constructor" << endl; }
    // Base& operator=(const Base& rhs);
    Base& operator=(Base rhs); // Pass by value to leverage copy constructor
    ~Base() {
        delete str;
        str = nullptr; 
        cout << "Base Destructor" << endl; 
    }
private:
    int x;
    string* str = nullptr;
};

void swap(Base& lhs, Base& rhs) 
{
    using std::swap; // Enable ADL
    cout << "addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    swap(lhs.x, rhs.x);
    cout << "After swap: addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    
    cout << "addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
    swap(lhs.str, rhs.str);				// 交换指针地址
    cout << "After swap: addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
}

Base& Base::operator=(Base rhs) // Pass by value to leverage copy constructor
{
    cout << "Base Assignment operator (copy-and-swap)" << endl;
    swap(*this, rhs); // Swap the contents
    return *this;
}

int main() 
{
    cout << "\nExiting main" << endl;

    Base b1(10);
    Base b2 = b1; // Copy constructor is called here
    
    Base b3;
    b3 = b1;      // Assignment operator is called here
    
    return 0;
}

/*
Base Assignment operator (copy-and-swap)
addr: lhs.x = 0x61fda0, addr: rhs.x = 0x61fe30
After swap: addr: lhs.x = 0x61fda0, addr: rhs.x = 0x61fe30

addr: lhs.str = 0x673e10, addr: rhs.str = 0x673e60
After swap: addr: lhs.str = 0x673e60, addr: rhs.str = 0x673e10
*/
```

### 2.4 拷贝控制示例

后续实现... ...

### 2.5 动态内存管理类

后续实现......

### 2.6 对象移动

#### 2.6.1 右值引用

* 作用：绑定一个即将销毁的值。
* 对应数据类型：表达式（`i+2`）、字面值常量（`42`）、返回右值的表达式（`Base()`）（算数运算、关系、位、后置递增/递减）生成的都是右值。**右值引用不能绑定右值引用**。
* 左值引用：下标访问、解引用、赋值、前置递增。

* 格式：

```cpp
int i = 42;
int &r = i;
int && rr = i * 42;			// 将右值引用绑定到算数表达式的结果上
const int& r3 = i * 42;		// 将const引用绑定到一个右值上

int && rr1 = rr;			// 错误，rr是一个左值。
```

* `std::move()`：将左值强制转换为右值引用（提示编译器：该对象可被移动）。

```cpp
#include <iostream>
#include <string>
#include <utility>

using namespace std;

int main(void)
{
    int i = 10;
    int &r = i; // r is an lvalue reference to i

    int &&r1 = 20; // r1 is an rvalue reference to a temporary integer with value 20
    int &&r2 = i + 10; // r2 is an rvalue reference to the result of i + 10, which is a temporary integer with value 20

    cout << "i = " << i << endl;       // Outputs: i = 10
    cout << "r1 = " << r1 << endl;     // Outputs: r1 = 20
    cout << "r2 = " << r2 << endl;     // Outputs: r2 = 20

    int && r3 = std::move(i); // r3 is an rvalue reference to i, which is treated as an rvalue
    r3 += 10; // Modifies i through r3
    cout << "After modifying r3, i = " << i << endl; // Outputs

    int && r4 = std::move(r1); // r4 is an rvalue reference to r1, which is treated as an rvalue
    r4 += 10; // Modifies r1 through r4
    cout << "After modifying r4, r1 = " << r1 << endl;

    int && r5 = std::move(r); // r5 is an rvalue reference to r, which is treated as an rvalue
    r5 += 10; // Modifies i through r5
    cout << "After modifying r5, r = " << r << endl;
	
    
    // 引用可以绑定在右值引用上
    int& r6 = r1; // r6 is an lvalue reference to r1
    r6 += 10; // Modifies r1 through r6
    cout << "After modifying r6, r1 = " << r1 << endl;

    return 0;

}
```

#### 2.6.2 移动构造函数

* 作用：将右值对象的资源**转移**给新对象（而非拷贝），提升性能。

* 格式：与拷贝构造函数相比，形参为类的右值引用，通常标记`noexcept`（避免移动过程中抛出异常导致容器未定义行为）

#### 2.6.3 移动赋值运算符

- 作用：将右值对象的资源转移给已有对象。
- 格式：形参为类的右值引用，需先释放当前对象资源，再接管源对象资源，标记`noexcept`。

#### 2.6.4 移动构造和移动赋值运算符示例：

```cpp
#include <iostream>
#include <string>
#include <utility>

using namespace std;

class Base;
void swap(Base& lhs, Base& rhs);

class Base 
{
    friend void swap(Base& lhs, Base& rhs);
public:
    Base(int y = 0, string s = string("")):x(y), str(new string(s)) { cout << "Base Constructor" << endl; }
    Base(const Base& rhs):x(rhs.x), str(new string(*(rhs.str))) { cout << "Base Copy Constructor" << endl; }
    Base(Base&& rhs) noexcept;
    // Base& operator=(const Base& rhs);
    // Base& operator=(Base rhs); // Pass by value to leverage copy constructor
    Base& operator=(Base&& rhs) noexcept;
    ~Base() {
        delete str;
        str = nullptr; 
        cout << "Base Destructor" << endl; 
    }
private:
    int x;
    string* str = nullptr;
};

void swap(Base& lhs, Base& rhs) 
{
    using std::swap; // Enable ADL
    cout << "addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    swap(lhs.x, rhs.x);
    cout << "After swap: addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    
    cout << "addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
    swap(lhs.str, rhs.str);
    cout << "After swap: addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
}

// Move constructor
Base::Base(Base&& rhs) noexcept : x(rhs.x), str(rhs.str) {
    rhs.str = nullptr; // Leave rhs in a valid state
    cout << "Base Move Constructor" << endl;
}

// Move assignment operator
Base& Base::operator=(Base&& rhs) noexcept {
    cout << "Base Move Assignment operator" << endl;
    if (this != &rhs) {
        delete str; // Free existing resource
        x = rhs.x;
        str = rhs.str;
        rhs.str = nullptr; // Leave rhs in a valid state
    }
    return *this;
}

int main(void)
{
    Base b1(10, "Hello");
    Base b2(20, "World");

    b2 = std::move(b1); // Move assignment operator is called here
    b1 = Base(30, "Temporary"); // Move assignment operator is called here

    return 0;
}

/*
Base Constructor
Base Constructor
Base Move Assignment operator
Base Constructor
Base Move Assignment operator
Base Destructor
Base Destructor
Base Destructo
*/
```

#### 2.6.5 在移后源对象必须可析构

```cpp
class Buffer {
private:
    int* data;
public:
    // 移动构造函数（错误实现：未处理源对象）
    Buffer(Buffer&& other) : data(other.data) {
        // 未将other.data置空！
    }

    ~Buffer() {
        delete[] data; // 若源对象的data未置空，会在此处重复释放
    }
};

void func() {
    Buffer a;
    Buffer b = std::move(a); // a的data被转移给b，但a.data未置空
    // a即将超出作用域，其析构函数会释放已属于b的data → 崩溃
}
```

#### 2.6.6 合成移动操作

* 条件：

  * 若类中显示定义了拷贝构造函数、拷贝赋值运算符或析构函数。编译器就不会为它合成移动构造函数和移动赋值运算符。
  * 类未自定义任何拷贝控制成员（拷贝构造、拷贝赋值、析构），且类中（非static）成员可以移动，编译器才会自动生成。

* 风险：

  * 成员的移动操作被删除或不可访问（如成员是`const`类型，无法移动赋值）。
  * 若成员析构函数被定义为删除或不可访问的，类的移动构造函数被删除。
  * 若有引用或`const`成员：移动赋值运算符被定义为删除。

  ```cpp
  class A {
  public:
      const int x; // const成员
      A(int x):x(x) {}
  };
  
  int main() {
      A a(1), b(2);
      a = std::move(b); // 编译错误：A的移动赋值运算符被删除（因const成员x）
      return 0;
  }
  ```

#### 2.6.7 移动迭代器（C+11）

移动迭代器（*move iterator*）：**将迭代器的解引用操作从 “拷贝” 转为 “移动”**，从而在遍历容器时高效地转移元素资源，而非复制资源。

* 配合算符进行高效：

```cpp
#include <algorithm>

std::vector<std::string> src = {"x", "y", "z"};
std::vector<std::string> dest(3);

// 用std::copy配合移动迭代器实现元素移动
std::copy(
    std::make_move_iterator(src.begin()),
    std::make_move_iterator(src.end()),
    dest.begin()
);
```

#### 2.6.8 右值引用和成员函数（重载）

* 成员函数可以使用`const X&`绑定左值引用`X&&`来绑定一个右值引用实现重载（拷贝构造函数和移动构造函数）。

```cpp
#include <iostream>
#include <string>
#include <utility>

using namespace std;

class Base;
void swap(Base& lhs, Base& rhs);

class Base 
{
    friend void swap(Base& lhs, Base& rhs);
public:
    Base(int y = 0, string s = string("")):x(y), str(new string(s)) { cout << "Base Constructor" << endl; }
    // 拷贝构造（左值引用）深拷贝
    Base(const Base& rhs);
    // 移动构造（右值引用）转移资源
    Base(Base&& rhs) noexcept;
    
    Base& operator=(const Base& rhs);
    Base& operator=(Base&& rhs) noexcept;
    ~Base() {
        delete str;
        str = nullptr; 
        cout << "Base Destructor" << endl; 
    }
private:
    int x;
    string* str = nullptr;
};

void swap(Base& lhs, Base& rhs) 
{
    using std::swap; // Enable ADL
    cout << "addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    swap(lhs.x, rhs.x);
    cout << "After swap: addr: lhs.x = " << &lhs.x << ", addr: rhs.x = " << &rhs.x << endl;
    
    cout << "addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
    swap(lhs.str, rhs.str);
    cout << "After swap: addr: lhs.str = " << lhs.str << ", addr: rhs.str = " << rhs.str << endl;
}

//  Copy constructor
Base::Base(const Base& rhs):x(rhs.x), str(new string(*(rhs.str))) 
{ 
    cout << "Base Copy Constructor" << endl; 
}

// Move constructor
Base::Base(Base&& rhs) noexcept : x(rhs.x), str(rhs.str) {
    rhs.str = nullptr; // Leave rhs in a valid state
    cout << "Base Move Constructor" << endl;
}

// Copy assignment operator
Base& Base::operator=(const Base& rhs) 
{
    cout << "Base Copy Assignment operator" << endl;
    if (this != &rhs) {
        x = rhs.x;
        delete str; // Free existing resource
        str = new string(*(rhs.str)); // Allocate new resource and copy
    }
    return *this;
}

// Move assignment operator
Base& Base::operator=(Base&& rhs) noexcept {
    cout << "Base Move Assignment operator" << endl;
    if (this != &rhs) {
        delete str; // Free existing resource
        x = rhs.x;
        str = rhs.str;
        rhs.str = nullptr; // Leave rhs in a valid state
    }
    return *this;
}

int main(void)
{
    // rvalueReferenceDemo();

    Base b1(10, "Hello");
    Base b2(20, "World");

    b2 = std::move(b1); // Move assignment operator is called here
    b1 = Base(30, "Temporary"); // Move assignment operator is called here

    return 0;
}


/*
Base Constructor
Base Constructor
Base Move Assignment operator
Base Constructor
Base Move Assignment operator
Base Destructor
Base Destructor
Base Destructo
*/
```

#### 2.6.9 右值可以调用成员函数：

```cpp
int main(void)
{
    string s = "Sample";
    string s1 = "Another Sample";
    auto n = (s + s1).find("ple");
    cout << "n = " << n << endl;

    return 0;
}

/*
n = 3
*/
```

#### 2.6.10 右值可以被赋值：

```cpp
int main(void)
{
    // rvalueReferenceDemo();

    Base b1(10, "Hello");
    Base b2(20, "World");

    b2 = std::move(b1); // Move assignment operator is called here
    b1 = Base(30, "Temporary"); // Move assignment operator is called here

    string s = "Sample";
    string s1 = "Another Sample";
    cout << "s + s1 = " << (s + s1) << endl;

    s + s1 = "Modified"; // Error: lvalue required as left operand of assignment

    cout << "s = " << s << endl; // s remains unchanged

    auto n = (s + s1).find("ple");
    cout << "n = " << n << endl;

    return 0;
}

/*
s + s1 = SampleAnother Sample
s = Sample
n = 3
*/
```

#### 2.6.11 引用限定符（C++11）

* 格式函数参数列表后添加引用限定符（*reference qualifier*）
  * `& `：只能被左值对象调用，返回左值引用，允许调用者修改对象内部数据
  * `&&`：只能被右值对象（通常是临时对象）调用，返回移动后的数据，避免不必要的拷贝
* 限制：如果同名的函数加了引用限定符，就都要加，或者都不加。
* `const`在`&`之前。通常使用`const &`和`&&`实现重载。

```cpp
#include <iostream>
#include <string>

class MyString {
private:
    std::string data;

public:
    // 构造函数
    MyString(std::string s) : data(std::move(s)) {}

    // 左值引用限定：只能被左值对象调用
    std::string& get_data() & {
        std::cout << "左值版本 get_data() 被调用\n";
        return data; // 返回左值引用，允许修改
    }

    // 右值引用限定：只能被右值对象调用
    std::string get_data() && {
        std::cout << "右值版本 get_data() 被调用\n";
        return std::move(data); // 移动数据，避免拷贝
    }

    // 普通成员函数，无引用限定（可被左值和右值调用）
    void print() const {
        std::cout << "数据: " << data << "\n";
    }
};

int main() {
    // 左值对象
    MyString left("左值字符串");
    left.print();
    std::string& l_ref = left.get_data(); // 调用左值版本
    l_ref += "（已修改）";
    left.print();

    // 右值对象（临时对象）
    MyString("右值字符串").print();
    std::string r_val = MyString("右值字符串").get_data(); // 调用右值版本
    std::cout << "从右值获取的数据: " << r_val << "\n";

    // 以下代码会编译错误，因为引用限定符限制了调用对象类型
    // std::string& err = MyString("错误示例").get_data(); // 右值不能调用左值版本
    // std::string err2 = left.get_data(); // 左值不能直接调用右值版本（需显式转换）

    return 0;
}

```

#### 2.6.12 何时优先使用移动而非拷贝？

移动操作适用于**临时对象**或**不再使用的对象**（通过`std::move`标记），例如：

- 函数返回临时对象（如`return Base(10);`）。
- 局部变量即将离开作用域（如`Base b = std::move(local_obj);`）。
- 容器扩容时转移元素（如`vector`的`push_back(std::move(obj))`）。

## 三、小结

1. **拷贝控制基础**：拷贝构造函数、拷贝赋值运算符和析构函数是管理类对象生命周期的核心。编译器会合成默认版本，但存在成员不可访问或特殊类型（引用、`const`）时可能被删除。
2. **三 / 五法则**：需要自定义析构函数时，通常需同时定义拷贝构造和拷贝赋值；C++11 新增移动操作，形成 “五法则”，移动操作通过右值引用实现资源高效转移。
3. **移动语义**：右值引用（`&&`）绑定临时对象，移动构造 / 赋值直接接管资源而非拷贝，需保证移后源对象可析构（如置空指针）。编译器仅在满足条件时合成移动操作。
4. **实用技巧**：
   - 用`=default`显式生成默认成员，`=delete`阻止拷贝。
   - 自定义`swap`结合拷贝 - 交换模式提升赋值的异常安全性。
   - 引用限定符（`&`/`&&`）可限制成员函数的调用对象类型，优化左值 / 右值处理逻辑。
5. **注意事项**：动态内存成员需区分值语义（深拷贝）和指针语义（引用计数）；移动操作仅适用于临时对象或不再使用的对象，避免误用`std::move`导致源对象失效。